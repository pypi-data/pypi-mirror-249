# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_core.ipynb.

# %% auto 0
__all__ = ['T', 'P', 'typed_dict_signature', 'typed_dict_defaults', 'typed_dict_func', 'typedict', 'dtyp', 'new', 'setkeywords']

# %% ../nbs/01_core.ipynb 6
from inspect import Signature, Parameter, get_annotations
from functools import wraps, partial

# %% ../nbs/01_core.ipynb 8
from typing import Self
from typing import TypedDict, Type, Callable, TypeVar, ParamSpec

# %% ../nbs/01_core.ipynb 10
#| export


# %% ../nbs/01_core.ipynb 12
from ptyp import Alias
from chck import isnone, istype
from nlit import __MODULE__, __NAME__, __QUALNAME__, __DOC__

# %% ../nbs/01_core.ipynb 14
#| export


# %% ../nbs/01_core.ipynb 16
T = TypeVar('T', bound=TypedDict)
P = ParamSpec('P')

# %% ../nbs/01_core.ipynb 17
def typed_dict_signature(__dct: T, **kwargs: TypedDict) -> Signature:
    '''Returns a Signature object for a TypedDict class.'''
    anns = get_annotations(__dct)
    kwds, prms = list(anns.keys()), list()
    
    for kwd, ann in zip(kwds, anns.values()):
        
        val = kwargs.get(kwd, None)
        if isnone(val) and istype(ann):
            try: 
                val = ann()
            except: 
                val = None
                
        prm = Parameter(kwd, Parameter.POSITIONAL_OR_KEYWORD, annotation=ann, default=val)
        prms.append(prm)
        
    return Signature(prms, return_annotation=__dct)

# %% ../nbs/01_core.ipynb 18
def typed_dict_defaults(
    __dct: T, *, 
    __sig: Signature | None = None, 
    __non: bool = True, 
    **kwargs: TypedDict
) -> T:
    '''Returns an instance of a TypedDict class with default values.'''
    sig = __sig or typed_dict_signature(__dct, **kwargs)
    
    defaults = {
        k: v.default for k, v in sig.parameters.items() 
        if v.default is not Parameter.empty
    }
    
    defaults.update({k:v for k,v in kwargs.items() if k in defaults})
    if not __non: defaults = {k:v for k,v in defaults.items() if not isnone(v)}
    return __dct(**defaults)

def typed_dict_func(
    __dct: T, __sig: Signature | None = None,
    __non: bool = True, 
) -> Callable[[T, Signature], Callable[P, T]]:
    return partial(typed_dict_defaults, __dct, __sig=__sig, __non=__non)

# %% ../nbs/01_core.ipynb 19
class typedict(dict):
    def __init_subclass__(cls: Type[Self], **defs: TypedDict) -> None:
        super().__init_subclass__()
        sub = defs.pop('__subclass', False)

        try:
            cls.__dct = defs.pop('__dct')
            cls.__non = defs.pop('__non', True)
            cls.__sig = defs.pop('__sig', typed_dict_signature(cls.__dct, **defs))
            
        except KeyError as err:
            if not sub: raise err
        return
    
    def __init__(self: Self, *args, **kwargs):
        kwargs.pop('__dct', None)
        kwargs.pop('__sig', None)
        __non = kwargs.pop('__non', True)
        kwds = typed_dict_defaults(type(self).__dct, __sig=type(self).__sig, __non=__non, **kwargs)
        super().__init__(*args, **kwds)
        
    def __instancecheck__(self, __instance) -> bool:
        return super().__instancecheck__(__instance) or isinstance(__instance, type(self).__dct)
    
    def dropnones(self: Self, inplace: bool = True) -> Self:
        bad = {k for k, v in self.items() if isnone(v)}
        if inplace:
            for k in bad: self.pop(k)
            return self
        sub = {k: v for k, v in self.items() if k in bad}
        return type(self)(sub)

# %% ../nbs/01_core.ipynb 20
@wraps(typedict, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
class dtyp(typedict, __subclass=True): ...

# %% ../nbs/01_core.ipynb 22
def new(d: TypedDict, **kwargs: TypedDict):
    def decorator(func: Callable):
        __non = kwargs.pop('__non', True)
        signature = typed_dict_signature(d, **kwargs)
        
        @wraps(func, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
        class wrapper(typedict, __dct=d, __sig=signature, __non=__non):
            ...
        wrapper.__signature__ = signature
        wrapper.__annotations__ = d.__annotations__
        try: 
            wrapper.__doc__  = d.__doc__
            wrapper.__call__ = d.__doc__
            wrapper.__init__.__signature__ = signature
            wrapper.__init__.__annotations__ = d.__annotations__
            wrapper.__annotations__ = d.__annotations__
        except: pass
        return wrapper
    
    return decorator

# %% ../nbs/01_core.ipynb 24
def setkeywords(d: TypedDict, **kwargs: TypedDict):
    
    def decorator(func: Callable):
        dropnones = kwargs.pop('__non', True)
        signature = typed_dict_signature(d, **kwargs)
        construct = typed_dict_func(d, signature, dropnones)
        
        @wraps(func, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__))
        def wrapper(**kwargs: Type[d]) -> Type[d]:
            kwds = construct(**kwargs)
            return d(**kwds)
        wrapper.__signature__ = signature
        return wrapper
    
    return decorator
