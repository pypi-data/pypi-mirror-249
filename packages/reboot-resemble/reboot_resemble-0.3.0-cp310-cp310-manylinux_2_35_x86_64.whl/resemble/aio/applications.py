import asyncio
import colorama
import os
import sys
import traceback
from colorama import Fore, Style
from resemble.aio.servicers import Servicer
from resemble.aio.tests import Resemble
from resemble.aio.workflows import Workflow
from resemble.controller.exceptions import InputError
from resemble.inspect.servicer import InspectServicer
from respect.logging import ERROR, set_log_level
from typing import Awaitable, Callable, Optional


class Application:
    """Entry point for all resemble applications."""

    def __init__(
        self,
        *,
        servicers: Optional[list[type[Servicer]]] = None,
        # A legacy gRPC servicer type can't be more specific than `type`,
        # because legacy gRPC servicers (as generated by the gRPC `protoc`
        # plugin) do not share any common base class other than `object`.
        legacy_grpc_servicers: Optional[list[type]] = None,
        initialize: Optional[Callable[[Workflow], Awaitable[None]]] = None,
    ):
        """
        :param servicers: the types of Resemble-powered servicers that this
                          Application will serve.
        :param legacy_grpc_servicers: the types of legacy gRPC servicers (not
                                      using Resemble libraries) that this
                                      Application will serve.

        :param initialize: will be called after the Application's servicers have
                       started for the first time, so that it can perform
                       initialization logic (e.g., creating some well-known
                       actors, loading some data, etc. It must do so in the
                       context of the given Workflow.

        TODO(benh): update the initialize function to be run in a transaction
        and ensure that the transaction has finished before serving any other
        calls on the servicers.
        """
        self._servicers = servicers
        self._legacy_grpc_servicers = legacy_grpc_servicers
        self._initialize = initialize

        # TODO(rjh, benh): set up a logging system that allows us to increase
        # the verbosity level of the logs by environment variable.
        #
        # See also: matching line in `resemble.aio.tests.Resemble.__init__`.
        set_log_level(ERROR)

        # NOTE: we construct a 'Resemble' instance here so that it can
        # perform any process wide initialization as early as possible
        # (e.g., initializing multiprocessing before any threads are
        # created)
        self._rsm = Resemble()

    async def run(self) -> int:
        """Runs the application and returns a status code indicating success
        or failure."""
        colorama.init()

        # TODO: support running an application from within K8s.
        if os.environ.get('RSM_DEV') != 'true':
            # TODO(benh): factor this and similar code in 'rsm.py' out into helpers.
            message = "Please use 'rsm dev' to run your application locally"
            if sys.stderr.isatty():
                print(
                    Fore.RED + Style.BRIGHT + message + Style.RESET_ALL,
                    file=sys.stderr,
                )
            else:
                print(message, file=sys.stderr)
            return 1

        name: Optional[str] = os.environ.get('RSM_DEV_NAME')

        directory: Optional[str] = os.environ.get('RSM_DOT_RSM_DEV_DIRECTORY')

        local_envoy: bool = os.environ.get(
            'RSM_DEV_LOCAL_ENVOY',
            'false',
        ).lower() == 'true'

        local_envoy_port: int = int(
            os.environ.get('RSM_DEV_LOCAL_ENVOY_PORT', '9991')
        )

        inspect_port: int = int(os.environ.get('RSM_DEV_INSPECT_PORT', '9992'))

        # We only want to initialize if the this is the first time
        # we're bringing up this application which is definitely the
        # case if 'name' is None since we'll be creating a temporary
        # directory otherwise we determine below based on whether or
        # not a directory already exists for this 'name'.
        initialize = name is None

        if name is not None:
            assert directory is not None

            # Check if this is the first time we're bringing up an
            # application with this name and thus need to initialize.
            initialize = not os.path.isdir(
                os.path.join(directory, f'{name}-sidecar')
            )

            try:
                os.makedirs(directory)
            except FileExistsError:
                # Directory likely already exists since that's the
                # whole purpose of '--name' in the first place!
                pass

        try:
            await self._rsm.up(
                servicers=self._servicers,
                legacy_grpc_servicers=self._legacy_grpc_servicers,
                local_envoy=local_envoy,
                local_envoy_port=local_envoy_port,
                directory=directory,
                name=name,
            )
        except InputError as e:
            print(e.reason, file=sys.stderr)
            return 1
        else:
            if initialize and self._initialize is not None:
                await self._initialize(
                    self._rsm.create_workflow(name='initialize')
                )

            # Serve the 'inspect' web app.
            #
            # TODO(benh): abstract/replace 'localhost.direct' once we
            # support running applications in K8s.
            inspect_static_server_task = asyncio.create_task(
                InspectServicer.run_static_server(
                    port=inspect_port,
                    uri=f'https://localhost.direct:{local_envoy_port}',
                )
            )

            # Wait forever unless we get cancelled!
            #
            # TODO(benh): have 'rsm.up()' return a tuple of (config,
            # future) so we can watch the future and if that ever
            # fails we should exit and return an error to the user.
            #
            # TODO(benh): also have 'rsm.up()' fail the future that it
            # returns to us if the local envoy that got started
            # happened to fail.
            forever = asyncio.Event()
            await forever.wait()
        finally:
            await self._rsm.down()

            try:
                inspect_static_server_task.cancel()
                await inspect_static_server_task
            except:
                pass

        return 0
