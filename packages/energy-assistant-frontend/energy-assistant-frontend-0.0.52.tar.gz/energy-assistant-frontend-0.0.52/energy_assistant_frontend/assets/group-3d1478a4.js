import{p as v,g as w,e as G,d as I,i as M,D as C,c as p,j as B,v as P,a as V,F as k,o as F,ag as O,ak as W,k as z}from"./index-17df1834.js";class b{constructor(s){let{x:l,y:t,width:e,height:i}=s;this.x=l,this.y=t,this.width=e,this.height=i}get top(){return this.y}get bottom(){return this.y+this.height}get left(){return this.x}get right(){return this.x+this.width}}function $(n,s){return{x:{before:Math.max(0,s.left-n.left),after:Math.max(0,n.right-s.right)},y:{before:Math.max(0,s.top-n.top),after:Math.max(0,n.bottom-s.bottom)}}}function q(n){return Array.isArray(n)?new b({x:n[0],y:n[1],width:0,height:0}):n.getBoundingClientRect()}function T(n){const s=n.getBoundingClientRect(),l=getComputedStyle(n),t=l.transform;if(t){let e,i,d,h,c;if(t.startsWith("matrix3d("))e=t.slice(9,-1).split(/, /),i=+e[0],d=+e[5],h=+e[12],c=+e[13];else if(t.startsWith("matrix("))e=t.slice(7,-1).split(/, /),i=+e[0],d=+e[3],h=+e[4],c=+e[5];else return new b(s);const x=l.transformOrigin,m=s.x-h-(1-i)*parseFloat(x),y=s.y-c-(1-d)*parseFloat(x.slice(x.indexOf(" ")+1)),r=i?s.width/i:n.offsetWidth+1,o=d?s.height/d:n.offsetHeight+1;return new b({x:m,y,width:r,height:o})}else return new b(s)}function D(n,s,l){if(typeof n.animate>"u")return{finished:Promise.resolve()};let t;try{t=n.animate(s,l)}catch{return{finished:Promise.resolve()}}return typeof t.finished>"u"&&(t.finished=new Promise(e=>{t.onfinish=()=>{e(t)}})),t}const H="cubic-bezier(0.4, 0, 0.2, 1)",N="cubic-bezier(0.0, 0, 0.2, 1)",j="cubic-bezier(0.4, 0, 1, 1)",J=v({modelValue:{type:null,default:void 0},multiple:Boolean,mandatory:[Boolean,String],max:Number,selectedClass:String,disabled:Boolean},"group"),L=v({value:null,disabled:Boolean,selectedClass:String},"group-item");function Q(n,s){let l=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!0;const t=w("useGroupItem");if(!t)throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");const e=G();I(Symbol.for(`${s.description}:id`),e);const i=M(s,null);if(!i){if(!l)return i;throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${s.description}`)}const d=C(n,"value"),h=p(()=>!!(i.disabled.value||n.disabled));i.register({id:e,value:d,disabled:h},t),B(()=>{i.unregister(e)});const c=p(()=>i.isSelected(e)),x=p(()=>c.value&&[i.selectedClass.value,n.selectedClass]);return P(c,m=>{t.emit("group:selected",{value:m})}),{id:e,isSelected:c,toggle:()=>i.select(e,!c.value),select:m=>i.select(e,m),selectedClass:x,value:d,disabled:h,group:i}}function X(n,s){let l=!1;const t=V([]),e=k(n,"modelValue",[],r=>r==null?[]:S(t,W(r)),r=>{const o=R(t,r);return n.multiple?o:o[0]}),i=w("useGroup");function d(r,o){const u=r,a=Symbol.for(`${s.description}:id`),g=z(a,i==null?void 0:i.vnode).indexOf(o);g>-1?t.splice(g,0,u):t.push(u)}function h(r){if(l)return;c();const o=t.findIndex(u=>u.id===r);t.splice(o,1)}function c(){const r=t.find(o=>!o.disabled);r&&n.mandatory==="force"&&!e.value.length&&(e.value=[r.id])}F(()=>{c()}),B(()=>{l=!0});function x(r,o){const u=t.find(a=>a.id===r);if(!(o&&(u!=null&&u.disabled)))if(n.multiple){const a=e.value.slice(),f=a.findIndex(E=>E===r),g=~f;if(o=o??!g,g&&n.mandatory&&a.length<=1||!g&&n.max!=null&&a.length+1>n.max)return;f<0&&o?a.push(r):f>=0&&!o&&a.splice(f,1),e.value=a}else{const a=e.value.includes(r);if(n.mandatory&&a)return;e.value=o??!a?[r]:[]}}function m(r){if(n.multiple,e.value.length){const o=e.value[0],u=t.findIndex(g=>g.id===o);let a=(u+r)%t.length,f=t[a];for(;f.disabled&&a!==u;)a=(a+r)%t.length,f=t[a];if(f.disabled)return;e.value=[t[a].id]}else{const o=t.find(u=>!u.disabled);o&&(e.value=[o.id])}}const y={register:d,unregister:h,selected:e,select:x,disabled:C(n,"disabled"),prev:()=>m(t.length-1),next:()=>m(1),isSelected:r=>e.value.includes(r),selectedClass:p(()=>n.selectedClass),items:p(()=>t),getItemIndex:r=>A(t,r)};return I(s,y),y}function A(n,s){const l=S(n,[s]);return l.length?n.findIndex(t=>t.id===l[0]):-1}function S(n,s){const l=[];return s.forEach(t=>{const e=n.find(d=>O(t,d.value)),i=n[t];(e==null?void 0:e.value)!=null?l.push(e.id):i!=null&&l.push(i.id)}),l}function R(n,s){const l=[];return s.forEach(t=>{const e=n.findIndex(i=>i.id===t);if(~e){const i=n[e];l.push(i.value!=null?i.value:e)}}),l}export{b as B,L as a,Q as b,D as c,N as d,j as e,$ as f,q as g,J as m,T as n,H as s,X as u};
