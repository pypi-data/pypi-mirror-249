Metadata-Version: 2.1
Name: nerdd-module
Version: 0.1.12
Summary: Base package to create NERDD modules
Home-page: https://github.com/molinfo-vienna/nerdd-module.git
Maintainer: Steffen Hirte
Maintainer-email: steffen.hirte@univie.ac.at
License: BSD 3-Clause License
Classifier: Intended Audience :: Science/Research
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: BSD License
Classifier: Programming Language :: C
Classifier: Programming Language :: Python
Classifier: Topic :: Software Development
Classifier: Topic :: Scientific/Engineering
Classifier: Operating System :: Microsoft :: Windows
Classifier: Operating System :: POSIX
Classifier: Operating System :: Unix
Classifier: Operating System :: MacOS
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Description-Content-Type: text/markdown
Provides-Extra: dev
Provides-Extra: test
License-File: LICENSE

# NERDD Module

This package provides the basis to implement molecular prediction modules in the
NERDD ecosystem.

## Installation

```bash
pip install -U nerdd-module
```


## Implement your own module

A new module is created by inheriting from the ```AbstractModel``` class. A 
preprocessing pipeline can be configured via calling the constructor of the superclass.
The actual prediction procedure is implemented in ```_predict_mols```:

```python
import pandas as pd
from typing import List
from rdkit.Chem import Mol
from nerdd_module import AbstractModel

class MyModel(AbstractModel):
    def __init__(self):
        super().__init__(
            preprocessing_pipeline="chembl_structure_pipeline",
        )

    def _predict_mols(self, mols: List[Mol], custom_param: int = 5) -> pd.DataFrame:
        # implement prediction logic and return a dataframe with new columns
        # containing values per input molecule
        return pd.DataFrame(dict(predictions=[custom_param]*len(mols)))
```

For custom preprocessing, specify ```preprocessing_pipeline="custom"``` when calling
the constructor of the superclass and override the method ```_preprocess_single_mol```:

```python
class MyModel(AbstractModel):
    def __init__(self):
        # important:
        super().__init__(preprocessing_pipeline="custom")

    def _preprocess_single_mol(self, mol: Mol) -> Tuple[Mol, List[str]]:
        # implement custom preprocessing logic here 
        # return preprocessed molecule and a list of error messages
        return preprocessed_mol, errors
    # ...
```


## Data specification


## Contribute

1. Fork and clone the code
2. Install test dependencies with ```pip install -e .[test]```
3. Run tests via ```pytest``` or ```pytest-watch``` (short: ```ptw```)
