/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
export const id = "vendors-node_modules_blocking-elements_dist_blocking-elements_js-node_modules_wicg-inert_dist-f20c59";
export const ids = ["vendors-node_modules_blocking-elements_dist_blocking-elements_js-node_modules_wicg-inert_dist-f20c59"];
export const modules = {

/***/ "./node_modules/blocking-elements/dist/blocking-elements.js":
/*!******************************************************************!*\
  !*** ./node_modules/blocking-elements/dist/blocking-elements.js ***!
  \******************************************************************/
/***/ (() => {

eval("/**\n * @license\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n(() => {\n  var _a, _b, _c;\n  /* Symbols for private properties */\n  const _blockingElements = Symbol();\n  const _alreadyInertElements = Symbol();\n  const _topElParents = Symbol();\n  const _siblingsToRestore = Symbol();\n  const _parentMO = Symbol();\n  /* Symbols for private static methods */\n  const _topChanged = Symbol();\n  const _swapInertedSibling = Symbol();\n  const _inertSiblings = Symbol();\n  const _restoreInertedSiblings = Symbol();\n  const _getParents = Symbol();\n  const _getDistributedChildren = Symbol();\n  const _isInertable = Symbol();\n  const _handleMutations = Symbol();\n  class BlockingElementsImpl {\n    constructor() {\n      /**\n       * The blocking elements.\n       */\n      this[_a] = [];\n      /**\n       * Used to keep track of the parents of the top element, from the element\n       * itself up to body. When top changes, the old top might have been removed\n       * from the document, so we need to memoize the inerted parents' siblings\n       * in order to restore their inerteness when top changes.\n       */\n      this[_b] = [];\n      /**\n       * Elements that are already inert before the first blocking element is\n       * pushed.\n       */\n      this[_c] = new Set();\n    }\n    destructor() {\n      // Restore original inertness.\n      this[_restoreInertedSiblings](this[_topElParents]);\n      // Note we don't want to make these properties nullable on the class,\n      // since then we'd need non-null casts in many places. Calling a method on\n      // a BlockingElements instance after calling destructor will result in an\n      // exception.\n      const nullable = this;\n      nullable[_blockingElements] = null;\n      nullable[_topElParents] = null;\n      nullable[_alreadyInertElements] = null;\n    }\n    get top() {\n      const elems = this[_blockingElements];\n      return elems[elems.length - 1] || null;\n    }\n    push(element) {\n      if (!element || element === this.top) {\n        return;\n      }\n      // Remove it from the stack, we'll bring it to the top.\n      this.remove(element);\n      this[_topChanged](element);\n      this[_blockingElements].push(element);\n    }\n    remove(element) {\n      const i = this[_blockingElements].indexOf(element);\n      if (i === -1) {\n        return false;\n      }\n      this[_blockingElements].splice(i, 1);\n      // Top changed only if the removed element was the top element.\n      if (i === this[_blockingElements].length) {\n        this[_topChanged](this.top);\n      }\n      return true;\n    }\n    pop() {\n      const top = this.top;\n      top && this.remove(top);\n      return top;\n    }\n    has(element) {\n      return this[_blockingElements].indexOf(element) !== -1;\n    }\n    /**\n     * Sets `inert` to all document elements except the new top element, its\n     * parents, and its distributed content.\n     */\n    [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {\n      const toKeepInert = this[_alreadyInertElements];\n      const oldParents = this[_topElParents];\n      // No new top, reset old top if any.\n      if (!newTop) {\n        this[_restoreInertedSiblings](oldParents);\n        toKeepInert.clear();\n        this[_topElParents] = [];\n        return;\n      }\n      const newParents = this[_getParents](newTop);\n      // New top is not contained in the main document!\n      if (newParents[newParents.length - 1].parentNode !== document.body) {\n        throw Error('Non-connected element cannot be a blocking element');\n      }\n      // Cast here because we know we'll call _inertSiblings on newParents\n      // below.\n      this[_topElParents] = newParents;\n      const toSkip = this[_getDistributedChildren](newTop);\n      // No previous top element.\n      if (!oldParents.length) {\n        this[_inertSiblings](newParents, toSkip, toKeepInert);\n        return;\n      }\n      let i = oldParents.length - 1;\n      let j = newParents.length - 1;\n      // Find common parent. Index 0 is the element itself (so stop before it).\n      while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {\n        i--;\n        j--;\n      }\n      // If up the parents tree there are 2 elements that are siblings, swap\n      // the inerted sibling.\n      if (oldParents[i] !== newParents[j]) {\n        this[_swapInertedSibling](oldParents[i], newParents[j]);\n      }\n      // Restore old parents siblings inertness.\n      i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));\n      // Make new parents siblings inert.\n      j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);\n    }\n    /**\n     * Swaps inertness between two sibling elements.\n     * Sets the property `inert` over the attribute since the inert spec\n     * doesn't specify if it should be reflected.\n     * https://html.spec.whatwg.org/multipage/interaction.html#inert\n     */\n    [_swapInertedSibling](oldInert, newInert) {\n      const siblingsToRestore = oldInert[_siblingsToRestore];\n      // oldInert is not contained in siblings to restore, so we have to check\n      // if it's inertable and if already inert.\n      if (this[_isInertable](oldInert) && !oldInert.inert) {\n        oldInert.inert = true;\n        siblingsToRestore.add(oldInert);\n      }\n      // If newInert was already between the siblings to restore, it means it is\n      // inertable and must be restored.\n      if (siblingsToRestore.has(newInert)) {\n        newInert.inert = false;\n        siblingsToRestore.delete(newInert);\n      }\n      newInert[_parentMO] = oldInert[_parentMO];\n      newInert[_siblingsToRestore] = siblingsToRestore;\n      oldInert[_parentMO] = undefined;\n      oldInert[_siblingsToRestore] = undefined;\n    }\n    /**\n     * Restores original inertness to the siblings of the elements.\n     * Sets the property `inert` over the attribute since the inert spec\n     * doesn't specify if it should be reflected.\n     * https://html.spec.whatwg.org/multipage/interaction.html#inert\n     */\n    [_restoreInertedSiblings](elements) {\n      for (const element of elements) {\n        const mo = element[_parentMO];\n        mo.disconnect();\n        element[_parentMO] = undefined;\n        const siblings = element[_siblingsToRestore];\n        for (const sibling of siblings) {\n          sibling.inert = false;\n        }\n        element[_siblingsToRestore] = undefined;\n      }\n    }\n    /**\n     * Inerts the siblings of the elements except the elements to skip. Stores\n     * the inerted siblings into the element's symbol `_siblingsToRestore`.\n     * Pass `toKeepInert` to collect the already inert elements.\n     * Sets the property `inert` over the attribute since the inert spec\n     * doesn't specify if it should be reflected.\n     * https://html.spec.whatwg.org/multipage/interaction.html#inert\n     */\n    [_inertSiblings](elements, toSkip, toKeepInert) {\n      for (const element of elements) {\n        // Assume element is not a Document, so it must have a parentNode.\n        const parent = element.parentNode;\n        const children = parent.children;\n        const inertedSiblings = new Set();\n        for (let j = 0; j < children.length; j++) {\n          const sibling = children[j];\n          // Skip the input element, if not inertable or to be skipped.\n          if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {\n            continue;\n          }\n          // Should be collected since already inerted.\n          if (toKeepInert && sibling.inert) {\n            toKeepInert.add(sibling);\n          } else {\n            sibling.inert = true;\n            inertedSiblings.add(sibling);\n          }\n        }\n        // Store the siblings that were inerted.\n        element[_siblingsToRestore] = inertedSiblings;\n        // Observe only immediate children mutations on the parent.\n        const mo = new MutationObserver(this[_handleMutations].bind(this));\n        element[_parentMO] = mo;\n        let parentToObserve = parent;\n        // If we're using the ShadyDOM polyfill, then our parent could be a\n        // shady root, which is an object that acts like a ShadowRoot, but isn't\n        // actually a node in the real DOM. Observe the real DOM parent instead.\n        const maybeShadyRoot = parentToObserve;\n        if (maybeShadyRoot.__shady && maybeShadyRoot.host) {\n          parentToObserve = maybeShadyRoot.host;\n        }\n        mo.observe(parentToObserve, {\n          childList: true\n        });\n      }\n    }\n    /**\n     * Handles newly added/removed nodes by toggling their inertness.\n     * It also checks if the current top Blocking Element has been removed,\n     * notifying and removing it.\n     */\n    [_handleMutations](mutations) {\n      const parents = this[_topElParents];\n      const toKeepInert = this[_alreadyInertElements];\n      for (const mutation of mutations) {\n        // If the target is a shadowRoot, get its host as we skip shadowRoots when\n        // computing _topElParents.\n        const target = mutation.target.host || mutation.target;\n        const idx = target === document.body ? parents.length : parents.indexOf(target);\n        const inertedChild = parents[idx - 1];\n        const inertedSiblings = inertedChild[_siblingsToRestore];\n        // To restore.\n        for (let i = 0; i < mutation.removedNodes.length; i++) {\n          const sibling = mutation.removedNodes[i];\n          if (sibling === inertedChild) {\n            console.info('Detected removal of the top Blocking Element.');\n            this.pop();\n            return;\n          }\n          if (inertedSiblings.has(sibling)) {\n            sibling.inert = false;\n            inertedSiblings.delete(sibling);\n          }\n        }\n        // To inert.\n        for (let i = 0; i < mutation.addedNodes.length; i++) {\n          const sibling = mutation.addedNodes[i];\n          if (!this[_isInertable](sibling)) {\n            continue;\n          }\n          if (toKeepInert && sibling.inert) {\n            toKeepInert.add(sibling);\n          } else {\n            sibling.inert = true;\n            inertedSiblings.add(sibling);\n          }\n        }\n      }\n    }\n    /**\n     * Returns if the element is inertable.\n     */\n    [_isInertable](element) {\n      return false === /^(style|template|script)$/.test(element.localName);\n    }\n    /**\n     * Returns the list of newParents of an element, starting from element\n     * (included) up to `document.body` (excluded).\n     */\n    [_getParents](element) {\n      const parents = [];\n      let current = element;\n      // Stop to body.\n      while (current && current !== document.body) {\n        // Skip shadow roots.\n        if (current.nodeType === Node.ELEMENT_NODE) {\n          parents.push(current);\n        }\n        // ShadowDom v1\n        if (current.assignedSlot) {\n          // Collect slots from deepest slot to top.\n          while (current = current.assignedSlot) {\n            parents.push(current);\n          }\n          // Continue the search on the top slot.\n          current = parents.pop();\n          continue;\n        }\n        current = current.parentNode || current.host;\n      }\n      return parents;\n    }\n    /**\n     * Returns the distributed children of the element's shadow root.\n     * Returns null if the element doesn't have a shadow root.\n     */\n    [_getDistributedChildren](element) {\n      const shadowRoot = element.shadowRoot;\n      if (!shadowRoot) {\n        return null;\n      }\n      const result = new Set();\n      let i;\n      let j;\n      let nodes;\n      const slots = shadowRoot.querySelectorAll('slot');\n      if (slots.length && slots[0].assignedNodes) {\n        for (i = 0; i < slots.length; i++) {\n          nodes = slots[i].assignedNodes({\n            flatten: true\n          });\n          for (j = 0; j < nodes.length; j++) {\n            if (nodes[j].nodeType === Node.ELEMENT_NODE) {\n              result.add(nodes[j]);\n            }\n          }\n        }\n        // No need to search for <content>.\n      }\n      return result;\n    }\n  }\n  document.$blockingElements = new BlockingElementsImpl();\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfYmxvY2tpbmdFbGVtZW50cyIsIlN5bWJvbCIsIl9hbHJlYWR5SW5lcnRFbGVtZW50cyIsIl90b3BFbFBhcmVudHMiLCJfc2libGluZ3NUb1Jlc3RvcmUiLCJfcGFyZW50TU8iLCJfdG9wQ2hhbmdlZCIsIl9zd2FwSW5lcnRlZFNpYmxpbmciLCJfaW5lcnRTaWJsaW5ncyIsIl9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzIiwiX2dldFBhcmVudHMiLCJfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbiIsIl9pc0luZXJ0YWJsZSIsIl9oYW5kbGVNdXRhdGlvbnMiLCJCbG9ja2luZ0VsZW1lbnRzSW1wbCIsImNvbnN0cnVjdG9yIiwiX2EiLCJfYiIsIl9jIiwiU2V0IiwiZGVzdHJ1Y3RvciIsIm51bGxhYmxlIiwidG9wIiwiZWxlbXMiLCJsZW5ndGgiLCJwdXNoIiwiZWxlbWVudCIsInJlbW92ZSIsImkiLCJpbmRleE9mIiwic3BsaWNlIiwicG9wIiwiaGFzIiwibmV3VG9wIiwidG9LZWVwSW5lcnQiLCJvbGRQYXJlbnRzIiwiY2xlYXIiLCJuZXdQYXJlbnRzIiwicGFyZW50Tm9kZSIsImRvY3VtZW50IiwiYm9keSIsIkVycm9yIiwidG9Ta2lwIiwiaiIsInNsaWNlIiwib2xkSW5lcnQiLCJuZXdJbmVydCIsInNpYmxpbmdzVG9SZXN0b3JlIiwiaW5lcnQiLCJhZGQiLCJkZWxldGUiLCJ1bmRlZmluZWQiLCJlbGVtZW50cyIsIm1vIiwiZGlzY29ubmVjdCIsInNpYmxpbmdzIiwic2libGluZyIsInBhcmVudCIsImNoaWxkcmVuIiwiaW5lcnRlZFNpYmxpbmdzIiwiTXV0YXRpb25PYnNlcnZlciIsImJpbmQiLCJwYXJlbnRUb09ic2VydmUiLCJtYXliZVNoYWR5Um9vdCIsIl9fc2hhZHkiLCJob3N0Iiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsIm11dGF0aW9ucyIsInBhcmVudHMiLCJtdXRhdGlvbiIsInRhcmdldCIsImlkeCIsImluZXJ0ZWRDaGlsZCIsInJlbW92ZWROb2RlcyIsImNvbnNvbGUiLCJpbmZvIiwiYWRkZWROb2RlcyIsInRlc3QiLCJsb2NhbE5hbWUiLCJjdXJyZW50Iiwibm9kZVR5cGUiLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwiYXNzaWduZWRTbG90Iiwic2hhZG93Um9vdCIsInJlc3VsdCIsIm5vZGVzIiwic2xvdHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiYXNzaWduZWROb2RlcyIsImZsYXR0ZW4iLCIkYmxvY2tpbmdFbGVtZW50cyJdLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvYmxvY2tpbmctZWxlbWVudHMudHM/NTQ4NSJdLCJzb3VyY2VzQ29udGVudCI6W251bGxdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0REEsQ0FBQyxNQUFLOztFQUNKO0VBQ0EsTUFBTUEsaUJBQWlCLEdBQUdDLE1BQU0sRUFBRTtFQUNsQyxNQUFNQyxxQkFBcUIsR0FBR0QsTUFBTSxFQUFFO0VBQ3RDLE1BQU1FLGFBQWEsR0FBR0YsTUFBTSxFQUFFO0VBQzlCLE1BQU1HLGtCQUFrQixHQUFHSCxNQUFNLEVBQUU7RUFDbkMsTUFBTUksU0FBUyxHQUFHSixNQUFNLEVBQUU7RUFFMUI7RUFDQSxNQUFNSyxXQUFXLEdBQUdMLE1BQU0sRUFBRTtFQUM1QixNQUFNTSxtQkFBbUIsR0FBR04sTUFBTSxFQUFFO0VBQ3BDLE1BQU1PLGNBQWMsR0FBR1AsTUFBTSxFQUFFO0VBQy9CLE1BQU1RLHVCQUF1QixHQUFHUixNQUFNLEVBQUU7RUFDeEMsTUFBTVMsV0FBVyxHQUFHVCxNQUFNLEVBQUU7RUFDNUIsTUFBTVUsdUJBQXVCLEdBQUdWLE1BQU0sRUFBRTtFQUN4QyxNQUFNVyxZQUFZLEdBQUdYLE1BQU0sRUFBRTtFQUM3QixNQUFNWSxnQkFBZ0IsR0FBR1osTUFBTSxFQUFFO0VBc0JqQyxNQUFNYSxvQkFBb0I7SUFBMUJDLFlBQUE7TUFDRTs7O01BR08sS0FBQUMsRUFBQSxDQUFtQixHQUE0QixFQUFFO01BRXhEOzs7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QUdDLEtBQUssQ0FBQzVELENBQUMsQ0FBQyxDQUFDOEQsYUFBYSxDQUFDO1lBQzdCQyxPQUFPLEVBQUU7V0FDVixDQUFDO1VBQ0YsS0FBS2hELENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRzRDLEtBQUssQ0FBQy9ELE1BQU0sRUFBRW1CLENBQUMsRUFBRSxFQUFFO1lBQ2pDLElBQUk0QyxLQUFLLENBQUM1QyxDQUFDLENBQUMsQ0FBQ3NDLFFBQVEsS0FBS0MsSUFBSSxDQUFDQyxZQUFZLEVBQUU7Y0FDM0NHLE1BQU0sQ0FBQ3JDLEdBQUcsQ0FBQ3NDLEtBQUssQ0FBQzVDLENBQUMsQ0FBZ0IsQ0FBQzs7OztRQUl6Qzs7TUFFRixPQUFPMkMsTUFBTTtJQUNmOztFQUdEL0MsUUFBeUMsQ0FBQ3FELGlCQUFpQixHQUN4RCxJQUFJOUUsb0JBQW9CLEVBQUU7QUFDaEMsQ0FBQyxFQUFDLENBQUUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmxvY2tpbmctZWxlbWVudHMvZGlzdC9ibG9ja2luZy1lbGVtZW50cy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/blocking-elements/dist/blocking-elements.js\n");

/***/ }),

/***/ "./node_modules/wicg-inert/dist/inert.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/wicg-inert/dist/inert.esm.js ***!
  \***************************************************/
/***/ (() => {

eval("var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n\n(function () {\n  // Return early if we're not running inside of the browser.\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  // Convenience function for converting NodeLists.\n  /** @type {typeof Array.prototype.slice} */\n  var slice = Array.prototype.slice;\n\n  /**\n   * IE has a non-standard name for \"matches\".\n   * @type {typeof Element.prototype.matches}\n   */\n  var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n  /** @type {string} */\n  var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n\n  /**\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n   * attribute.\n   *\n   * Its main functions are:\n   *\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\n   *\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\n   *   `deregister` method on `InertManager` for each managed inert node.\n   */\n\n  var InertRoot = function () {\n    /**\n     * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.\n     * @param {!InertManager} inertManager The global singleton InertManager object.\n     */\n    function InertRoot(rootElement, inertManager) {\n      _classCallCheck(this, InertRoot);\n\n      /** @type {!InertManager} */\n      this._inertManager = inertManager;\n\n      /** @type {!HTMLElement} */\n      this._rootElement = rootElement;\n\n      /**\n       * @type {!Set<!InertNode>}\n       * All managed focusable nodes in this InertRoot's subtree.\n       */\n      this._managedNodes = new Set();\n\n      // Make the subtree hidden from assistive technology\n      if (this._rootElement.hasAttribute('aria-hidden')) {\n        /** @type {?string} */\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n      } else {\n        this._savedAriaHidden = null;\n      }\n      this._rootElement.setAttribute('aria-hidden', 'true');\n\n      // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n      this._makeSubtreeUnfocusable(this._rootElement);\n\n      // Watch for:\n      // - any additions in the subtree: make them unfocusable too\n      // - any removals from the subtree: remove them from this inert root's managed nodes\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n      //   element, make that node a managed node.\n      this._observer = new MutationObserver(this._onMutation.bind(this));\n      this._observer.observe(this._rootElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n     * stored in this object and updates the state of all of the managed nodes.\n     */\n\n    _createClass(InertRoot, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._observer.disconnect();\n        if (this._rootElement) {\n          if (this._savedAriaHidden !== null) {\n            this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n          } else {\n            this._rootElement.removeAttribute('aria-hidden');\n          }\n        }\n        this._managedNodes.forEach(function (inertNode) {\n          this._unmanageNode(inertNode.node);\n        }, this);\n\n        // Note we cast the nulls to the ANY type here because:\n        // 1) We want the class properties to be declared as non-null, or else we\n        //    need even more casts throughout this code. All bets are off if an\n        //    instance has been destroyed and a method is called.\n        // 2) We don't want to cast \"this\", because we want type-aware optimizations\n        //    to know which properties we're setting.\n        this._observer = /** @type {?} */null;\n        this._rootElement = /** @type {?} */null;\n        this._managedNodes = /** @type {?} */null;\n        this._inertManager = /** @type {?} */null;\n      }\n\n      /**\n       * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\n       */\n    }, {\n      key: '_makeSubtreeUnfocusable',\n      /**\n       * @param {!Node} startNode\n       */\n      value: function _makeSubtreeUnfocusable(startNode) {\n        var _this2 = this;\n        composedTreeWalk(startNode, function (node) {\n          return _this2._visitNode(node);\n        });\n        var activeElement = document.activeElement;\n        if (!document.body.contains(startNode)) {\n          // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n          var node = startNode;\n          /** @type {!ShadowRoot|undefined} */\n          var root = undefined;\n          while (node) {\n            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n              root = /** @type {!ShadowRoot} */node;\n              break;\n            }\n            node = node.parentNode;\n          }\n          if (root) {\n            activeElement = root.activeElement;\n          }\n        }\n        if (startNode.contains(activeElement)) {\n          activeElement.blur();\n          // In IE11, if an element is already focused, and then set to tabindex=-1\n          // calling blur() will not actually move the focus.\n          // To work around this we call focus() on the body instead.\n          if (activeElement === document.activeElement) {\n            document.body.focus();\n          }\n        }\n      }\n\n      /**\n       * @param {!Node} node\n       */\n    }, {\n      key: '_visitNode',\n      value: function _visitNode(node) {\n        if (node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n        var element = /** @type {!HTMLElement} */node;\n\n        // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n        // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n        if (element !== this._rootElement && element.hasAttribute('inert')) {\n          this._adoptInertRoot(element);\n        }\n        if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n          this._manageNode(element);\n        }\n      }\n\n      /**\n       * Register the given node with this InertRoot and with InertManager.\n       * @param {!Node} node\n       */\n    }, {\n      key: '_manageNode',\n      value: function _manageNode(node) {\n        var inertNode = this._inertManager.register(node, this);\n        this._managedNodes.add(inertNode);\n      }\n\n      /**\n       * Unregister the given node with this InertRoot and with InertManager.\n       * @param {!Node} node\n       */\n    }, {\n      key: '_unmanageNode',\n      value: function _unmanageNode(node) {\n        var inertNode = this._inertManager.deregister(node, this);\n        if (inertNode) {\n          this._managedNodes['delete'](inertNode);\n        }\n      }\n\n      /**\n       * Unregister the entire subtree starting at `startNode`.\n       * @param {!Node} startNode\n       */\n    }, {\n      key: '_unmanageSubtree',\n      value: function _unmanageSubtree(startNode) {\n        var _this3 = this;\n        composedTreeWalk(startNode, function (node) {\n          return _this3._unmanageNode(node);\n        });\n      }\n\n      /**\n       * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n       * @param {!HTMLElement} node\n       */\n    }, {\n      key: '_adoptInertRoot',\n      value: function _adoptInertRoot(node) {\n        var inertSubroot = this._inertManager.getInertRoot(node);\n\n        // During initialisation this inert root may not have been registered yet,\n        // so register it now if need be.\n        if (!inertSubroot) {\n          this._inertManager.setInert(node, true);\n          inertSubroot = this._inertManager.getInertRoot(node);\n        }\n        inertSubroot.managedNodes.forEach(function (savedInertNode) {\n          this._manageNode(savedInertNode.node);\n        }, this);\n      }\n\n      /**\n       * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n       * @param {!Array<!MutationRecord>} records\n       * @param {!MutationObserver} self\n       */\n    }, {\n      key: '_onMutation',\n      value: function _onMutation(records, self) {\n        records.forEach(function (record) {\n          var target = /** @type {!HTMLElement} */record.target;\n          if (record.type === 'childList') {\n            // Manage added nodes\n            slice.call(record.addedNodes).forEach(function (node) {\n              this._makeSubtreeUnfocusable(node);\n            }, this);\n\n            // Un-manage removed nodes\n            slice.call(record.removedNodes).forEach(function (node) {\n              this._unmanageSubtree(node);\n            }, this);\n          } else if (record.type === 'attributes') {\n            if (record.attributeName === 'tabindex') {\n              // Re-initialise inert node if tabindex changes\n              this._manageNode(target);\n            } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n              // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n              // already managed nodes from this inert subroot.\n              this._adoptInertRoot(target);\n              var inertSubroot = this._inertManager.getInertRoot(target);\n              this._managedNodes.forEach(function (managedNode) {\n                if (target.contains(managedNode.node)) {\n                  inertSubroot._manageNode(managedNode.node);\n                }\n              });\n            }\n          }\n        }, this);\n      }\n    }, {\n      key: 'managedNodes',\n      get: function get() {\n        return new Set(this._managedNodes);\n      }\n\n      /** @return {boolean} */\n    }, {\n      key: 'hasSavedAriaHidden',\n      get: function get() {\n        return this._savedAriaHidden !== null;\n      }\n\n      /** @param {?string} ariaHidden */\n    }, {\n      key: 'savedAriaHidden',\n      set: function set(ariaHidden) {\n        this._savedAriaHidden = ariaHidden;\n      }\n\n      /** @return {?string} */,\n\n      get: function get() {\n        return this._savedAriaHidden;\n      }\n    }]);\n    return InertRoot;\n  }();\n\n  /**\n   * `InertNode` initialises and manages a single inert node.\n   * A node is inert if it is a descendant of one or more inert root elements.\n   *\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n   * is intrinsically focusable or not.\n   *\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\n   */\n\n  var InertNode = function () {\n    /**\n     * @param {!Node} node A focusable element to be made inert.\n     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\n     */\n    function InertNode(node, inertRoot) {\n      _classCallCheck(this, InertNode);\n\n      /** @type {!Node} */\n      this._node = node;\n\n      /** @type {boolean} */\n      this._overrodeFocusMethod = false;\n\n      /**\n       * @type {!Set<!InertRoot>} The set of descendant inert roots.\n       *    If and only if this set becomes empty, this node is no longer inert.\n       */\n      this._inertRoots = new Set([inertRoot]);\n\n      /** @type {?number} */\n      this._savedTabIndex = null;\n\n      /** @type {boolean} */\n      this._destroyed = false;\n\n      // Save any prior tabindex info and make this node untabbable\n      this.ensureUntabbable();\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.\n     * This makes the managed node focusable again and deletes all of the previously stored state.\n     */\n\n    _createClass(InertNode, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._throwIfDestroyed();\n        if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n          var element = /** @type {!HTMLElement} */this._node;\n          if (this._savedTabIndex !== null) {\n            element.setAttribute('tabindex', this._savedTabIndex);\n          } else {\n            element.removeAttribute('tabindex');\n          }\n\n          // Use `delete` to restore native focus method.\n          if (this._overrodeFocusMethod) {\n            delete element.focus;\n          }\n        }\n\n        // See note in InertRoot.destructor for why we cast these nulls to ANY.\n        this._node = /** @type {?} */null;\n        this._inertRoots = /** @type {?} */null;\n        this._destroyed = true;\n      }\n\n      /**\n       * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n       * If the object has been destroyed, any attempt to access it will cause an exception.\n       */\n    }, {\n      key: '_throwIfDestroyed',\n      /**\n       * Throw if user tries to access destroyed InertNode.\n       */\n      value: function _throwIfDestroyed() {\n        if (this.destroyed) {\n          throw new Error('Trying to access destroyed InertNode');\n        }\n      }\n\n      /** @return {boolean} */\n    }, {\n      key: 'ensureUntabbable',\n      /** Save the existing tabindex value and make the node untabbable and unfocusable */\n      value: function ensureUntabbable() {\n        if (this.node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n        var element = /** @type {!HTMLElement} */this.node;\n        if (matches.call(element, _focusableElementsString)) {\n          if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {\n            return;\n          }\n          if (element.hasAttribute('tabindex')) {\n            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n          }\n          element.setAttribute('tabindex', '-1');\n          if (element.nodeType === Node.ELEMENT_NODE) {\n            element.focus = function () {};\n            this._overrodeFocusMethod = true;\n          }\n        } else if (element.hasAttribute('tabindex')) {\n          this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\n          element.removeAttribute('tabindex');\n        }\n      }\n\n      /**\n       * Add another inert root to this inert node's set of managing inert roots.\n       * @param {!InertRoot} inertRoot\n       */\n    }, {\n      key: 'addInertRoot',\n      value: function addInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots.add(inertRoot);\n      }\n\n      /**\n       * Remove the given inert root from this inert node's set of managing inert roots.\n       * If the set of managing inert roots becomes empty, this node is no longer inert,\n       * so the object should be destroyed.\n       * @param {!InertRoot} inertRoot\n       */\n    }, {\n      key: 'removeInertRoot',\n      value: function removeInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots['delete'](inertRoot);\n        if (this._inertRoots.size === 0) {\n          this.destructor();\n        }\n      }\n    }, {\n      key: 'destroyed',\n      get: function get() {\n        return /** @type {!InertNode} */this._destroyed;\n      }\n    }, {\n      key: 'hasSavedTabIndex',\n      get: function get() {\n        return this._savedTabIndex !== null;\n      }\n\n      /** @return {!Node} */\n    }, {\n      key: 'node',\n      get: function get() {\n        this._throwIfDestroyed();\n        return this._node;\n      }\n\n      /** @param {?number} tabIndex */\n    }, {\n      key: 'savedTabIndex',\n      set: function set(tabIndex) {\n        this._throwIfDestroyed();\n        this._savedTabIndex = tabIndex;\n      }\n\n      /** @return {?number} */,\n\n      get: function get() {\n        this._throwIfDestroyed();\n        return this._savedTabIndex;\n      }\n    }]);\n    return InertNode;\n  }();\n\n  /**\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\n   *\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n   * is created for each such node, via the `_managedNodes` map.\n   */\n\n  var InertManager = function () {\n    /**\n     * @param {!Document} document\n     */\n    function InertManager(document) {\n      _classCallCheck(this, InertManager);\n      if (!document) {\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\n      }\n\n      /** @type {!Document} */\n      this._document = document;\n\n      /**\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertNode>}\n       */\n      this._managedNodes = new Map();\n\n      /**\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\n       * @type {!Map<!Node, !InertRoot>}\n       */\n      this._inertRoots = new Map();\n\n      /**\n       * Observer for mutations on `document.body`.\n       * @type {!MutationObserver}\n       */\n      this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n      // Add inert style.\n      addInertStyle(document.head || document.body || document.documentElement);\n\n      // Wait for document to be loaded.\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n      } else {\n        this._onDocumentLoaded();\n      }\n    }\n\n    /**\n     * Set whether the given element should be an inert root or not.\n     * @param {!HTMLElement} root\n     * @param {boolean} inert\n     */\n\n    _createClass(InertManager, [{\n      key: 'setInert',\n      value: function setInert(root, inert) {\n        if (inert) {\n          if (this._inertRoots.has(root)) {\n            // element is already inert\n            return;\n          }\n          var inertRoot = new InertRoot(root, this);\n          root.setAttribute('inert', '');\n          this._inertRoots.set(root, inertRoot);\n          // If not contained in the document, it must be in a shadowRoot.\n          // Ensure inert styles are added there.\n          if (!this._document.body.contains(root)) {\n            var parent = root.parentNode;\n            while (parent) {\n              if (parent.nodeType === 11) {\n                addInertStyle(parent);\n              }\n              parent = parent.parentNode;\n            }\n          }\n        } else {\n          if (!this._inertRoots.has(root)) {\n            // element is already non-inert\n            return;\n          }\n          var _inertRoot = this._inertRoots.get(root);\n          _inertRoot.destructor();\n          this._inertRoots['delete'](root);\n          root.removeAttribute('inert');\n        }\n      }\n\n      /**\n       * Get the InertRoot object corresponding to the given inert root element, if any.\n       * @param {!Node} element\n       * @return {!InertRoot|undefined}\n       */\n    }, {\n      key: 'getInertRoot',\n      value: function getInertRoot(element) {\n        return this._inertRoots.get(element);\n      }\n\n      /**\n       * Register the given InertRoot as managing the given node.\n       * In the case where the node has a previously existing inert root, this inert root will\n       * be added to its set of inert roots.\n       * @param {!Node} node\n       * @param {!InertRoot} inertRoot\n       * @return {!InertNode} inertNode\n       */\n    }, {\n      key: 'register',\n      value: function register(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (inertNode !== undefined) {\n          // node was already in an inert subtree\n          inertNode.addInertRoot(inertRoot);\n        } else {\n          inertNode = new InertNode(node, inertRoot);\n        }\n        this._managedNodes.set(node, inertNode);\n        return inertNode;\n      }\n\n      /**\n       * De-register the given InertRoot as managing the given inert node.\n       * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n       * node from the InertManager's set of managed nodes if it is destroyed.\n       * If the node is not currently managed, this is essentially a no-op.\n       * @param {!Node} node\n       * @param {!InertRoot} inertRoot\n       * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\n       */\n    }, {\n      key: 'deregister',\n      value: function deregister(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (!inertNode) {\n          return null;\n        }\n        inertNode.removeInertRoot(inertRoot);\n        if (inertNode.destroyed) {\n          this._managedNodes['delete'](node);\n        }\n        return inertNode;\n      }\n\n      /**\n       * Callback used when document has finished loading.\n       */\n    }, {\n      key: '_onDocumentLoaded',\n      value: function _onDocumentLoaded() {\n        // Find all inert roots in document and make them actually inert.\n        var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n        inertElements.forEach(function (inertElement) {\n          this.setInert(inertElement, true);\n        }, this);\n\n        // Comment this out to use programmatic API only.\n        this._observer.observe(this._document.body || this._document.documentElement, {\n          attributes: true,\n          subtree: true,\n          childList: true\n        });\n      }\n\n      /**\n       * Callback used when mutation observer detects attribute changes.\n       * @param {!Array<!MutationRecord>} records\n       * @param {!MutationObserver} self\n       */\n    }, {\n      key: '_watchForInert',\n      value: function _watchForInert(records, self) {\n        var _this = this;\n        records.forEach(function (record) {\n          switch (record.type) {\n            case 'childList':\n              slice.call(record.addedNodes).forEach(function (node) {\n                if (node.nodeType !== Node.ELEMENT_NODE) {\n                  return;\n                }\n                var inertElements = slice.call(node.querySelectorAll('[inert]'));\n                if (matches.call(node, '[inert]')) {\n                  inertElements.unshift(node);\n                }\n                inertElements.forEach(function (inertElement) {\n                  this.setInert(inertElement, true);\n                }, _this);\n              }, _this);\n              break;\n            case 'attributes':\n              if (record.attributeName !== 'inert') {\n                return;\n              }\n              var target = /** @type {!HTMLElement} */record.target;\n              var inert = target.hasAttribute('inert');\n              _this.setInert(target, inert);\n              break;\n          }\n        }, this);\n      }\n    }]);\n    return InertManager;\n  }();\n\n  /**\n   * Recursively walk the composed tree from |node|.\n   * @param {!Node} node\n   * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,\n   *     before descending into child nodes.\n   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n   */\n\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      var element = /** @type {!HTMLElement} */node;\n      if (callback) {\n        callback(element);\n      }\n\n      // Descend into node:\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\n      // up by the <content> or <shadow> elements. Descend straight into the\n      // ShadowRoot.\n      var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;\n      if (shadowRoot) {\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\n        return;\n      }\n\n      // If it is a <content> element, descend into distributed elements - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'content') {\n        var content = /** @type {!HTMLContentElement} */element;\n        // Verifies if ShadowDom v0 is supported.\n        var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n        for (var i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n\n      // If it is a <slot> element, descend into assigned nodes - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'slot') {\n        var slot = /** @type {!HTMLSlotElement} */element;\n        // Verify if ShadowDom v1 is supported.\n        var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({\n          flatten: true\n        }) : [];\n        for (var _i = 0; _i < _distributedNodes.length; _i++) {\n          composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n    }\n\n    // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n    // element, nor a <shadow> element recurse normally.\n    var child = node.firstChild;\n    while (child != null) {\n      composedTreeWalk(child, callback, shadowRootAncestor);\n      child = child.nextSibling;\n    }\n  }\n\n  /**\n   * Adds a style element to the node containing the inert specific styles\n   * @param {!Node} node\n   */\n  function addInertStyle(node) {\n    if (node.querySelector('style#inert-style, link#inert-style')) {\n      return;\n    }\n    var style = document.createElement('style');\n    style.setAttribute('id', 'inert-style');\n    style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\n    node.appendChild(style);\n  }\n  if (!HTMLElement.prototype.hasOwnProperty('inert')) {\n    /** @type {!InertManager} */\n    var inertManager = new InertManager(document);\n    Object.defineProperty(HTMLElement.prototype, 'inert', {\n      enumerable: true,\n      /** @this {!HTMLElement} */\n      get: function get() {\n        return this.hasAttribute('inert');\n      },\n      /** @this {!HTMLElement} */\n      set: function set(inert) {\n        inertManager.setInert(this, inert);\n      }\n    });\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIlR5cGVFcnJvciIsIndpbmRvdyIsInNsaWNlIiwiQXJyYXkiLCJtYXRjaGVzIiwiRWxlbWVudCIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nIiwiam9pbiIsIkluZXJ0Um9vdCIsInJvb3RFbGVtZW50IiwiaW5lcnRNYW5hZ2VyIiwiX2luZXJ0TWFuYWdlciIsIl9yb290RWxlbWVudCIsIl9tYW5hZ2VkTm9kZXMiLCJTZXQiLCJoYXNBdHRyaWJ1dGUiLCJfc2F2ZWRBcmlhSGlkZGVuIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUiLCJfb2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiX29uTXV0YXRpb24iLCJiaW5kIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwidmFsdWUiLCJkZXN0cnVjdG9yIiwiZGlzY29ubmVjdCIsInJlbW92ZUF0dHJpYnV0ZSIsImZvckVhY2giLCJpbmVydE5vZGUiLCJfdW5tYW5hZ2VOb2RlIiwibm9kZSIsInN0YXJ0Tm9kZSIsIl90aGlzMiIsImNvbXBvc2VkVHJlZVdhbGsiLCJfdmlzaXROb2RlIiwiYWN0aXZlRWxlbWVudCIsImRvY3VtZW50IiwiYm9keSIsImNvbnRhaW5zIiwicm9vdCIsInVuZGVmaW5lZCIsIm5vZGVUeXBlIiwiTm9kZSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUiLCJwYXJlbnROb2RlIiwiYmx1ciIsImZvY3VzIiwiRUxFTUVOVF9OT0RFIiwiZWxlbWVudCIsIl9hZG9wdEluZXJ0Um9vdCIsImNhbGwiLCJfbWFuYWdlTm9kZSIsInJlZ2lzdGVyIiwiYWRkIiwiZGVyZWdpc3RlciIsIl91bm1hbmFnZVN1YnRyZWUiLCJfdGhpczMiLCJpbmVydFN1YnJvb3QiLCJnZXRJbmVydFJvb3QiLCJzZXRJbmVydCIsIm1hbmFnZWROb2RlcyIsInNhdmVkSW5lcnROb2RlIiwicmVjb3JkcyIsInNlbGYiLCJyZWNvcmQiLCJ0eXBlIiwiYWRkZWROb2RlcyIsInJlbW92ZWROb2RlcyIsImF0dHJpYnV0ZU5hbWUiLCJtYW5hZ2VkTm9kZSIsImdldCIsInNldCIsImFyaWFIaWRkZW4iLCJJbmVydE5vZGUiLCJpbmVydFJvb3QiLCJfbm9kZSIsIl9vdmVycm9kZUZvY3VzTWV0aG9kIiwiX2luZXJ0Um9vdHMiLCJfc2F2ZWRUYWJJbmRleCIsIl9kZXN0cm95ZWQiLCJlbnN1cmVVbnRhYmJhYmxlIiwiX3Rocm93SWZEZXN0cm95ZWQiLCJkZXN0cm95ZWQiLCJFcnJvciIsInRhYkluZGV4IiwiaGFzU2F2ZWRUYWJJbmRleCIsImFkZEluZXJ0Um9vdCIsInJlbW92ZUluZXJ0Um9vdCIsInNpemUiLCJJbmVydE1hbmFnZXIiLCJfZG9jdW1lbnQiLCJNYXAiLCJfd2F0Y2hGb3JJbmVydCIsImFkZEluZXJ0U3R5bGUiLCJoZWFkIiwiZG9jdW1lbnRFbGVtZW50IiwicmVhZHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfb25Eb2N1bWVudExvYWRlZCIsImluZXJ0IiwiaGFzIiwicGFyZW50IiwiX2luZXJ0Um9vdCIsImluZXJ0RWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5lcnRFbGVtZW50IiwiX3RoaXMiLCJ1bnNoaWZ0IiwiY2FsbGJhY2siLCJzaGFkb3dSb290QW5jZXN0b3IiLCJzaGFkb3dSb290IiwibG9jYWxOYW1lIiwiY29udGVudCIsImRpc3RyaWJ1dGVkTm9kZXMiLCJnZXREaXN0cmlidXRlZE5vZGVzIiwic2xvdCIsIl9kaXN0cmlidXRlZE5vZGVzIiwiYXNzaWduZWROb2RlcyIsImZsYXR0ZW4iLCJfaSIsImNoaWxkIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicXVlcnlTZWxlY3RvciIsInN0eWxlIiwiY3JlYXRlRWxlbWVudCIsInRleHRDb250ZW50IiwiYXBwZW5kQ2hpbGQiLCJIVE1MRWxlbWVudCIsImhhc093blByb3BlcnR5Il0sInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3dpY2ctaW5lcnQvZGlzdC9pbmVydC5lc20uanM/Y2U2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICovXG5cbihmdW5jdGlvbiAoKSB7XG4gIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgKi9cbiAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgLyoqXG4gICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgKiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAqXG4gICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAqXG4gICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICovXG5cbiAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW5lcnRSb290O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICpcbiAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICpcbiAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgKi9cblxuXG4gIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnbm9kZScsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAqXG4gICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICovXG5cblxuICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgIC8qKlxuICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICovXG4gICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgfSxcbiAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAg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QUM7UUFDdkU7UUFDQTtNQUNGO0lBQ0Y7O0lBRUE7SUFDQTtJQUNBLElBQUlXLEtBQUssR0FBRzFGLElBQUksQ0FBQzJGLFVBQVU7SUFDM0IsT0FBT0QsS0FBSyxJQUFJLElBQUksRUFBRTtNQUNwQnZGLGdCQUFnQixDQUFDdUYsS0FBSyxFQUFFWixRQUFRLEVBQUVDLGtCQUFrQixDQUFDO01BQ3JEVyxLQUFLLEdBQUdBLEtBQUssQ0FBQ0UsV0FBVztJQUMzQjtFQUNGOztFQUVBO0FBQ0Y7QUFDQTtBQUNBO0VBQ0UsU0FBUzdCLGFBQWFBLENBQUMvRCxJQUFJLEVBQUU7SUFDM0IsSUFBSUEsSUFBSSxDQUFDNkYsYUFBYSxDQUFDLHFDQUFxQyxDQUFDLEVBQUU7TUFDN0Q7SUFDRjtJQUNBLElBQUlDLEtBQUssR0FBR3hGLFFBQVEsQ0FBQ3lGLGFBQWEsQ0FBQyxPQUFPLENBQUM7SUFDM0NELEtBQUssQ0FBQy9HLFlBQVksQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDO0lBQ3ZDK0csS0FBSyxDQUFDRSxXQUFXLEdBQUcsSUFBSSxHQUFHLGFBQWEsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxLQUFLLEdBQUcsSUFBSSxHQUFHLHdCQUF3QixHQUFHLGdDQUFnQyxHQUFHLDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLHdCQUF3QixHQUFHLEtBQUs7SUFDOVFoRyxJQUFJLENBQUNpRyxXQUFXLENBQUNILEtBQUssQ0FBQztFQUN6QjtFQUVBLElBQUksQ0FBQ0ksV0FBVyxDQUFDekksU0FBUyxDQUFDMEksY0FBYyxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ2xEO0lBQ0EsSUFBSTVILFlBQVksR0FBRyxJQUFJb0YsWUFBWSxDQUFDckQsUUFBUSxDQUFDO0lBRTdDbkQsTUFBTSxDQUFDQyxjQUFjLENBQUM4SSxXQUFXLENBQUN6SSxTQUFTLEVBQUUsT0FBTyxFQUFFO01BQ3BEVCxVQUFVLEVBQUUsSUFBSTtNQUNoQjtNQUNBd0YsR0FBRyxFQUFFLFNBQVNBLEdBQUdBLENBQUEsRUFBRztRQUNsQixPQUFPLElBQUksQ0FBQzVELFlBQVksQ0FBQyxPQUFPLENBQUM7TUFDbkMsQ0FBQztNQUNEO01BQ0E2RCxHQUFHLEVBQUUsU0FBU0EsR0FBR0EsQ0FBQzRCLEtBQUssRUFBRTtRQUN2QjlGLFlBQVksQ0FBQ3NELFFBQVEsQ0FBQyxJQUFJLEVBQUV3QyxLQUFLLENBQUM7TUFDcEM7SUFDRixDQUFDLENBQUM7RUFDSjtBQUNGLENBQUMsRUFBRSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dpY2ctaW5lcnQvZGlzdC9pbmVydC5lc20uanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/wicg-inert/dist/inert.esm.js\n");

/***/ })

};
