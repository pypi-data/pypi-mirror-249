/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
export const id = "src_common_string_filter_sequence-matching_ts";
export const ids = ["src_common_string_filter_sequence-matching_ts"];
export const modules = {

/***/ "./src/common/string/filter/char-code.ts":
/*!***********************************************!*\
  !*** ./src/common/string/filter/char-code.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharCode: () => (/* binding */ CharCode)\n/* harmony export */ });\n// MIT License\n\n// Copyright (c) 2015 - present Microsoft Corporation\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// Names from https://blog.codinghorror.com/ascii-pronunciation-rules-for-programmers/\n\n/**\n * An inlined enum containing useful character codes (to be used with String.charCodeAt).\n * Please leave the const keyword such that it gets inlined when compiled to JavaScript!\n */\nlet CharCode = /*#__PURE__*/function (CharCode) {\n  CharCode[CharCode[\"Null\"] = 0] = \"Null\";\n  CharCode[CharCode[\"Backspace\"] = 8] = \"Backspace\";\n  CharCode[CharCode[\"Tab\"] = 9] = \"Tab\";\n  CharCode[CharCode[\"LineFeed\"] = 10] = \"LineFeed\";\n  CharCode[CharCode[\"CarriageReturn\"] = 13] = \"CarriageReturn\";\n  CharCode[CharCode[\"Space\"] = 32] = \"Space\";\n  CharCode[CharCode[\"ExclamationMark\"] = 33] = \"ExclamationMark\";\n  CharCode[CharCode[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n  CharCode[CharCode[\"Hash\"] = 35] = \"Hash\";\n  CharCode[CharCode[\"DollarSign\"] = 36] = \"DollarSign\";\n  CharCode[CharCode[\"PercentSign\"] = 37] = \"PercentSign\";\n  CharCode[CharCode[\"Ampersand\"] = 38] = \"Ampersand\";\n  CharCode[CharCode[\"SingleQuote\"] = 39] = \"SingleQuote\";\n  CharCode[CharCode[\"OpenParen\"] = 40] = \"OpenParen\";\n  CharCode[CharCode[\"CloseParen\"] = 41] = \"CloseParen\";\n  CharCode[CharCode[\"Asterisk\"] = 42] = \"Asterisk\";\n  CharCode[CharCode[\"Plus\"] = 43] = \"Plus\";\n  CharCode[CharCode[\"Comma\"] = 44] = \"Comma\";\n  CharCode[CharCode[\"Dash\"] = 45] = \"Dash\";\n  CharCode[CharCode[\"Period\"] = 46] = \"Period\";\n  CharCode[CharCode[\"Slash\"] = 47] = \"Slash\";\n  CharCode[CharCode[\"Digit0\"] = 48] = \"Digit0\";\n  CharCode[CharCode[\"Digit1\"] = 49] = \"Digit1\";\n  CharCode[CharCode[\"Digit2\"] = 50] = \"Digit2\";\n  CharCode[CharCode[\"Digit3\"] = 51] = \"Digit3\";\n  CharCode[CharCode[\"Digit4\"] = 52] = \"Digit4\";\n  CharCode[CharCode[\"Digit5\"] = 53] = \"Digit5\";\n  CharCode[CharCode[\"Digit6\"] = 54] = \"Digit6\";\n  CharCode[CharCode[\"Digit7\"] = 55] = \"Digit7\";\n  CharCode[CharCode[\"Digit8\"] = 56] = \"Digit8\";\n  CharCode[CharCode[\"Digit9\"] = 57] = \"Digit9\";\n  CharCode[CharCode[\"Colon\"] = 58] = \"Colon\";\n  CharCode[CharCode[\"Semicolon\"] = 59] = \"Semicolon\";\n  CharCode[CharCode[\"LessThan\"] = 60] = \"LessThan\";\n  CharCode[CharCode[\"Equals\"] = 61] = \"Equals\";\n  CharCode[CharCode[\"GreaterThan\"] = 62] = \"GreaterThan\";\n  CharCode[CharCode[\"QuestionMark\"] = 63] = \"QuestionMark\";\n  CharCode[CharCode[\"AtSign\"] = 64] = \"AtSign\";\n  CharCode[CharCode[\"A\"] = 65] = \"A\";\n  CharCode[CharCode[\"B\"] = 66] = \"B\";\n  CharCode[CharCode[\"C\"] = 67] = \"C\";\n  CharCode[CharCode[\"D\"] = 68] = \"D\";\n  CharCode[CharCode[\"E\"] = 69] = \"E\";\n  CharCode[CharCode[\"F\"] = 70] = \"F\";\n  CharCode[CharCode[\"G\"] = 71] = \"G\";\n  CharCode[CharCode[\"H\"] = 72] = \"H\";\n  CharCode[CharCode[\"I\"] = 73] = \"I\";\n  CharCode[CharCode[\"J\"] = 74] = \"J\";\n  CharCode[CharCode[\"K\"] = 75] = \"K\";\n  CharCode[CharCode[\"L\"] = 76] = \"L\";\n  CharCode[CharCode[\"M\"] = 77] = \"M\";\n  CharCode[CharCode[\"N\"] = 78] = \"N\";\n  CharCode[CharCode[\"O\"] = 79] = \"O\";\n  CharCode[CharCode[\"P\"] = 80] = \"P\";\n  CharCode[CharCode[\"Q\"] = 81] = \"Q\";\n  CharCode[CharCode[\"R\"] = 82] = \"R\";\n  CharCode[CharCode[\"S\"] = 83] = \"S\";\n  CharCode[CharCode[\"T\"] = 84] = \"T\";\n  CharCode[CharCode[\"U\"] = 85] = \"U\";\n  CharCode[CharCode[\"V\"] = 86] = \"V\";\n  CharCode[CharCode[\"W\"] = 87] = \"W\";\n  CharCode[CharCode[\"X\"] = 88] = \"X\";\n  CharCode[CharCode[\"Y\"] = 89] = \"Y\";\n  CharCode[CharCode[\"Z\"] = 90] = \"Z\";\n  CharCode[CharCode[\"OpenSquareBracket\"] = 91] = \"OpenSquareBracket\";\n  CharCode[CharCode[\"Backslash\"] = 92] = \"Backslash\";\n  CharCode[CharCode[\"CloseSquareBracket\"] = 93] = \"CloseSquareBracket\";\n  CharCode[CharCode[\"Caret\"] = 94] = \"Caret\";\n  CharCode[CharCode[\"Underline\"] = 95] = \"Underline\";\n  CharCode[CharCode[\"BackTick\"] = 96] = \"BackTick\";\n  CharCode[CharCode[\"a\"] = 97] = \"a\";\n  CharCode[CharCode[\"b\"] = 98] = \"b\";\n  CharCode[CharCode[\"c\"] = 99] = \"c\";\n  CharCode[CharCode[\"d\"] = 100] = \"d\";\n  CharCode[CharCode[\"e\"] = 101] = \"e\";\n  CharCode[CharCode[\"f\"] = 102] = \"f\";\n  CharCode[CharCode[\"g\"] = 103] = \"g\";\n  CharCode[CharCode[\"h\"] = 104] = \"h\";\n  CharCode[CharCode[\"i\"] = 105] = \"i\";\n  CharCode[CharCode[\"j\"] = 106] = \"j\";\n  CharCode[CharCode[\"k\"] = 107] = \"k\";\n  CharCode[CharCode[\"l\"] = 108] = \"l\";\n  CharCode[CharCode[\"m\"] = 109] = \"m\";\n  CharCode[CharCode[\"n\"] = 110] = \"n\";\n  CharCode[CharCode[\"o\"] = 111] = \"o\";\n  CharCode[CharCode[\"p\"] = 112] = \"p\";\n  CharCode[CharCode[\"q\"] = 113] = \"q\";\n  CharCode[CharCode[\"r\"] = 114] = \"r\";\n  CharCode[CharCode[\"s\"] = 115] = \"s\";\n  CharCode[CharCode[\"t\"] = 116] = \"t\";\n  CharCode[CharCode[\"u\"] = 117] = \"u\";\n  CharCode[CharCode[\"v\"] = 118] = \"v\";\n  CharCode[CharCode[\"w\"] = 119] = \"w\";\n  CharCode[CharCode[\"x\"] = 120] = \"x\";\n  CharCode[CharCode[\"y\"] = 121] = \"y\";\n  CharCode[CharCode[\"z\"] = 122] = \"z\";\n  CharCode[CharCode[\"OpenCurlyBrace\"] = 123] = \"OpenCurlyBrace\";\n  CharCode[CharCode[\"Pipe\"] = 124] = \"Pipe\";\n  CharCode[CharCode[\"CloseCurlyBrace\"] = 125] = \"CloseCurlyBrace\";\n  CharCode[CharCode[\"Tilde\"] = 126] = \"Tilde\";\n  return CharCode;\n}({});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL3N0cmluZy9maWx0ZXIvY2hhci1jb2RlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9zcmMvY29tbW9uL3N0cmluZy9maWx0ZXIvY2hhci1jb2RlLnRzPzBiZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTUlUIExpY2Vuc2VcblxuLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gcHJlc2VudCBNaWNyb3NvZnQgQ29ycG9yYXRpb25cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbi8vIFNPRlRXQVJFLlxuXG4vLyBOYW1lcyBmcm9tIGh0dHBzOi8vYmxvZy5jb2Rpbmdob3Jyb3IuY29tL2FzY2lpLXByb251bmNpYXRpb24tcnVsZXMtZm9yLXByb2dyYW1tZXJzL1xuXG4vKipcbiAqIEFuIGlubGluZWQgZW51bSBjb250YWluaW5nIHVzZWZ1bCBjaGFyYWN0ZXIgY29kZXMgKHRvIGJlIHVzZWQgd2l0aCBTdHJpbmcuY2hhckNvZGVBdCkuXG4gKiBQbGVhc2UgbGVhdmUgdGhlIGNvbnN0IGtleXdvcmQgc3VjaCB0aGF0IGl0IGdldHMgaW5saW5lZCB3aGVuIGNvbXBpbGVkIHRvIEphdmFTY3JpcHQhXG4gKi9cbmV4cG9ydCBlbnVtIENoYXJDb2RlIHtcbiAgTnVsbCA9IDAsXG4gIC8qKlxuICAgKiBUaGUgYFxcYmAgY2hhcmFjdGVyLlxuICAgKi9cbiAgQmFja3NwYWNlID0gOCxcbiAgLyoqXG4gICAqIFRoZSBgXFx0YCBjaGFyYWN0ZXIuXG4gICAqL1xuICBUYWIgPSA5LFxuICAvKipcbiAgICogVGhlIGBcXG5gIGNoYXJhY3Rlci5cbiAgICovXG4gIExpbmVGZWVkID0gMTAsXG4gIC8qKlxuICAgKiBUaGUgYFxccmAgY2hhcmFjdGVyLlxuICAgKi9cbiAgQ2FycmlhZ2VSZXR1cm4gPSAxMyxcbiAgU3BhY2UgPSAzMixcbiAgLyoqXG4gICAqIFRoZSBgIWAgY2hhcmFjdGVyLlxuICAgKi9cbiAgRXhjbGFtYXRpb25NYXJrID0gMzMsXG4gIC8qKlxuICAgKiBUaGUgYFwiYCBjaGFyYWN0ZXIuXG4gICAqL1xuICBEb3VibGVRdW90ZSA9IDM0LFxuICAvKipcbiAgICogVGhlIGAjYCBjaGFyYWN0ZXIuXG4gICAqL1xuICBIYXNoID0gMzUsXG4gIC8qKlxuICAgKiBUaGUgYCRgIGNoYXJhY3Rlci5cbiAgICovXG4gIERvbGxhclNpZ24gPSAzNixcbiAgLyoqXG4gICAqIFRoZSBgJWAgY2hhcmFjdGVyLlxuICAgKi9cbiAgUGVyY2VudFNpZ24gPSAzNyxcbiAgLyoqXG4gICAqIFRoZSBgJmAgY2hhcmFjdGVyLlxuICAgKi9cbiAgQW1wZXJzYW5kID0gMzgsXG4gIC8qKlxuICAgKiBUaGUgYCdgIGNoYXJhY3Rlci5cbiAgICovXG4gIFNpbmdsZVF1b3RlID0gMzksXG4gIC8qKlxuICAgKiBUaGUgYChgIGNoYXJhY3Rlci5cbiAgICovXG4gIE9wZW5QYXJlbiA9IDQwLFxuICAvKipcbiAgICogVGhlIGApYCBjaGFyYWN0ZXIuXG4gICAqL1xuICBDbG9zZVBhcmVuID0gNDEsXG4gIC8qKlxuICAgKiBUaGUgYCpgIGNoYXJhY3Rlci5cbiAgICovXG4gIEFzdGVyaXNrID0gNDIsXG4gIC8qKlxuICAgKiBUaGUgYCtgIGNoYXJhY3Rlci5cbiAgICovXG4gIFBsdXMgPSA0MyxcbiAgLyoqXG4gICAqIFRoZSBgLGAgY2hhcmFjdGVyLlxuICAgKi9cbiAgQ29tbWEgPSA0NCxcbiAgLyoqXG4gICAqIFRoZSBgLWAgY2hhcmFjdGVyLlxuICAgKi9cbiAgRGFzaCA9IDQ1LFxuICAvKipcbiAgICogVGhlIGAuYCBjaGFyYWN0ZXIuXG4gICAqL1xuICBQZXJpb2QgPSA0NixcbiAgLyoqXG4gICAqIFRoZSBgL2AgY2hhcmFjdGVyLlxuICAgKi9cbiAgU2xhc2ggPSA0NyxcblxuICBEaWdpdDAgPSA0OCxcbiAgRGlnaXQxID0gNDksXG4gIERpZ2l0MiA9IDUwLFxuICBEaWdpdDMgPSA1MSxcbiAgRGlnaXQ0ID0gNTIsXG4gIERpZ2l0NSA9IDUzLFxuICBEaWdpdDYgPSA1NCxcbiAgRGlnaXQ3ID0gNTUsXG4gIERpZ2l0OCA9IDU2LFxuICBEaWdpdDkgPSA1NyxcblxuICAvKipcbiAgICogVGhlIGA6YCBjaGFyYWN0ZXIuXG4gICAqL1xuICBDb2xvbiA9IDU4LFxuICAvKipcbiAgICogVGhlIGA7YCBjaGFyYWN0ZXIuXG4gICAqL1xuICBTZW1pY29sb24gPSA1OSxcbiAgLyoqXG4gICAqIFRoZSBgPGAgY2hhcmFjdGVyLlxuICAgKi9cbiAgTGVzc1RoYW4gPSA2MCxcbiAgLyoqXG4gICAqIFRoZSBgPWAgY2hhcmFjdGVyLlxuICAgKi9cbiAgRXF1YWxzID0gNjEsXG4gIC8qKlxuICAgKiBUaGUgYD5gIGNoYXJhY3Rlci5cbiAgICovXG4gIEdyZWF0ZXJUaGFuID0gNjIsXG4gIC8qKlxuICAgKiBUaGUgYD9gIGNoYXJhY3Rlci5cbiAgICovXG4gIFF1ZXN0aW9uTWFyayA9IDYzLFxuICAvKipcbiAgICogVGhlIGBAYCBjaGFyYWN0ZXIuXG4gICAqL1xuICBBdFNpZ24gPSA2NCxcblxuICBBID0gNjUsXG4gIEIgPSA2NixcbiAgQyA9IDY3LFxuICBEID0gNjgsXG4gIEUgPSA2OSxcbiAgRiA9IDcwLFxuICBHID0gNzEsXG4gIEggPSA3MixcbiAgSSA9IDczLFxuICBKID0gNzQsXG4gIEsgPSA3NSxcbiAgTCA9IDc2LFxuICBNID0gNzcsXG4gIE4gPSA3OCxcbiAgTyA9IDc5LFxuICBQID0gODAsXG4gIFEgPSA4MSxcbiAgUiA9IDgyLFxuICBTID0gODMsXG4gIFQgPSA4NCxcbiAgVSA9IDg1LFxuICBWID0gODYsXG4gIFcgPSA4NyxcbiAgWCA9IDg4LFxuICBZID0gODksXG4gIFogPSA5MCxcblxuICAvKipcbiAgICogVGhlIGBbYCBjaGFyYWN0ZXIuXG4gICAqL1xuICBPcGVuU3F1YXJlQnJhY2tldCA9IDkxLFxuICAvKipcbiAgICogVGhlIGBcXGAgY2hhcmFjdGVyLlxuICAgKi9cbiAgQmFja3NsYXNoID0gOTIsXG4gIC8qKlxuICAgKiBUaGUgYF1gIGNoYXJhY3Rlci5cbiAgICovXG4gIENsb3NlU3F1YXJlQnJhY2tldCA9IDkzLFxuICAvKipcbiAgICogVGhlIGBeYCBjaGFyYWN0ZXIuXG4gICAqL1xuICBDYXJldCA9IDk0LFxuICAvKipcbiAgICogVGhlIGBfYCBjaGFyYWN0ZXIuXG4gICAqL1xuICBVbmRlcmxpbmUgPSA5NSxcbiAgLyoqXG4gICAqIFRoZSBgYChgKWBgIGNoYXJhY3Rlci5cbiAgICovXG4gIEJhY2tUaWNrID0gOTYsXG5cbiAgYSA9IDk3LFxuICBiID0gOTgsXG4gIGMgPSA5OSxcbiAgZCA9IDEwMCxcbiAgZSA9IDEwMSxcbiAgZiA9IDEwMixcbiAgZyA9IDEwMyxcbiAgaCA9IDEwNCxcbiAgaSA9IDEwNSxcbiAgaiA9IDEwNixcbiAgayA9IDEwNyxcbiAgbCA9IDEwOCxcbiAgbSA9IDEwOSxcbiAgbiA9IDExMCxcbiAgbyA9IDExMSxcbiAgcCA9IDExMixcbiAgcSA9IDExMyxcbiAgciA9IDExNCxcbiAgcyA9IDExNSxcbiAgdCA9IDExNixcbiAgdSA9IDExNyxcbiAgdiA9IDExOCxcbiAgdyA9IDExOSxcbiAgeCA9IDEyMCxcbiAgeSA9IDEyMSxcbiAgeiA9IDEyMixcblxuICAvKipcbiAgICogVGhlIGB7YCBjaGFyYWN0ZXIuXG4gICAqL1xuICBPcGVuQ3VybHlCcmFjZSA9IDEyMyxcbiAgLyoqXG4gICAqIFRoZSBgfGAgY2hhcmFjdGVyLlxuICAgKi9cbiAgUGlwZSA9IDEyNCxcbiAgLyoqXG4gICAqIFRoZSBgfWAgY2hhcmFjdGVyLlxuICAgKi9cbiAgQ2xvc2VDdXJseUJyYWNlID0gMTI1LFxuICAvKipcbiAgICogVGhlIGB+YCBjaGFyYWN0ZXIuXG4gICAqL1xuICBUaWxkZSA9IDEyNixcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/common/string/filter/char-code.ts\n");

/***/ }),

/***/ "./src/common/string/filter/filter.ts":
/*!********************************************!*\
  !*** ./src/common/string/filter/filter.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMatches: () => (/* binding */ createMatches),\n/* harmony export */   fuzzyScore: () => (/* binding */ fuzzyScore),\n/* harmony export */   isEmojiImprecise: () => (/* binding */ isEmojiImprecise),\n/* harmony export */   isPatternInWord: () => (/* binding */ isPatternInWord)\n/* harmony export */ });\n/* harmony import */ var _char_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./char-code */ \"./src/common/string/filter/char-code.ts\");\n/* eslint-disable no-console */\n// MIT License\n\n// Copyright (c) 2015 - present Microsoft Corporation\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n\nconst _debug = false;\nconst _maxLen = 128;\nfunction initTable() {\n  const table = [];\n  const row = [];\n  for (let i = 0; i <= _maxLen; i++) {\n    row[i] = 0;\n  }\n  for (let i = 0; i <= _maxLen; i++) {\n    table.push(row.slice(0));\n  }\n  return table;\n}\nfunction isSeparatorAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.codePointAt(index);\n  switch (code) {\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.Underline:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.Dash:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.Period:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.Space:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.Slash:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.Backslash:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.SingleQuote:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.DoubleQuote:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.Colon:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.DollarSign:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.LessThan:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.OpenParen:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.OpenSquareBracket:\n      return true;\n    case undefined:\n      return false;\n    default:\n      if (isEmojiImprecise(code)) {\n        return true;\n      }\n      return false;\n  }\n}\nfunction isWhitespaceAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.charCodeAt(index);\n  switch (code) {\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.Space:\n    case _char_code__WEBPACK_IMPORTED_MODULE_0__.CharCode.Tab:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n  return word[pos] !== wordLow[pos];\n}\nfunction isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      if (fillMinWordPosArr) {\n        // Remember the min word position for each pattern position\n        _minWordMatchPos[patternPos] = wordPos;\n      }\n      patternPos += 1;\n    }\n    wordPos += 1;\n  }\n  return patternPos === patternLen; // pattern must be exhausted\n}\nvar Arrow = /*#__PURE__*/function (Arrow) {\n  Arrow[Arrow[\"Diag\"] = 1] = \"Diag\";\n  Arrow[Arrow[\"Left\"] = 2] = \"Left\";\n  Arrow[Arrow[\"LeftLeft\"] = 3] = \"LeftLeft\";\n  return Arrow;\n}(Arrow || {});\n/**\n * An array representing a fuzzy match.\n *\n * 0. the score\n * 1. the offset at which matching started\n * 2. `<match_pos_N>`\n * 3. `<match_pos_1>`\n * 4. `<match_pos_0>` etc\n */\n// export type FuzzyScore = [score: number, wordStart: number, ...matches: number[]];// [number, number, number];\nfunction fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\n  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  const wordLen = word.length > _maxLen ? _maxLen : word.length;\n  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {\n    return undefined;\n  }\n\n  // Run a simple check if the characters of pattern occur\n  // (in order) at all in word. If that isn't the case we\n  // stop because no match will be possible\n  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n    return undefined;\n  }\n\n  // Find the max matching word position for each pattern position\n  // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n  let row;\n  let column = 1;\n  let patternPos;\n  let wordPos;\n  const hasStrongFirstMatch = [false];\n\n  // There will be a match, fill in tables\n  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n    // Reduce search space to possible matching word positions and to possible access from next row\n    const minWordMatchPos = _minWordMatchPos[patternPos];\n    const maxWordMatchPos = _maxWordMatchPos[patternPos];\n    const nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;\n    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n      let score = Number.MIN_SAFE_INTEGER;\n      let canComeDiag = false;\n      if (wordPos <= maxWordMatchPos) {\n        score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n      }\n      let diagScore = 0;\n      if (score !== Number.MAX_SAFE_INTEGER) {\n        canComeDiag = true;\n        diagScore = score + _table[row - 1][column - 1];\n      }\n      const canComeLeft = wordPos > minWordMatchPos;\n      const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n      const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n      const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n        // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n        _table[row][column] = leftLeftScore;\n        _arrows[row][column] = Arrow.LeftLeft;\n        _diag[row][column] = 0;\n      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n        // always prefer choosing left since that means a match is earlier in the word\n        _table[row][column] = leftScore;\n        _arrows[row][column] = Arrow.Left;\n        _diag[row][column] = 0;\n      } else if (canComeDiag) {\n        _table[row][column] = diagScore;\n        _arrows[row][column] = Arrow.Diag;\n        _diag[row][column] = _diag[row - 1][column - 1] + 1;\n      } else {\n        throw new Error(`not possible`);\n      }\n    }\n  }\n  if (_debug) {\n    printTables(pattern, patternStart, word, wordStart);\n  }\n  if (!hasStrongFirstMatch[0] && !firstMatchCanBeWeak) {\n    return undefined;\n  }\n  row--;\n  column--;\n  const result = [_table[row][column], wordStart];\n  let backwardsDiagLength = 0;\n  let maxMatchColumn = 0;\n  while (row >= 1) {\n    // Find the column where we go diagonally up\n    let diagColumn = column;\n    do {\n      const arrow = _arrows[row][diagColumn];\n      if (arrow === Arrow.LeftLeft) {\n        diagColumn -= 2;\n      } else if (arrow === Arrow.Left) {\n        diagColumn -= 1;\n      } else {\n        // found the diagonal\n        break;\n      }\n    } while (diagColumn >= 1);\n\n    // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n    if (backwardsDiagLength > 1 &&\n    // only if we would have a contiguous match of 3 characters\n    patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] &&\n    // only if we can do a contiguous match diagonally\n    !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) &&\n    // only if the forwards chose diagonal is not an uppercase\n    backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n    ) {\n      diagColumn = column;\n    }\n    if (diagColumn === column) {\n      // this is a contiguous match\n      backwardsDiagLength++;\n    } else {\n      backwardsDiagLength = 1;\n    }\n    if (!maxMatchColumn) {\n      // remember the last matched column\n      maxMatchColumn = diagColumn;\n    }\n    row--;\n    column = diagColumn - 1;\n    result.push(column);\n  }\n  if (wordLen === patternLen) {\n    // the word matches the pattern with all characters!\n    // giving the score a total match boost (to come up ahead other words)\n    result[0] += 2;\n  }\n\n  // Add 1 penalty for each skipped character in the word\n  const skippedCharsCount = maxMatchColumn - patternLen;\n  result[0] -= skippedCharsCount;\n  return result;\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n  let score = 1;\n  let isGapLocation = false;\n  if (wordPos === patternPos - patternStart) {\n    // common prefix: `foobar <-> foobaz`\n    //                            ^^^^^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n    // hitting upper-case: `foo <-> forOthers`\n    //                              ^^ ^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    isGapLocation = true;\n  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n    // hitting a separator: `. <-> foo.bar`\n    //                                ^\n    score = 5;\n  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n    // post separator: `foo <-> bar_foo`\n    //                              ^^^\n    score = 5;\n    isGapLocation = true;\n  }\n  if (score > 1 && patternPos === patternStart) {\n    outFirstMatchStrong[0] = true;\n  }\n  if (!isGapLocation) {\n    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n  }\n\n  //\n  if (patternPos === patternStart) {\n    // first character in pattern\n    if (wordPos > wordStart) {\n      // the first pattern character would match a word character that is not at the word start\n      // so introduce a penalty to account for the gap preceding this match\n      score -= isGapLocation ? 3 : 5;\n    }\n  } else if (newMatchStart) {\n    // this would be the beginning of a new match (i.e. there would be a gap before this location)\n    score += isGapLocation ? 2 : 0;\n  } else {\n    // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a prefered gap location\n    score += isGapLocation ? 0 : 1;\n  }\n  if (wordPos + 1 === wordLen) {\n    // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n    // so pretend there is a gap after the last character in the word to normalize things\n    score -= isGapLocation ? 3 : 5;\n  }\n  return score;\n}\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n  function pad(s, n, _pad = \" \") {\n    while (s.length < n) {\n      s = _pad + s;\n    }\n    return s;\n  }\n  let ret = ` |   |${word.split(\"\").map(c => pad(c, 3)).join(\"|\")}\\n`;\n  for (let i = 0; i <= patternLen; i++) {\n    if (i === 0) {\n      ret += \" |\";\n    } else {\n      ret += `${pattern[i - 1]}|`;\n    }\n    ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join(\"|\") + \"\\n\";\n  }\n  return ret;\n}\nfunction printTables(pattern, patternStart, word, wordStart) {\n  pattern = pattern.substr(patternStart);\n  word = word.substr(wordStart);\n  console.log(printTable(_table, pattern, pattern.length, word, word.length));\n  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n  console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = initTable();\nfunction initArr(maxLen) {\n  const row = [];\n  for (let i = 0; i <= maxLen; i++) {\n    row[i] = 0;\n  }\n  return row;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n  let patternPos = patternLen - 1;\n  let wordPos = wordLen - 1;\n  while (patternPos >= patternStart && wordPos >= wordStart) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      _maxWordMatchPos[patternPos] = wordPos;\n      patternPos--;\n    }\n    wordPos--;\n  }\n}\nfunction createMatches(score) {\n  if (typeof score === \"undefined\") {\n    return [];\n  }\n  const res = [];\n  const wordPos = score[1];\n  for (let i = score.length - 1; i > 1; i--) {\n    const pos = score[i] + wordPos;\n    const last = res[res.length - 1];\n    if (last && last.end === pos) {\n      last.end = pos + 1;\n    } else {\n      res.push({\n        start: pos,\n        end: pos + 1\n      });\n    }\n  }\n  return res;\n}\n\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexdima/unicode-utils/blob/master/generate-emoji-test.js\n */\nfunction isEmojiImprecise(x) {\n  return x >= 0x1f1e6 && x <= 0x1f1ff || x === 8986 || x === 8987 || x === 9200 || x === 9203 || x >= 9728 && x <= 10175 || x === 11088 || x === 11093 || x >= 127744 && x <= 128591 || x >= 128640 && x <= 128764 || x >= 128992 && x <= 129003 || x >= 129280 && x <= 129535 || x >= 129648 && x <= 129750;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL3N0cmluZy9maWx0ZXIvZmlsdGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBU0E7QUFDQTtBQUVBO0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBYUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFJQTtBQUVBOztBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQWFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL3NyYy9jb21tb24vc3RyaW5nL2ZpbHRlci9maWx0ZXIudHM/ZWFhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4vLyBNSVQgTGljZW5zZVxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSBwcmVzZW50IE1pY3Jvc29mdCBDb3Jwb3JhdGlvblxuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuLy8gY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuLy8gU09GVFdBUkUuXG5cbmltcG9ydCB7IENoYXJDb2RlIH0gZnJvbSBcIi4vY2hhci1jb2RlXCI7XG5cbmNvbnN0IF9kZWJ1ZyA9IGZhbHNlO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1hdGNoIHtcbiAgc3RhcnQ6IG51bWJlcjtcbiAgZW5kOiBudW1iZXI7XG59XG5cbmNvbnN0IF9tYXhMZW4gPSAxMjg7XG5cbmZ1bmN0aW9uIGluaXRUYWJsZSgpIHtcbiAgY29uc3QgdGFibGU6IG51bWJlcltdW10gPSBbXTtcbiAgY29uc3Qgcm93OiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBfbWF4TGVuOyBpKyspIHtcbiAgICByb3dbaV0gPSAwO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IF9tYXhMZW47IGkrKykge1xuICAgIHRhYmxlLnB1c2gocm93LnNsaWNlKDApKTtcbiAgfVxuICByZXR1cm4gdGFibGU7XG59XG5cbmZ1bmN0aW9uIGlzU2VwYXJhdG9yQXRQb3ModmFsdWU6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHZhbHVlLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjb2RlID0gdmFsdWUuY29kZVBvaW50QXQoaW5kZXgpO1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIENoYXJDb2RlLlVuZGVybGluZTpcbiAgICBjYXNlIENoYXJDb2RlLkRhc2g6XG4gICAgY2FzZSBDaGFyQ29kZS5QZXJpb2Q6XG4gICAgY2FzZSBDaGFyQ29kZS5TcGFjZTpcbiAgICBjYXNlIENoYXJDb2RlLlNsYXNoOlxuICAgIGNhc2UgQ2hhckNvZGUuQmFja3NsYXNoOlxuICAgIGNhc2UgQ2hhckNvZGUuU2luZ2xlUXVvdGU6XG4gICAgY2FzZSBDaGFyQ29kZS5Eb3VibGVRdW90ZTpcbiAgICBjYXNlIENoYXJDb2RlLkNvbG9uOlxuICAgIGNhc2UgQ2hhckNvZGUuRG9sbGFyU2lnbjpcbiAgICBjYXNlIENoYXJDb2RlLkxlc3NUaGFuOlxuICAgIGNhc2UgQ2hhckNvZGUuT3BlblBhcmVuOlxuICAgIGNhc2UgQ2hhckNvZGUuT3BlblNxdWFyZUJyYWNrZXQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGlzRW1vamlJbXByZWNpc2UoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlQXRQb3ModmFsdWU6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHZhbHVlLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gIHN3aXRjaCAoY29kZSkge1xuICAgIGNhc2UgQ2hhckNvZGUuU3BhY2U6XG4gICAgY2FzZSBDaGFyQ29kZS5UYWI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVXBwZXJDYXNlQXRQb3MocG9zOiBudW1iZXIsIHdvcmQ6IHN0cmluZywgd29yZExvdzogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiB3b3JkW3Bvc10gIT09IHdvcmRMb3dbcG9zXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0dGVybkluV29yZChcbiAgcGF0dGVybkxvdzogc3RyaW5nLFxuICBwYXR0ZXJuUG9zOiBudW1iZXIsXG4gIHBhdHRlcm5MZW46IG51bWJlcixcbiAgd29yZExvdzogc3RyaW5nLFxuICB3b3JkUG9zOiBudW1iZXIsXG4gIHdvcmRMZW46IG51bWJlcixcbiAgZmlsbE1pbldvcmRQb3NBcnIgPSBmYWxzZVxuKTogYm9vbGVhbiB7XG4gIHdoaWxlIChwYXR0ZXJuUG9zIDwgcGF0dGVybkxlbiAmJiB3b3JkUG9zIDwgd29yZExlbikge1xuICAgIGlmIChwYXR0ZXJuTG93W3BhdHRlcm5Qb3NdID09PSB3b3JkTG93W3dvcmRQb3NdKSB7XG4gICAgICBpZiAoZmlsbE1pbldvcmRQb3NBcnIpIHtcbiAgICAgICAgLy8gUmVtZW1iZXIgdGhlIG1pbiB3b3JkIHBvc2l0aW9uIGZvciBlYWNoIHBhdHRlcm4gcG9zaXRpb25cbiAgICAgICAgX21pbldvcmRNYXRjaFBvc1twYXR0ZXJuUG9zXSA9IHdvcmRQb3M7XG4gICAgICB9XG4gICAgICBwYXR0ZXJuUG9zICs9IDE7XG4gICAgfVxuICAgIHdvcmRQb3MgKz0gMTtcbiAgfVxuICByZXR1cm4gcGF0dGVyblBvcyA9PT0gcGF0dGVybkxlbjsgLy8gcGF0dGVybiBtdXN0IGJlIGV4aGF1c3RlZFxufVxuXG5lbnVtIEFycm93IHtcbiAgRGlhZyA9IDEsXG4gIExlZnQgPSAyLFxuICBMZWZ0TGVmdCA9IDMsXG59XG5cbi8qKlxuICogQW4gYXJyYXkgcmVwcmVzZW50aW5nIGEgZnV6enkgbWF0Y2guXG4gKlxuICogMC4gdGhlIHNjb3JlXG4gKiAxLiB0aGUgb2Zmc2V0IGF0IHdoaWNoIG1hdGNoaW5nIHN0YXJ0ZWRcbiAqIDIuIGA8bWF0Y2hfcG9zX04+YFxuICogMy4gYDxtYXRjaF9wb3NfMT5gXG4gKiA0LiBgPG1hdGNoX3Bvc18wPmAgZXRjXG4gKi9cbi8vIGV4cG9ydCB0eXBlIEZ1enp5U2NvcmUgPSBbc2NvcmU6IG51bWJlciwgd29yZFN0YXJ0OiBudW1iZXIsIC4uLm1hdGNoZXM6IG51bWJlcltdXTsvLyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5leHBvcnQgdHlwZSBGdXp6eVNjb3JlID0gQXJyYXk8bnVtYmVyPjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZ1enp5U2NvcmUoXG4gIHBhdHRlcm46IHN0cmluZyxcbiAgcGF0dGVybkxvdzogc3RyaW5nLFxuICBwYXR0ZXJuU3RhcnQ6IG51bWJlcixcbiAgd29yZDogc3RyaW5nLFxuICB3b3JkTG93OiBzdHJpbmcsXG4gIHdvcmRTdGFydDogbnVtYmVyLFxuICBmaXJzdE1hdGNoQ2FuQmVXZWFrOiBib29sZWFuXG4pOiBGdXp6eVNjb3JlIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgcGF0dGVybkxlbiA9IHBhdHRlcm4ubGVuZ3RoID4gX21heExlbiA/IF9tYXhMZW4gOiBwYXR0ZXJuLmxlbmd0aDtcbiAgY29uc3Qgd29yZExlbiA9IHdvcmQubGVuZ3RoID4gX21heExlbiA/IF9tYXhMZW4gOiB3b3JkLmxlbmd0aDtcblxuICBpZiAoXG4gICAgcGF0dGVyblN0YXJ0ID49IHBhdHRlcm5MZW4gfHxcbiAgICB3b3JkU3RhcnQgPj0gd29yZExlbiB8fFxuICAgIHBhdHRlcm5MZW4gLSBwYXR0ZXJuU3RhcnQgPiB3b3JkTGVuIC0gd29yZFN0YXJ0XG4gICkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBSdW4gYSBzaW1wbGUgY2hlY2sgaWYgdGhlIGNoYXJhY3RlcnMgb2YgcGF0dGVybiBvY2N1clxuICAvLyAoaW4gb3JkZXIpIGF0IGFsbCBpbiB3b3JkLiBJZiB0aGF0IGlzbid0IHRoZSBjYXNlIHdlXG4gIC8vIHN0b3AgYmVjYXVzZSBubyBtYXRjaCB3aWxsIGJlIHBvc3NpYmxlXG4gIGlmIChcbiAgICAhaXNQYXR0ZXJuSW5Xb3JkKFxuICAgICAgcGF0dGVybkxvdyxcbiAgICAgIHBhdHRlcm5TdGFydCxcbiAgICAgIHBhdHRlcm5MZW4sXG4gICAgICB3b3JkTG93LFxuICAgICAgd29yZFN0YXJ0LFxuICAgICAgd29yZExlbixcbiAgICAgIHRydWVcbiAgICApXG4gICkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBGaW5kIHRoZSBtYXggbWF0Y2hpbmcgd29yZCBwb3NpdGlvbiBmb3IgZWFjaCBwYXR0ZXJuIHBvc2l0aW9uXG4gIC8vIE5PVEU6IHRoZSBtaW4gbWF0Y2hpbmcgd29yZCBwb3NpdGlvbiB3YXMgZmlsbGVkIGluIGFib3ZlLCBpbiB0aGUgYGlzUGF0dGVybkluV29yZGAgY2FsbFxuICBfZmlsbEluTWF4V29yZE1hdGNoUG9zKFxuICAgIHBhdHRlcm5MZW4sXG4gICAgd29yZExlbixcbiAgICBwYXR0ZXJuU3RhcnQsXG4gICAgd29yZFN0YXJ0LFxuICAgIHBhdHRlcm5Mb3csXG4gICAgd29yZExvd1xuICApO1xuXG4gIGxldCByb3c6IG51bWJlcjtcbiAgbGV0IGNvbHVtbiA9IDE7XG4gIGxldCBwYXR0ZXJuUG9zOiBudW1iZXI7XG4gIGxldCB3b3JkUG9zOiBudW1iZXI7XG5cbiAgY29uc3QgaGFzU3Ryb25nRmlyc3RNYXRjaCA9IFtmYWxzZV07XG5cbiAgLy8gVGhlcmUgd2lsbCBiZSBhIG1hdGNoLCBmaWxsIGluIHRhYmxlc1xuICBmb3IgKFxuICAgIHJvdyA9IDEsIHBhdHRlcm5Qb3MgPSBwYXR0ZXJuU3RhcnQ7XG4gICAgcGF0dGVyblBvcyA8IHBhdHRlcm5MZW47XG4gICAgcm93KyssIHBhdHRlcm5Qb3MrK1xuICApIHtcbiAgICAvLyBSZWR1Y2Ugc2VhcmNoIHNwYWNlIHRvIHBvc3NpYmxlIG1hdGNoaW5nIHdvcmQgcG9zaXRpb25zIGFuZCB0byBwb3NzaWJsZSBhY2Nlc3MgZnJvbSBuZXh0IHJvd1xuICAgIGNvbnN0IG1pbldvcmRNYXRjaFBvcyA9IF9taW5Xb3JkTWF0Y2hQb3NbcGF0dGVyblBvc107XG4gICAgY29uc3QgbWF4V29yZE1hdGNoUG9zID0gX21heFdvcmRNYXRjaFBvc1twYXR0ZXJuUG9zXTtcbiAgICBjb25zdCBuZXh0TWF4V29yZE1hdGNoUG9zID1cbiAgICAgIHBhdHRlcm5Qb3MgKyAxIDwgcGF0dGVybkxlbiA/IF9tYXhXb3JkTWF0Y2hQb3NbcGF0dGVyblBvcyArIDFdIDogd29yZExlbjtcblxuICAgIGZvciAoXG4gICAgICBjb2x1bW4gPSBtaW5Xb3JkTWF0Y2hQb3MgLSB3b3JkU3RhcnQgKyAxLCB3b3JkUG9zID0gbWluV29yZE1hdGNoUG9zO1xuICAgICAgd29yZFBvcyA8IG5leHRNYXhXb3JkTWF0Y2hQb3M7XG4gICAgICBjb2x1bW4rKywgd29yZFBvcysrXG4gICAgKSB7XG4gICAgICBsZXQgc2NvcmUgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgIGxldCBjYW5Db21lRGlhZyA9IGZhbHNlO1xuXG4gICAgICBpZiAod29yZFBvcyA8PSBtYXhXb3JkTWF0Y2hQb3MpIHtcbiAgICAgICAgc2NvcmUgPSBfZG9TY29yZShcbiAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgIHBhdHRlcm5Mb3csXG4gICAgICAgICAgcGF0dGVyblBvcyxcbiAgICAgICAgICBwYXR0ZXJuU3RhcnQsXG4gICAgICAgICAgd29yZCxcbiAgICAgICAgICB3b3JkTG93LFxuICAgICAgICAgIHdvcmRQb3MsXG4gICAgICAgICAgd29yZExlbixcbiAgICAgICAgICB3b3JkU3RhcnQsXG4gICAgICAgICAgX2RpYWdbcm93IC0gMV1bY29sdW1uIC0gMV0gPT09IDAsXG4gICAgICAgICAgaGFzU3Ryb25nRmlyc3RNYXRjaFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGlhZ1Njb3JlID0gMDtcbiAgICAgIGlmIChzY29yZSAhPT0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgY2FuQ29tZURpYWcgPSB0cnVlO1xuICAgICAgICBkaWFnU2NvcmUgPSBzY29yZSArIF90YWJsZVtyb3cgLSAxXVtjb2x1bW4gLSAxXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FuQ29tZUxlZnQgPSB3b3JkUG9zID4gbWluV29yZE1hdGNoUG9zO1xuICAgICAgY29uc3QgbGVmdFNjb3JlID0gY2FuQ29tZUxlZnRcbiAgICAgICAgPyBfdGFibGVbcm93XVtjb2x1bW4gLSAxXSArIChfZGlhZ1tyb3ddW2NvbHVtbiAtIDFdID4gMCA/IC01IDogMClcbiAgICAgICAgOiAwOyAvLyBwZW5hbHR5IGZvciBhIGdhcCBzdGFydFxuXG4gICAgICBjb25zdCBjYW5Db21lTGVmdExlZnQgPVxuICAgICAgICB3b3JkUG9zID4gbWluV29yZE1hdGNoUG9zICsgMSAmJiBfZGlhZ1tyb3ddW2NvbHVtbiAtIDFdID4gMDtcbiAgICAgIGNvbnN0IGxlZnRMZWZ0U2NvcmUgPSBjYW5Db21lTGVmdExlZnRcbiAgICAgICAgPyBfdGFibGVbcm93XVtjb2x1bW4gLSAyXSArIChfZGlhZ1tyb3ddW2NvbHVtbiAtIDJdID4gMCA/IC01IDogMClcbiAgICAgICAgOiAwOyAvLyBwZW5hbHR5IGZvciBhIGdhcCBzdGFydFxuXG4gICAgICBpZiAoXG4gICAgICAgIGNhbkNvbWVMZWZ0TGVmdCAmJlxuICAgICAgICAoIWNhbkNvbWVMZWZ0IHx8IGxlZnRMZWZ0U2NvcmUgPj0gbGVmdFNjb3JlKSAmJlxuICAgICAgICAoIWNhbkNvbWVEaWFnIHx8IGxlZnRMZWZ0U2NvcmUgPj0gZGlhZ1Njb3JlKVxuICAgICAgKSB7XG4gICAgICAgIC8vIGFsd2F5cyBwcmVmZXIgY2hvb3NpbmcgbGVmdCBsZWZ0IHRvIGp1bXAgb3ZlciBhIGRpYWdvbmFsIGJlY2F1c2UgdGhhdCBtZWFucyBhIG1hdGNoIGlzIGVhcmxpZXIgaW4gdGhlIHdvcmRcbiAgICAgICAgX3RhYmxlW3Jvd11bY29sdW1uXSA9IGxlZnRMZWZ0U2NvcmU7XG4gICAgICAgIF9hcnJvd3Nbcm93XVtjb2x1bW5dID0gQXJyb3cuTGVmdExlZnQ7XG4gICAgICAgIF9kaWFnW3Jvd11bY29sdW1uXSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGNhbkNvbWVMZWZ0ICYmICghY2FuQ29tZURpYWcgfHwgbGVmdFNjb3JlID49IGRpYWdTY29yZSkpIHtcbiAgICAgICAgLy8gYWx3YXlzIHByZWZlciBjaG9vc2luZyBsZWZ0IHNpbmNlIHRoYXQgbWVhbnMgYSBtYXRjaCBpcyBlYXJsaWVyIGluIHRoZSB3b3JkXG4gICAgICAgIF90YWJsZVtyb3ddW2NvbHVtbl0gPSBsZWZ0U2NvcmU7XG4gICAgICAgIF9hcnJvd3Nbcm93XVtjb2x1bW5dID0gQXJyb3cuTGVmdDtcbiAgICAgICAgX2RpYWdbcm93XVtjb2x1bW5dID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQ29tZURpYWcpIHtcbiAgICAgICAgX3RhYmxlW3Jvd11bY29sdW1uXSA9IGRpYWdTY29yZTtcbiAgICAgICAgX2Fycm93c1tyb3ddW2NvbHVtbl0gPSBBcnJvdy5EaWFnO1xuICAgICAgICBfZGlhZ1tyb3ddW2NvbHVtbl0gPSBfZGlhZ1tyb3cgLSAxXVtjb2x1bW4gLSAxXSArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBwb3NzaWJsZWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChfZGVidWcpIHtcbiAgICBwcmludFRhYmxlcyhwYXR0ZXJuLCBwYXR0ZXJuU3RhcnQsIHdvcmQsIHdvcmRTdGFydCk7XG4gIH1cblxuICBpZiAoIWhhc1N0cm9uZ0ZpcnN0TWF0Y2hbMF0gJiYgIWZpcnN0TWF0Y2hDYW5CZVdlYWspIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcm93LS07XG4gIGNvbHVtbi0tO1xuXG4gIGNvbnN0IHJlc3VsdDogRnV6enlTY29yZSA9IFtfdGFibGVbcm93XVtjb2x1bW5dLCB3b3JkU3RhcnRdO1xuXG4gIGxldCBiYWNrd2FyZHNEaWFnTGVuZ3RoID0gMDtcbiAgbGV0IG1heE1hdGNoQ29sdW1uID0gMDtcblxuICB3aGlsZSAocm93ID49IDEpIHtcbiAgICAvLyBGaW5kIHRoZSBjb2x1bW4gd2hlcmUgd2UgZ28gZGlhZ29uYWxseSB1cFxuICAgIGxldCBkaWFnQ29sdW1uID0gY29sdW1uO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IGFycm93ID0gX2Fycm93c1tyb3ddW2RpYWdDb2x1bW5dO1xuICAgICAgaWYgKGFycm93ID09PSBBcnJvdy5MZWZ0TGVmdCkge1xuICAgICAgICBkaWFnQ29sdW1uIC09IDI7XG4gICAgICB9IGVsc2UgaWYgKGFycm93ID09PSBBcnJvdy5MZWZ0KSB7XG4gICAgICAgIGRpYWdDb2x1bW4gLT0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZvdW5kIHRoZSBkaWFnb25hbFxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChkaWFnQ29sdW1uID49IDEpO1xuXG4gICAgLy8gT3ZlcnR1cm4gdGhlIFwiZm9yd2FyZHNcIiBkZWNpc2lvbiBpZiBrZWVwaW5nIHRoZSBcImJhY2t3YXJkc1wiIGRpYWdvbmFsIHdvdWxkIGdpdmUgYSBiZXR0ZXIgbWF0Y2hcbiAgICBpZiAoXG4gICAgICBiYWNrd2FyZHNEaWFnTGVuZ3RoID4gMSAmJiAvLyBvbmx5IGlmIHdlIHdvdWxkIGhhdmUgYSBjb250aWd1b3VzIG1hdGNoIG9mIDMgY2hhcmFjdGVyc1xuICAgICAgcGF0dGVybkxvd1twYXR0ZXJuU3RhcnQgKyByb3cgLSAxXSA9PT0gd29yZExvd1t3b3JkU3RhcnQgKyBjb2x1bW4gLSAxXSAmJiAvLyBvbmx5IGlmIHdlIGNhbiBkbyBhIGNvbnRpZ3VvdXMgbWF0Y2ggZGlhZ29uYWxseVxuICAgICAgIWlzVXBwZXJDYXNlQXRQb3MoZGlhZ0NvbHVtbiArIHdvcmRTdGFydCAtIDEsIHdvcmQsIHdvcmRMb3cpICYmIC8vIG9ubHkgaWYgdGhlIGZvcndhcmRzIGNob3NlIGRpYWdvbmFsIGlzIG5vdCBhbiB1cHBlcmNhc2VcbiAgICAgIGJhY2t3YXJkc0RpYWdMZW5ndGggKyAxID4gX2RpYWdbcm93XVtkaWFnQ29sdW1uXSAvLyBvbmx5IGlmIG91ciBjb250aWd1b3VzIG1hdGNoIHdvdWxkIGJlIGxvbmdlciB0aGFuIHRoZSBcImZvcndhcmRzXCIgY29udGlndW91cyBtYXRjaFxuICAgICkge1xuICAgICAgZGlhZ0NvbHVtbiA9IGNvbHVtbjtcbiAgICB9XG5cbiAgICBpZiAoZGlhZ0NvbHVtbiA9PT0gY29sdW1uKSB7XG4gICAgICAvLyB0aGlzIGlzIGEgY29udGlndW91cyBtYXRjaFxuICAgICAgYmFja3dhcmRzRGlhZ0xlbmd0aCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrd2FyZHNEaWFnTGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICBpZiAoIW1heE1hdGNoQ29sdW1uKSB7XG4gICAgICAvLyByZW1lbWJlciB0aGUgbGFzdCBtYXRjaGVkIGNvbHVtblxuICAgICAgbWF4TWF0Y2hDb2x1bW4gPSBkaWFnQ29sdW1uO1xuICAgIH1cblxuICAgIHJvdy0tO1xuICAgIGNvbHVtbiA9IGRpYWdDb2x1bW4gLSAxO1xuICAgIHJlc3VsdC5wdXNoKGNvbHVtbik7XG4gIH1cblxuICBpZiAod29yZExlbiA9PT0gcGF0dGVybkxlbikge1xuICAgIC8vIHRoZSB3b3JkIG1hdGNoZXMgdGhlIHBhdHRlcm4gd2l0aCBhbGwgY2hhcmFjdGVycyFcbiAgICAvLyBnaXZpbmcgdGhlIHNjb3JlIGEgdG90YWwgbWF0Y2ggYm9vc3QgKHRvIGNvbWUgdXAgYWhlYWQgb3RoZXIgd29yZHMpXG4gICAgcmVzdWx0WzBdICs9IDI7XG4gIH1cblxuICAvLyBBZGQgMSBwZW5hbHR5IGZvciBlYWNoIHNraXBwZWQgY2hhcmFjdGVyIGluIHRoZSB3b3JkXG4gIGNvbnN0IHNraXBwZWRDaGFyc0NvdW50ID0gbWF4TWF0Y2hDb2x1bW4gLSBwYXR0ZXJuTGVuO1xuICByZXN1bHRbMF0gLT0gc2tpcHBlZENoYXJzQ291bnQ7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gX2RvU2NvcmUoXG4gIHBhdHRlcm46IHN0cmluZyxcbiAgcGF0dGVybkxvdzogc3RyaW5nLFxuICBwYXR0ZXJuUG9zOiBudW1iZXIsXG4gIHBhdHRlcm5TdGFydDogbnVtYmVyLFxuICB3b3JkOiBzdHJpbmcsXG4gIHdvcmRMb3c6IHN0cmluZyxcbiAgd29yZFBvczogbnVtYmVyLFxuICB3b3JkTGVuOiBudW1iZXIsXG4gIHdvcmRTdGFydDogbnVtYmVyLFxuICBuZXdNYXRjaFN0YXJ0OiBib29sZWFuLFxuICBvdXRGaXJzdE1hdGNoU3Ryb25nOiBib29sZWFuW11cbik6IG51bWJlciB7XG4gIGlmIChwYXR0ZXJuTG93W3BhdHRlcm5Qb3NdICE9PSB3b3JkTG93W3dvcmRQb3NdKSB7XG4gICAgcmV0dXJuIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICB9XG5cbiAgbGV0IHNjb3JlID0gMTtcbiAgbGV0IGlzR2FwTG9jYXRpb24gPSBmYWxzZTtcbiAgaWYgKHdvcmRQb3MgPT09IHBhdHRlcm5Qb3MgLSBwYXR0ZXJuU3RhcnQpIHtcbiAgICAvLyBjb21tb24gcHJlZml4OiBgZm9vYmFyIDwtPiBmb29iYXpgXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5cbiAgICBzY29yZSA9IHBhdHRlcm5bcGF0dGVyblBvc10gPT09IHdvcmRbd29yZFBvc10gPyA3IDogNTtcbiAgfSBlbHNlIGlmIChcbiAgICBpc1VwcGVyQ2FzZUF0UG9zKHdvcmRQb3MsIHdvcmQsIHdvcmRMb3cpICYmXG4gICAgKHdvcmRQb3MgPT09IDAgfHwgIWlzVXBwZXJDYXNlQXRQb3Mod29yZFBvcyAtIDEsIHdvcmQsIHdvcmRMb3cpKVxuICApIHtcbiAgICAvLyBoaXR0aW5nIHVwcGVyLWNhc2U6IGBmb28gPC0+IGZvck90aGVyc2BcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eIF5cbiAgICBzY29yZSA9IHBhdHRlcm5bcGF0dGVyblBvc10gPT09IHdvcmRbd29yZFBvc10gPyA3IDogNTtcbiAgICBpc0dhcExvY2F0aW9uID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChcbiAgICBpc1NlcGFyYXRvckF0UG9zKHdvcmRMb3csIHdvcmRQb3MpICYmXG4gICAgKHdvcmRQb3MgPT09IDAgfHwgIWlzU2VwYXJhdG9yQXRQb3Mod29yZExvdywgd29yZFBvcyAtIDEpKVxuICApIHtcbiAgICAvLyBoaXR0aW5nIGEgc2VwYXJhdG9yOiBgLiA8LT4gZm9vLmJhcmBcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXlxuICAgIHNjb3JlID0gNTtcbiAgfSBlbHNlIGlmIChcbiAgICBpc1NlcGFyYXRvckF0UG9zKHdvcmRMb3csIHdvcmRQb3MgLSAxKSB8fFxuICAgIGlzV2hpdGVzcGFjZUF0UG9zKHdvcmRMb3csIHdvcmRQb3MgLSAxKVxuICApIHtcbiAgICAvLyBwb3N0IHNlcGFyYXRvcjogYGZvbyA8LT4gYmFyX2Zvb2BcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXlxuICAgIHNjb3JlID0gNTtcbiAgICBpc0dhcExvY2F0aW9uID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzY29yZSA+IDEgJiYgcGF0dGVyblBvcyA9PT0gcGF0dGVyblN0YXJ0KSB7XG4gICAgb3V0Rmlyc3RNYXRjaFN0cm9uZ1swXSA9IHRydWU7XG4gIH1cblxuICBpZiAoIWlzR2FwTG9jYXRpb24pIHtcbiAgICBpc0dhcExvY2F0aW9uID1cbiAgICAgIGlzVXBwZXJDYXNlQXRQb3Mod29yZFBvcywgd29yZCwgd29yZExvdykgfHxcbiAgICAgIGlzU2VwYXJhdG9yQXRQb3Mod29yZExvdywgd29yZFBvcyAtIDEpIHx8XG4gICAgICBpc1doaXRlc3BhY2VBdFBvcyh3b3JkTG93LCB3b3JkUG9zIC0gMSk7XG4gIH1cblxuICAvL1xuICBpZiAocGF0dGVyblBvcyA9PT0gcGF0dGVyblN0YXJ0KSB7XG4gICAgLy8gZmlyc3QgY2hhcmFjdGVyIGluIHBhdHRlcm5cbiAgICBpZiAod29yZFBvcyA+IHdvcmRTdGFydCkge1xuICAgICAgLy8gdGhlIGZpcnN0IHBhdHRlcm4gY2hhcmFjdGVyIHdvdWxkIG1hdGNoIGEgd29yZCBjaGFyYWN0ZXIgdGhhdCBpcyBub3QgYXQgdGhlIHdvcmQgc3RhcnRcbiAgICAgIC8vIHNvIGludHJvZHVjZSBhIHBlbmFsdHkgdG8gYWNjb3VudCBmb3IgdGhlIGdhcCBwcmVjZWRpbmcgdGhpcyBtYXRjaFxuICAgICAgc2NvcmUgLT0gaXNHYXBMb2NhdGlvbiA/IDMgOiA1O1xuICAgIH1cbiAgfSBlbHNlIGlmIChuZXdNYXRjaFN0YXJ0KSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSB0aGUgYmVnaW5uaW5nIG9mIGEgbmV3IG1hdGNoIChpLmUuIHRoZXJlIHdvdWxkIGJlIGEgZ2FwIGJlZm9yZSB0aGlzIGxvY2F0aW9uKVxuICAgIHNjb3JlICs9IGlzR2FwTG9jYXRpb24gPyAyIDogMDtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGlzIGlzIHBhcnQgb2YgYSBjb250aWd1b3VzIG1hdGNoLCBzbyBnaXZlIGl0IGEgc2xpZ2h0IGJvbnVzLCBidXQgZG8gc28gb25seSBpZiBpdCB3b3VsZCBub3QgYmUgYSBwcmVmZXJlZCBnYXAgbG9jYXRpb25cbiAgICBzY29yZSArPSBpc0dhcExvY2F0aW9uID8gMCA6IDE7XG4gIH1cblxuICBpZiAod29yZFBvcyArIDEgPT09IHdvcmRMZW4pIHtcbiAgICAvLyB3ZSBhbHdheXMgcGVuYWxpemUgZ2FwcywgYnV0IHRoaXMgZ2l2ZXMgdW5mYWlyIGFkdmFudGFnZXMgdG8gYSBtYXRjaCB0aGF0IHdvdWxkIG1hdGNoIHRoZSBsYXN0IGNoYXJhY3RlciBpbiB0aGUgd29yZFxuICAgIC8vIHNvIHByZXRlbmQgdGhlcmUgaXMgYSBnYXAgYWZ0ZXIgdGhlIGxhc3QgY2hhcmFjdGVyIGluIHRoZSB3b3JkIHRvIG5vcm1hbGl6ZSB0aGluZ3NcbiAgICBzY29yZSAtPSBpc0dhcExvY2F0aW9uID8gMyA6IDU7XG4gIH1cblxuICByZXR1cm4gc2NvcmU7XG59XG5cbmZ1bmN0aW9uIHByaW50VGFibGUoXG4gIHRhYmxlOiBudW1iZXJbXVtdLFxuICBwYXR0ZXJuOiBzdHJpbmcsXG4gIHBhdHRlcm5MZW46IG51bWJlcixcbiAgd29yZDogc3RyaW5nLFxuICB3b3JkTGVuOiBudW1iZXJcbik6IHN0cmluZyB7XG4gIGZ1bmN0aW9uIHBhZChzOiBzdHJpbmcsIG46IG51bWJlciwgX3BhZCA9IFwiIFwiKSB7XG4gICAgd2hpbGUgKHMubGVuZ3RoIDwgbikge1xuICAgICAgcyA9IF9wYWQgKyBzO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxuICBsZXQgcmV0ID0gYCB8ICAgfCR7d29yZFxuICAgIC5zcGxpdChcIlwiKVxuICAgIC5tYXAoKGMpID0+IHBhZChjLCAzKSlcbiAgICAuam9pbihcInxcIil9XFxuYDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwYXR0ZXJuTGVuOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0ICs9IFwiIHxcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ICs9IGAke3BhdHRlcm5baSAtIDFdfXxgO1xuICAgIH1cbiAgICByZXQgKz1cbiAgICAgIHRhYmxlW2ldXG4gICAgICAgIC5zbGljZSgwLCB3b3JkTGVuICsgMSlcbiAgICAgICAgLm1hcCgobikgPT4gcGFkKG4udG9TdHJpbmcoKSwgMykpXG4gICAgICAgIC5qb2luKFwifFwiKSArIFwiXFxuXCI7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gcHJpbnRUYWJsZXMoXG4gIHBhdHRlcm46IHN0cmluZyxcbiAgcGF0dGVyblN0YXJ0OiBudW1iZXIsXG4gIHdvcmQ6IHN0cmluZyxcbiAgd29yZFN0YXJ0OiBudW1iZXJcbik6IHZvaWQge1xuICBwYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIocGF0dGVyblN0YXJ0KTtcbiAgd29yZCA9IHdvcmQuc3Vic3RyKHdvcmRTdGFydCk7XG4gIGNvbnNvbGUubG9nKHByaW50VGFibGUoX3RhYmxlLCBwYXR0ZXJuLCBwYXR0ZXJuLmxlbmd0aCwgd29yZCwgd29yZC5sZW5ndGgpKTtcbiAgY29uc29sZS5sb2cocHJpbnRUYWJsZShfYXJyb3dzLCBwYXR0ZXJuLCBwYXR0ZXJuLmxlbmd0aCwgd29yZCwgd29yZC5sZW5ndGgpKTtcbiAgY29uc29sZS5sb2cocHJpbnRUYWJsZShfZGlhZywgcGF0dGVybiwgcGF0dGVybi5sZW5ndGgsIHdvcmQsIHdvcmQubGVuZ3RoKSk7XG59XG5cbmNvbnN0IF9taW5Xb3JkTWF0Y2hQb3MgPSBpbml0QXJyKDIgKiBfbWF4TGVuKTsgLy8gbWluIHdvcmQgcG9zaXRpb24gZm9yIGEgY2VydGFpbiBwYXR0ZXJuIHBvc2l0aW9uXG5jb25zdCBfbWF4V29yZE1hdGNoUG9zID0gaW5pdEFycigyICogX21heExlbik7IC8vIG1heCB3b3JkIHBvc2l0aW9uIGZvciBhIGNlcnRhaW4gcGF0dGVybiBwb3NpdGlvblxuY29uc3QgX2RpYWcgPSBpbml0VGFibGUoKTsgLy8gdGhlIGxlbmd0aCBvZiBhIGNvbnRpZ3VvdXMgZGlhZ29uYWwgbWF0Y2hcbmNvbnN0IF90YWJsZSA9IGluaXRUYWJsZSgpO1xuY29uc3QgX2Fycm93cyA9IDxBcnJvd1tdW10+aW5pdFRhYmxlKCk7XG5cbmZ1bmN0aW9uIGluaXRBcnIobWF4TGVuOiBudW1iZXIpIHtcbiAgY29uc3Qgcm93OiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXhMZW47IGkrKykge1xuICAgIHJvd1tpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHJvdztcbn1cblxuZnVuY3Rpb24gX2ZpbGxJbk1heFdvcmRNYXRjaFBvcyhcbiAgcGF0dGVybkxlbjogbnVtYmVyLFxuICB3b3JkTGVuOiBudW1iZXIsXG4gIHBhdHRlcm5TdGFydDogbnVtYmVyLFxuICB3b3JkU3RhcnQ6IG51bWJlcixcbiAgcGF0dGVybkxvdzogc3RyaW5nLFxuICB3b3JkTG93OiBzdHJpbmdcbikge1xuICBsZXQgcGF0dGVyblBvcyA9IHBhdHRlcm5MZW4gLSAxO1xuICBsZXQgd29yZFBvcyA9IHdvcmRMZW4gLSAxO1xuICB3aGlsZSAocGF0dGVyblBvcyA+PSBwYXR0ZXJuU3RhcnQgJiYgd29yZFBvcyA+PSB3b3JkU3RhcnQpIHtcbiAgICBpZiAocGF0dGVybkxvd1twYXR0ZXJuUG9zXSA9PT0gd29yZExvd1t3b3JkUG9zXSkge1xuICAgICAgX21heFdvcmRNYXRjaFBvc1twYXR0ZXJuUG9zXSA9IHdvcmRQb3M7XG4gICAgICBwYXR0ZXJuUG9zLS07XG4gICAgfVxuICAgIHdvcmRQb3MtLTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1enp5U2NvcmVyIHtcbiAgKFxuICAgIHBhdHRlcm46IHN0cmluZyxcbiAgICBsb3dQYXR0ZXJuOiBzdHJpbmcsXG4gICAgcGF0dGVyblBvczogbnVtYmVyLFxuICAgIHdvcmQ6IHN0cmluZyxcbiAgICBsb3dXb3JkOiBzdHJpbmcsXG4gICAgd29yZFBvczogbnVtYmVyLFxuICAgIGZpcnN0TWF0Y2hDYW5CZVdlYWs6IGJvb2xlYW5cbiAgKTogRnV6enlTY29yZSB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXMoc2NvcmU6IHVuZGVmaW5lZCB8IEZ1enp5U2NvcmUpOiBNYXRjaFtdIHtcbiAgaWYgKHR5cGVvZiBzY29yZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCByZXM6IE1hdGNoW10gPSBbXTtcbiAgY29uc3Qgd29yZFBvcyA9IHNjb3JlWzFdO1xuICBmb3IgKGxldCBpID0gc2NvcmUubGVuZ3RoIC0gMTsgaSA+IDE7IGktLSkge1xuICAgIGNvbnN0IHBvcyA9IHNjb3JlW2ldICsgd29yZFBvcztcbiAgICBjb25zdCBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LmVuZCA9PT0gcG9zKSB7XG4gICAgICBsYXN0LmVuZCA9IHBvcyArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcy5wdXNoKHsgc3RhcnQ6IHBvcywgZW5kOiBwb3MgKyAxIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEEgZmFzdCBmdW5jdGlvbiAodGhlcmVmb3JlIGltcHJlY2lzZSkgdG8gY2hlY2sgaWYgY29kZSBwb2ludHMgYXJlIGVtb2ppcy5cbiAqIEdlbmVyYXRlZCB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vYWxleGRpbWEvdW5pY29kZS11dGlscy9ibG9iL21hc3Rlci9nZW5lcmF0ZS1lbW9qaS10ZXN0LmpzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Vtb2ppSW1wcmVjaXNlKHg6IG51bWJlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgICh4ID49IDB4MWYxZTYgJiYgeCA8PSAweDFmMWZmKSB8fFxuICAgIHggPT09IDg5ODYgfHxcbiAgICB4ID09PSA4OTg3IHx8XG4gICAgeCA9PT0gOTIwMCB8fFxuICAgIHggPT09IDkyMDMgfHxcbiAgICAoeCA+PSA5NzI4ICYmIHggPD0gMTAxNzUpIHx8XG4gICAgeCA9PT0gMTEwODggfHxcbiAgICB4ID09PSAxMTA5MyB8fFxuICAgICh4ID49IDEyNzc0NCAmJiB4IDw9IDEyODU5MSkgfHxcbiAgICAoeCA+PSAxMjg2NDAgJiYgeCA8PSAxMjg3NjQpIHx8XG4gICAgKHggPj0gMTI4OTkyICYmIHggPD0gMTI5MDAzKSB8fFxuICAgICh4ID49IDEyOTI4MCAmJiB4IDw9IDEyOTUzNSkgfHxcbiAgICAoeCA+PSAxMjk2NDggJiYgeCA8PSAxMjk3NTApXG4gICk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/common/string/filter/filter.ts\n");

/***/ }),

/***/ "./src/common/string/filter/sequence-matching.ts":
/*!*******************************************************!*\
  !*** ./src/common/string/filter/sequence-matching.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fuzzyFilterSort: () => (/* binding */ fuzzyFilterSort),\n/* harmony export */   fuzzySequentialMatch: () => (/* binding */ fuzzySequentialMatch)\n/* harmony export */ });\n/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter */ \"./src/common/string/filter/filter.ts\");\n\n\n/**\n * Determine whether a sequence of letters exists in another string,\n *   in that order, allowing for skipping. Ex: \"chdr\" exists in \"chandelier\")\n *\n * @param {string} filter - Sequence of letters to check for\n * @param {ScorableTextItem} item - Item against whose strings will be checked\n *\n * @return {number} Score representing how well the word matches the filter. Return of 0 means no match.\n */\n\nconst fuzzySequentialMatch = (filter, item) => {\n  let topScore = Number.NEGATIVE_INFINITY;\n  for (const word of item.strings) {\n    const scores = (0,_filter__WEBPACK_IMPORTED_MODULE_0__.fuzzyScore)(filter, filter.toLowerCase(), 0, word, word.toLowerCase(), 0, true);\n    if (!scores) {\n      continue;\n    }\n\n    // The VS Code implementation of filter returns a 0 for a weak match.\n    // But if .filter() sees a \"0\", it considers that a failed match and will remove it.\n    // So, we set score to 1 in these cases so the match will be included, and mostly respect correct ordering.\n    const score = scores[0] === 0 ? 1 : scores[0];\n    if (score > topScore) {\n      topScore = score;\n    }\n  }\n  if (topScore === Number.NEGATIVE_INFINITY) {\n    return undefined;\n  }\n  return topScore;\n};\n\n/**\n * An interface that objects must extend in order to use the fuzzy sequence matcher\n *\n * @param {number} score - A number representing the existence and strength of a match.\n *    - `< 0` means a good match that starts in the middle of the string\n *    - `> 0` means a good match that starts at the beginning of the string\n *    - `0` means just barely a match\n *    - `undefined` means not a match\n *\n * @param {string} strings - Array of strings (aliases) representing the item. The filter string will be compared against each of these for a match.\n *\n */\n\nconst fuzzyFilterSort = (filter, items) => items.map(item => {\n  item.score = fuzzySequentialMatch(filter, item);\n  return item;\n}).filter(item => item.score !== undefined).sort(({\n  score: scoreA = 0\n}, {\n  score: scoreB = 0\n}) => scoreA > scoreB ? -1 : scoreA < scoreB ? 1 : 0);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL3N0cmluZy9maWx0ZXIvc2VxdWVuY2UtbWF0Y2hpbmcudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFFQTtBQUNBO0FBVUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFZQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9zcmMvY29tbW9uL3N0cmluZy9maWx0ZXIvc2VxdWVuY2UtbWF0Y2hpbmcudHM/YmI4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmdXp6eVNjb3JlIH0gZnJvbSBcIi4vZmlsdGVyXCI7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBzZXF1ZW5jZSBvZiBsZXR0ZXJzIGV4aXN0cyBpbiBhbm90aGVyIHN0cmluZyxcbiAqICAgaW4gdGhhdCBvcmRlciwgYWxsb3dpbmcgZm9yIHNraXBwaW5nLiBFeDogXCJjaGRyXCIgZXhpc3RzIGluIFwiY2hhbmRlbGllclwiKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWx0ZXIgLSBTZXF1ZW5jZSBvZiBsZXR0ZXJzIHRvIGNoZWNrIGZvclxuICogQHBhcmFtIHtTY29yYWJsZVRleHRJdGVtfSBpdGVtIC0gSXRlbSBhZ2FpbnN0IHdob3NlIHN0cmluZ3Mgd2lsbCBiZSBjaGVja2VkXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSBTY29yZSByZXByZXNlbnRpbmcgaG93IHdlbGwgdGhlIHdvcmQgbWF0Y2hlcyB0aGUgZmlsdGVyLiBSZXR1cm4gb2YgMCBtZWFucyBubyBtYXRjaC5cbiAqL1xuXG5leHBvcnQgY29uc3QgZnV6enlTZXF1ZW50aWFsTWF0Y2ggPSAoXG4gIGZpbHRlcjogc3RyaW5nLFxuICBpdGVtOiBTY29yYWJsZVRleHRJdGVtXG4pID0+IHtcbiAgbGV0IHRvcFNjb3JlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gIGZvciAoY29uc3Qgd29yZCBvZiBpdGVtLnN0cmluZ3MpIHtcbiAgICBjb25zdCBzY29yZXMgPSBmdXp6eVNjb3JlKFxuICAgICAgZmlsdGVyLFxuICAgICAgZmlsdGVyLnRvTG93ZXJDYXNlKCksXG4gICAgICAwLFxuICAgICAgd29yZCxcbiAgICAgIHdvcmQudG9Mb3dlckNhc2UoKSxcbiAgICAgIDAsXG4gICAgICB0cnVlXG4gICAgKTtcblxuICAgIGlmICghc2NvcmVzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBUaGUgVlMgQ29kZSBpbXBsZW1lbnRhdGlvbiBvZiBmaWx0ZXIgcmV0dXJucyBhIDAgZm9yIGEgd2VhayBtYXRjaC5cbiAgICAvLyBCdXQgaWYgLmZpbHRlcigpIHNlZXMgYSBcIjBcIiwgaXQgY29uc2lkZXJzIHRoYXQgYSBmYWlsZWQgbWF0Y2ggYW5kIHdpbGwgcmVtb3ZlIGl0LlxuICAgIC8vIFNvLCB3ZSBzZXQgc2NvcmUgdG8gMSBpbiB0aGVzZSBjYXNlcyBzbyB0aGUgbWF0Y2ggd2lsbCBiZSBpbmNsdWRlZCwgYW5kIG1vc3RseSByZXNwZWN0IGNvcnJlY3Qgb3JkZXJpbmcuXG4gICAgY29uc3Qgc2NvcmUgPSBzY29yZXNbMF0gPT09IDAgPyAxIDogc2NvcmVzWzBdO1xuXG4gICAgaWYgKHNjb3JlID4gdG9wU2NvcmUpIHtcbiAgICAgIHRvcFNjb3JlID0gc2NvcmU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRvcFNjb3JlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHRvcFNjb3JlO1xufTtcblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgdGhhdCBvYmplY3RzIG11c3QgZXh0ZW5kIGluIG9yZGVyIHRvIHVzZSB0aGUgZnV6enkgc2VxdWVuY2UgbWF0Y2hlclxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY29yZSAtIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgZXhpc3RlbmNlIGFuZCBzdHJlbmd0aCBvZiBhIG1hdGNoLlxuICogICAgLSBgPCAwYCBtZWFucyBhIGdvb2QgbWF0Y2ggdGhhdCBzdGFydHMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc3RyaW5nXG4gKiAgICAtIGA+IDBgIG1lYW5zIGEgZ29vZCBtYXRjaCB0aGF0IHN0YXJ0cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmdcbiAqICAgIC0gYDBgIG1lYW5zIGp1c3QgYmFyZWx5IGEgbWF0Y2hcbiAqICAgIC0gYHVuZGVmaW5lZGAgbWVhbnMgbm90IGEgbWF0Y2hcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5ncyAtIEFycmF5IG9mIHN0cmluZ3MgKGFsaWFzZXMpIHJlcHJlc2VudGluZyB0aGUgaXRlbS4gVGhlIGZpbHRlciBzdHJpbmcgd2lsbCBiZSBjb21wYXJlZCBhZ2FpbnN0IGVhY2ggb2YgdGhlc2UgZm9yIGEgbWF0Y2guXG4gKlxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NvcmFibGVUZXh0SXRlbSB7XG4gIHNjb3JlPzogbnVtYmVyO1xuICBzdHJpbmdzOiBzdHJpbmdbXTtcbn1cblxudHlwZSBGdXp6eUZpbHRlclNvcnQgPSA8VCBleHRlbmRzIFNjb3JhYmxlVGV4dEl0ZW0+KFxuICBmaWx0ZXI6IHN0cmluZyxcbiAgaXRlbXM6IFRbXVxuKSA9PiBUW107XG5cbmV4cG9ydCBjb25zdCBmdXp6eUZpbHRlclNvcnQ6IEZ1enp5RmlsdGVyU29ydCA9IChmaWx0ZXIsIGl0ZW1zKSA9PlxuICBpdGVtc1xuICAgIC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgIGl0ZW0uc2NvcmUgPSBmdXp6eVNlcXVlbnRpYWxNYXRjaChmaWx0ZXIsIGl0ZW0pO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSlcbiAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnNjb3JlICE9PSB1bmRlZmluZWQpXG4gICAgLnNvcnQoKHsgc2NvcmU6IHNjb3JlQSA9IDAgfSwgeyBzY29yZTogc2NvcmVCID0gMCB9KSA9PlxuICAgICAgc2NvcmVBID4gc2NvcmVCID8gLTEgOiBzY29yZUEgPCBzY29yZUIgPyAxIDogMFxuICAgICk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/common/string/filter/sequence-matching.ts\n");

/***/ })

};
