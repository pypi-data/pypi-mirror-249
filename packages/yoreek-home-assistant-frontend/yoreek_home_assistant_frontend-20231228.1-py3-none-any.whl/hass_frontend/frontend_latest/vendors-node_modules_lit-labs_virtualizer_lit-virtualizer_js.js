/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
export const id = "vendors-node_modules_lit-labs_virtualizer_lit-virtualizer_js";
export const ids = ["vendors-node_modules_lit-labs_virtualizer_lit-virtualizer_js"];
export const modules = {

/***/ "./node_modules/@lit-labs/virtualizer/LitVirtualizer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/LitVirtualizer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LitVirtualizer: () => (/* binding */ LitVirtualizer)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/decorators/property.js */ \"./node_modules/lit/decorators/property.js\");\n/* harmony import */ var _virtualize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./virtualize.js */ \"./node_modules/@lit-labs/virtualizer/virtualize.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\n\nclass LitVirtualizer extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {\n  constructor() {\n    super(...arguments);\n    this.items = [];\n    this.renderItem = _virtualize_js__WEBPACK_IMPORTED_MODULE_2__.defaultRenderItem;\n    this.keyFunction = _virtualize_js__WEBPACK_IMPORTED_MODULE_2__.defaultKeyFunction;\n    this.layout = {};\n    this.scroller = false;\n  }\n  createRenderRoot() {\n    return this;\n  }\n  render() {\n    const {\n      items,\n      renderItem,\n      keyFunction,\n      layout,\n      scroller\n    } = this;\n    return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`${(0,_virtualize_js__WEBPACK_IMPORTED_MODULE_2__.virtualize)({\n      items,\n      renderItem,\n      keyFunction,\n      layout,\n      scroller\n    })}`;\n  }\n  element(index) {\n    var _this$virtualizerRef;\n    return (_this$virtualizerRef = this[_virtualize_js__WEBPACK_IMPORTED_MODULE_2__.virtualizerRef]) === null || _this$virtualizerRef === void 0 ? void 0 : _this$virtualizerRef.element(index);\n  }\n  get layoutComplete() {\n    var _this$virtualizerRef2;\n    return (_this$virtualizerRef2 = this[_virtualize_js__WEBPACK_IMPORTED_MODULE_2__.virtualizerRef]) === null || _this$virtualizerRef2 === void 0 ? void 0 : _this$virtualizerRef2.layoutComplete;\n  }\n  /**\n   * This scrollToIndex() shim is here to provide backwards compatibility with other 0.x versions of\n   * lit-virtualizer. It is deprecated and will likely be removed in the 1.0.0 release.\n   */\n  scrollToIndex(index, position = 'start') {\n    var _this$element;\n    (_this$element = this.element(index)) === null || _this$element === void 0 || _this$element.scrollIntoView({\n      block: position\n    });\n  }\n}\n(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  attribute: false\n})], LitVirtualizer.prototype, \"items\", void 0);\n(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)()], LitVirtualizer.prototype, \"renderItem\", void 0);\n(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)()], LitVirtualizer.prototype, \"keyFunction\", void 0);\n(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  attribute: false\n})], LitVirtualizer.prototype, \"layout\", void 0);\n(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  reflect: true,\n  type: Boolean\n})], LitVirtualizer.prototype, \"scroller\", void 0);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL0xpdFZpcnR1YWxpemVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7OztBQU1BO0FBQ0E7QUFHQTtBQVNBO0FBQUE7O0FBRUE7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQW1DQTtBQWpDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUE5Q0E7QUFEQTtBQUFBO0FBSUE7QUFHQTtBQUdBO0FBREE7QUFBQTtBQUlBO0FBREE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL0xpdFZpcnR1YWxpemVyLnRzP2JiNjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbmltcG9ydCB7aHRtbCwgTGl0RWxlbWVudH0gZnJvbSAnbGl0JztcbmltcG9ydCB7cHJvcGVydHl9IGZyb20gJ2xpdC9kZWNvcmF0b3JzL3Byb3BlcnR5LmpzJztcbmltcG9ydCB7S2V5Rm59IGZyb20gJ2xpdC9kaXJlY3RpdmVzL3JlcGVhdC5qcyc7XG5pbXBvcnQge0xheW91dENvbmZpZ1ZhbHVlfSBmcm9tICcuL2xheW91dHMvc2hhcmVkL0xheW91dC5qcyc7XG5pbXBvcnQge1xuICB2aXJ0dWFsaXplLFxuICB2aXJ0dWFsaXplclJlZixcbiAgVmlydHVhbGl6ZXJIb3N0RWxlbWVudCxcbiAgZGVmYXVsdFJlbmRlckl0ZW0sXG4gIGRlZmF1bHRLZXlGdW5jdGlvbixcbiAgUmVuZGVySXRlbUZ1bmN0aW9uLFxufSBmcm9tICcuL3ZpcnR1YWxpemUuanMnO1xuXG5leHBvcnQgY2xhc3MgTGl0VmlydHVhbGl6ZXI8VCA9IHVua25vd24+IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gIEBwcm9wZXJ0eSh7YXR0cmlidXRlOiBmYWxzZX0pXG4gIGl0ZW1zOiBUW10gPSBbXTtcblxuICBAcHJvcGVydHkoKVxuICByZW5kZXJJdGVtOiBSZW5kZXJJdGVtRnVuY3Rpb248VD4gPSBkZWZhdWx0UmVuZGVySXRlbTtcblxuICBAcHJvcGVydHkoKVxuICBrZXlGdW5jdGlvbjogS2V5Rm48VD4gPSBkZWZhdWx0S2V5RnVuY3Rpb247XG5cbiAgQHByb3BlcnR5KHthdHRyaWJ1dGU6IGZhbHNlfSlcbiAgbGF5b3V0OiBMYXlvdXRDb25maWdWYWx1ZSA9IHt9O1xuXG4gIEBwcm9wZXJ0eSh7cmVmbGVjdDogdHJ1ZSwgdHlwZTogQm9vbGVhbn0pXG4gIHNjcm9sbGVyID0gZmFsc2U7XG5cbiAgY3JlYXRlUmVuZGVyUm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7aXRlbXMsIHJlbmRlckl0ZW0sIGtleUZ1bmN0aW9uLCBsYXlvdXQsIHNjcm9sbGVyfSA9IHRoaXM7XG4gICAgcmV0dXJuIGh0bWxgJHt2aXJ0dWFsaXplKHtcbiAgICAgIGl0ZW1zLFxuICAgICAgcmVuZGVySXRlbSxcbiAgICAgIGtleUZ1bmN0aW9uLFxuICAgICAgbGF5b3V0LFxuICAgICAgc2Nyb2xsZXIsXG4gICAgfSl9YDtcbiAgfVxuXG4gIGVsZW1lbnQoaW5kZXg6IG51bWJlcikge1xuICAgIHJldHVybiAodGhpcyBhcyBWaXJ0dWFsaXplckhvc3RFbGVtZW50KVt2aXJ0dWFsaXplclJlZl0/LmVsZW1lbnQoaW5kZXgpO1xuICB9XG5cbiAgZ2V0IGxheW91dENvbXBsZXRlKCkge1xuICAgIHJldHVybiAodGhpcyBhcyBWaXJ0dWFsaXplckhvc3RFbGVtZW50KVt2aXJ0dWFsaXplclJlZl0/LmxheW91dENvbXBsZXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgc2Nyb2xsVG9JbmRleCgpIHNoaW0gaXMgaGVyZSB0byBwcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb3RoZXIgMC54IHZlcnNpb25zIG9mXG4gICAqIGxpdC12aXJ0dWFsaXplci4gSXQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiB0aGUgMS4wLjAgcmVsZWFzZS5cbiAgICovXG4gIHNjcm9sbFRvSW5kZXgoXG4gICAgaW5kZXg6IG51bWJlcixcbiAgICBwb3NpdGlvbjogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgfCAnbmVhcmVzdCcgPSAnc3RhcnQnXG4gICkge1xuICAgIHRoaXMuZWxlbWVudChpbmRleCk/LnNjcm9sbEludG9WaWV3KHtibG9jazogcG9zaXRpb259KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/LitVirtualizer.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/ScrollerController.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/ScrollerController.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollerController: () => (/* binding */ ScrollerController),\n/* harmony export */   ScrollerShim: () => (/* binding */ ScrollerShim)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nclass ScrollerShim {\n  constructor(element) {\n    this._element = null;\n    const node = element !== null && element !== void 0 ? element : window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n  get element() {\n    return this._element || document.scrollingElement || document.documentElement;\n  }\n  get scrollTop() {\n    return this.element.scrollTop || window.scrollY;\n  }\n  get scrollLeft() {\n    return this.element.scrollLeft || window.scrollX;\n  }\n  get scrollHeight() {\n    return this.element.scrollHeight;\n  }\n  get scrollWidth() {\n    return this.element.scrollWidth;\n  }\n  get viewportHeight() {\n    return this._element ? this._element.getBoundingClientRect().height : window.innerHeight;\n  }\n  get viewportWidth() {\n    return this._element ? this._element.getBoundingClientRect().width : window.innerWidth;\n  }\n  get maxScrollTop() {\n    return this.scrollHeight - this.viewportHeight;\n  }\n  get maxScrollLeft() {\n    return this.scrollWidth - this.viewportWidth;\n  }\n}\nclass ScrollerController extends ScrollerShim {\n  constructor(client, element) {\n    super(element);\n    this._clients = new Set();\n    this._retarget = null;\n    this._end = null;\n    this.__destination = null;\n    this.correctingScrollError = false;\n    this._checkForArrival = this._checkForArrival.bind(this);\n    this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n    this.scrollTo = this.scrollTo.bind(this);\n    this.scrollBy = this.scrollBy.bind(this);\n    const node = this._node;\n    this._originalScrollTo = node.scrollTo;\n    this._originalScrollBy = node.scrollBy;\n    this._originalScroll = node.scroll;\n    this._attach(client);\n  }\n  get _destination() {\n    return this.__destination;\n  }\n  get scrolling() {\n    return this._destination !== null;\n  }\n  scrollTo(p1, p2) {\n    const options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n      left: p1,\n      top: p2\n    } : p1;\n    this._scrollTo(options);\n  }\n  scrollBy(p1, p2) {\n    const options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n      left: p1,\n      top: p2\n    } : p1;\n    if (options.top !== undefined) {\n      options.top += this.scrollTop;\n    }\n    if (options.left !== undefined) {\n      options.left += this.scrollLeft;\n    }\n    this._scrollTo(options);\n  }\n  _nativeScrollTo(options) {\n    this._originalScrollTo.bind(this._element || window)(options);\n  }\n  _scrollTo(options, retarget = null, end = null) {\n    if (this._end !== null) {\n      this._end();\n    }\n    if (options.behavior === 'smooth') {\n      this._setDestination(options);\n      this._retarget = retarget;\n      this._end = end;\n    } else {\n      this._resetScrollState();\n    }\n    this._nativeScrollTo(options);\n  }\n  _setDestination(options) {\n    let {\n      top,\n      left\n    } = options;\n    top = top === undefined ? undefined : Math.max(0, Math.min(top, this.maxScrollTop));\n    left = left === undefined ? undefined : Math.max(0, Math.min(left, this.maxScrollLeft));\n    if (this._destination !== null && left === this._destination.left && top === this._destination.top) {\n      return false;\n    }\n    this.__destination = {\n      top,\n      left,\n      behavior: 'smooth'\n    };\n    return true;\n  }\n  _resetScrollState() {\n    this.__destination = null;\n    this._retarget = null;\n    this._end = null;\n  }\n  _updateManagedScrollTo(coordinates) {\n    if (this._destination) {\n      if (this._setDestination(coordinates)) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }\n  managedScrollTo(options, retarget, end) {\n    this._scrollTo(options, retarget, end);\n    return this._updateManagedScrollTo;\n  }\n  correctScrollError(coordinates) {\n    this.correctingScrollError = true;\n    requestAnimationFrame(() => requestAnimationFrame(() => this.correctingScrollError = false));\n    // Correct the error\n    this._nativeScrollTo(coordinates);\n    // Then, if we were headed for a specific destination, we continue scrolling:\n    // First, we update our target destination, if applicable...\n    if (this._retarget) {\n      this._setDestination(this._retarget());\n    }\n    // Then we go ahead and resume scrolling\n    if (this._destination) {\n      this._nativeScrollTo(this._destination);\n    }\n  }\n  _checkForArrival() {\n    if (this._destination !== null) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = this;\n      let {\n        top,\n        left\n      } = this._destination;\n      top = Math.min(top || 0, this.maxScrollTop);\n      left = Math.min(left || 0, this.maxScrollLeft);\n      const topDiff = Math.abs(top - scrollTop);\n      const leftDiff = Math.abs(left - scrollLeft);\n      // We check to see if we've arrived at our destination.\n      if (topDiff < 1 && leftDiff < 1) {\n        if (this._end) {\n          this._end();\n        }\n        this._resetScrollState();\n      }\n    }\n  }\n  detach(client) {\n    this._clients.delete(client);\n    /**\n     * If there aren't any more clients, then return the node's default\n     * scrolling methods\n     */\n    if (this._clients.size === 0) {\n      this._node.scrollTo = this._originalScrollTo;\n      this._node.scrollBy = this._originalScrollBy;\n      this._node.scroll = this._originalScroll;\n      this._node.removeEventListener('scroll', this._checkForArrival);\n    }\n    return null;\n  }\n  _attach(client) {\n    this._clients.add(client);\n    /**\n     * The node should only have the methods shimmed when adding the first\n     * client â€“ otherwise it's redundant\n     */\n    if (this._clients.size === 1) {\n      this._node.scrollTo = this.scrollTo;\n      this._node.scrollBy = this.scrollBy;\n      this._node.scroll = this.scrollTo;\n      this._node.addEventListener('scroll', this._checkForArrival);\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL1Njcm9sbGVyQ29udHJvbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7OztBQVlBO0FBSUE7QUFGQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUdBO0FBZUE7QUFDQTtBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBa0JBO0FBYkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBSUE7QUFLQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBRUE7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9TY3JvbGxlckNvbnRyb2xsZXIudHM/ZjY0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuaW1wb3J0IHtTY3JvbGxUb0Nvb3JkaW5hdGVzfSBmcm9tICcuL2xheW91dHMvc2hhcmVkL0xheW91dC5qcyc7XG5cbnR5cGUgcmV0YXJnZXRTY3JvbGxDYWxsYmFjayA9ICgpID0+IFNjcm9sbFRvQ29vcmRpbmF0ZXM7XG50eXBlIGVuZFNjcm9sbENhbGxiYWNrID0gKCkgPT4gdm9pZDtcbnR5cGUgTnVsbGFibGU8VD4gPSBUIHwgbnVsbDtcblxuZXhwb3J0IGNsYXNzIFNjcm9sbGVyU2hpbSB7XG4gIHByb3RlY3RlZCBfbm9kZTogRWxlbWVudCB8IFdpbmRvdztcbiAgcHJvdGVjdGVkIF9lbGVtZW50OiBOdWxsYWJsZTxFbGVtZW50PiA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudD86IEVsZW1lbnQpIHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudCA/PyB3aW5kb3c7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fZWxlbWVudCB8fCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNjcm9sbFRvcCB8fCB3aW5kb3cuc2Nyb2xsWTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2Nyb2xsTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNjcm9sbExlZnQgfHwgd2luZG93LnNjcm9sbFg7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNjcm9sbEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2Nyb2xsV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdmlld3BvcnRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRcbiAgICAgID8gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgIDogd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldCB2aWV3cG9ydFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50XG4gICAgICA/IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgICAgIDogd2luZG93LmlubmVyV2lkdGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG1heFNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxIZWlnaHQgLSB0aGlzLnZpZXdwb3J0SGVpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldCBtYXhTY3JvbGxMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLnNjcm9sbFdpZHRoIC0gdGhpcy52aWV3cG9ydFdpZHRoO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTY3JvbGxlckNvbnRyb2xsZXIgZXh0ZW5kcyBTY3JvbGxlclNoaW0ge1xuICBwcml2YXRlIF9vcmlnaW5hbFNjcm9sbFRvOlxuICAgIHwgdHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvXG4gICAgfCB0eXBlb2Ygd2luZG93LnNjcm9sbFRvO1xuICBwcml2YXRlIF9vcmlnaW5hbFNjcm9sbEJ5OlxuICAgIHwgdHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEJ5XG4gICAgfCB0eXBlb2Ygd2luZG93LnNjcm9sbEJ5O1xuICBwcml2YXRlIF9vcmlnaW5hbFNjcm9sbDpcbiAgICB8IHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxcbiAgICB8IHR5cGVvZiB3aW5kb3cuc2Nyb2xsO1xuICBwcml2YXRlIF9jbGllbnRzID0gbmV3IFNldDx1bmtub3duPigpO1xuICBwcml2YXRlIF9yZXRhcmdldDogTnVsbGFibGU8cmV0YXJnZXRTY3JvbGxDYWxsYmFjaz4gPSBudWxsO1xuICBwcml2YXRlIF9lbmQ6IE51bGxhYmxlPGVuZFNjcm9sbENhbGxiYWNrPiA9IG51bGw7XG4gIHByaXZhdGUgX19kZXN0aW5hdGlvbjogTnVsbGFibGU8U2Nyb2xsVG9PcHRpb25zPiA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoY2xpZW50OiB1bmtub3duLCBlbGVtZW50PzogRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpO1xuXG4gICAgdGhpcy5fY2hlY2tGb3JBcnJpdmFsID0gdGhpcy5fY2hlY2tGb3JBcnJpdmFsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlTWFuYWdlZFNjcm9sbFRvID0gdGhpcy5fdXBkYXRlTWFuYWdlZFNjcm9sbFRvLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zY3JvbGxUbyA9IHRoaXMuc2Nyb2xsVG8uYmluZCh0aGlzKTtcbiAgICB0aGlzLnNjcm9sbEJ5ID0gdGhpcy5zY3JvbGxCeS5iaW5kKHRoaXMpO1xuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGU7XG5cbiAgICB0aGlzLl9vcmlnaW5hbFNjcm9sbFRvID0gbm9kZS5zY3JvbGxUbztcbiAgICB0aGlzLl9vcmlnaW5hbFNjcm9sbEJ5ID0gbm9kZS5zY3JvbGxCeTtcbiAgICB0aGlzLl9vcmlnaW5hbFNjcm9sbCA9IG5vZGUuc2Nyb2xsO1xuICAgIHRoaXMuX2F0dGFjaChjbGllbnQpO1xuICB9XG5cbiAgcHVibGljIGNvcnJlY3RpbmdTY3JvbGxFcnJvciA9IGZhbHNlO1xuXG4gIHByaXZhdGUgZ2V0IF9kZXN0aW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX2Rlc3RpbmF0aW9uO1xuICB9XG5cbiAgcHVibGljIGdldCBzY3JvbGxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc3RpbmF0aW9uICE9PSBudWxsO1xuICB9XG5cbiAgcHVibGljIHNjcm9sbFRvKG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucyk6IHZvaWQ7XG4gIHB1YmxpYyBzY3JvbGxUbyh4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQ7XG4gIHB1YmxpYyBzY3JvbGxUbyhwMTogU2Nyb2xsVG9PcHRpb25zIHwgbnVtYmVyLCBwMj86IG51bWJlcik6IHZvaWQ7XG4gIHB1YmxpYyBzY3JvbGxUbyhwMTogU2Nyb2xsVG9PcHRpb25zIHwgbnVtYmVyLCBwMj86IG51bWJlcikge1xuICAgIGNvbnN0IG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucyA9XG4gICAgICB0eXBlb2YgcDEgPT09ICdudW1iZXInICYmIHR5cGVvZiBwMiA9PT0gJ251bWJlcidcbiAgICAgICAgPyB7bGVmdDogcDEsIHRvcDogcDJ9XG4gICAgICAgIDogKHAxIGFzIFNjcm9sbFRvT3B0aW9ucyk7XG4gICAgdGhpcy5fc2Nyb2xsVG8ob3B0aW9ucyk7XG4gIH1cblxuICBwdWJsaWMgc2Nyb2xsQnkob3B0aW9uczogU2Nyb2xsVG9PcHRpb25zKTogdm9pZDtcbiAgcHVibGljIHNjcm9sbEJ5KHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZDtcbiAgcHVibGljIHNjcm9sbEJ5KHAxOiBTY3JvbGxUb09wdGlvbnMgfCBudW1iZXIsIHAyPzogbnVtYmVyKTogdm9pZDtcbiAgcHVibGljIHNjcm9sbEJ5KHAxOiBTY3JvbGxUb09wdGlvbnMgfCBudW1iZXIsIHAyPzogbnVtYmVyKSB7XG4gICAgY29uc3Qgb3B0aW9uczogU2Nyb2xsVG9PcHRpb25zID1cbiAgICAgIHR5cGVvZiBwMSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHAyID09PSAnbnVtYmVyJ1xuICAgICAgICA/IHtsZWZ0OiBwMSwgdG9wOiBwMn1cbiAgICAgICAgOiAocDEgYXMgU2Nyb2xsVG9PcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50b3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy50b3AgKz0gdGhpcy5zY3JvbGxUb3A7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxlZnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5sZWZ0ICs9IHRoaXMuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgdGhpcy5fc2Nyb2xsVG8ob3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIF9uYXRpdmVTY3JvbGxUbyhvcHRpb25zOiBTY3JvbGxUb09wdGlvbnMpIHtcbiAgICB0aGlzLl9vcmlnaW5hbFNjcm9sbFRvIS5iaW5kKHRoaXMuX2VsZW1lbnQgfHwgd2luZG93KShvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgX3Njcm9sbFRvKFxuICAgIG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucyxcbiAgICByZXRhcmdldDogcmV0YXJnZXRTY3JvbGxDYWxsYmFjayB8IG51bGwgPSBudWxsLFxuICAgIGVuZDogZW5kU2Nyb2xsQ2FsbGJhY2sgfCBudWxsID0gbnVsbFxuICApIHtcbiAgICBpZiAodGhpcy5fZW5kICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9lbmQoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG4gICAgICB0aGlzLl9zZXREZXN0aW5hdGlvbihvcHRpb25zKTtcbiAgICAgIHRoaXMuX3JldGFyZ2V0ID0gcmV0YXJnZXQ7XG4gICAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2V0U2Nyb2xsU3RhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5fbmF0aXZlU2Nyb2xsVG8ob3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIF9zZXREZXN0aW5hdGlvbihvcHRpb25zOiBTY3JvbGxUb09wdGlvbnMpIHtcbiAgICBsZXQge3RvcCwgbGVmdH0gPSBvcHRpb25zO1xuICAgIHRvcCA9XG4gICAgICB0b3AgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKHRvcCwgdGhpcy5tYXhTY3JvbGxUb3ApKTtcbiAgICBsZWZ0ID1cbiAgICAgIGxlZnQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKGxlZnQsIHRoaXMubWF4U2Nyb2xsTGVmdCkpO1xuICAgIGlmIChcbiAgICAgIHRoaXMuX2Rlc3RpbmF0aW9uICE9PSBudWxsICYmXG4gICAgICBsZWZ0ID09PSB0aGlzLl9kZXN0aW5hdGlvbi5sZWZ0ICYmXG4gICAgICB0b3AgPT09IHRoaXMuX2Rlc3RpbmF0aW9uLnRvcFxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9fZGVzdGluYXRpb24gPSB7dG9wLCBsZWZ0LCBiZWhhdmlvcjogJ3Ntb290aCd9O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVzZXRTY3JvbGxTdGF0ZSgpIHtcbiAgICB0aGlzLl9fZGVzdGluYXRpb24gPSBudWxsO1xuICAgIHRoaXMuX3JldGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLl9lbmQgPSBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBfdXBkYXRlTWFuYWdlZFNjcm9sbFRvKGNvb3JkaW5hdGVzOiBTY3JvbGxUb0Nvb3JkaW5hdGVzKSB7XG4gICAgaWYgKHRoaXMuX2Rlc3RpbmF0aW9uKSB7XG4gICAgICBpZiAodGhpcy5fc2V0RGVzdGluYXRpb24oY29vcmRpbmF0ZXMpKSB7XG4gICAgICAgIHRoaXMuX25hdGl2ZVNjcm9sbFRvKHRoaXMuX2Rlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbWFuYWdlZFNjcm9sbFRvKFxuICAgIG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucyxcbiAgICByZXRhcmdldDogcmV0YXJnZXRTY3JvbGxDYWxsYmFjayxcbiAgICBlbmQ6IGVuZFNjcm9sbENhbGxiYWNrXG4gICkge1xuICAgIHRoaXMuX3Njcm9sbFRvKG9wdGlvbnMsIHJldGFyZ2V0LCBlbmQpO1xuICAgIHJldHVybiB0aGlzLl91cGRhdGVNYW5hZ2VkU2Nyb2xsVG87XG4gIH1cblxuICBwdWJsaWMgY29ycmVjdFNjcm9sbEVycm9yKGNvb3JkaW5hdGVzOiBTY3JvbGxUb0Nvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5jb3JyZWN0aW5nU2Nyb2xsRXJyb3IgPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PlxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+ICh0aGlzLmNvcnJlY3RpbmdTY3JvbGxFcnJvciA9IGZhbHNlKSlcbiAgICApO1xuICAgIC8vIENvcnJlY3QgdGhlIGVycm9yXG4gICAgdGhpcy5fbmF0aXZlU2Nyb2xsVG8oY29vcmRpbmF0ZXMpO1xuICAgIC8vIFRoZW4sIGlmIHdlIHdlcmUgaGVhZGVkIGZvciBhIHNwZWNpZmljIGRlc3RpbmF0aW9uLCB3ZSBjb250aW51ZSBzY3JvbGxpbmc6XG4gICAgLy8gRmlyc3QsIHdlIHVwZGF0ZSBvdXIgdGFyZ2V0IGRlc3RpbmF0aW9uLCBpZiBhcHBsaWNhYmxlLi4uXG4gICAgaWYgKHRoaXMuX3JldGFyZ2V0KSB7XG4gICAgICB0aGlzLl9zZXREZXN0aW5hdGlvbih0aGlzLl9yZXRhcmdldCgpKTtcbiAgICB9XG4gICAgLy8gVGhlbiB3ZSBnbyBhaGVhZCBhbmQgcmVzdW1lIHNjcm9sbGluZ1xuICAgIGlmICh0aGlzLl9kZXN0aW5hdGlvbikge1xuICAgICAgdGhpcy5fbmF0aXZlU2Nyb2xsVG8odGhpcy5fZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NoZWNrRm9yQXJyaXZhbCgpIHtcbiAgICBpZiAodGhpcy5fZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtzY3JvbGxUb3AsIHNjcm9sbExlZnR9ID0gdGhpcztcbiAgICAgIGxldCB7dG9wLCBsZWZ0fSA9IHRoaXMuX2Rlc3RpbmF0aW9uO1xuICAgICAgdG9wID0gTWF0aC5taW4odG9wIHx8IDAsIHRoaXMubWF4U2Nyb2xsVG9wKTtcbiAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0IHx8IDAsIHRoaXMubWF4U2Nyb2xsTGVmdCk7XG4gICAgICBjb25zdCB0b3BEaWZmID0gTWF0aC5hYnModG9wIC0gc2Nyb2xsVG9wKTtcbiAgICAgIGNvbnN0IGxlZnREaWZmID0gTWF0aC5hYnMobGVmdCAtIHNjcm9sbExlZnQpO1xuICAgICAgLy8gV2UgY2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGFycml2ZWQgYXQgb3VyIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKHRvcERpZmYgPCAxICYmIGxlZnREaWZmIDwgMSkge1xuICAgICAgICBpZiAodGhpcy5fZW5kKSB7XG4gICAgICAgICAgdGhpcy5fZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzZXRTY3JvbGxTdGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZXRhY2goY2xpZW50OiB1bmtub3duKSB7XG4gICAgdGhpcy5fY2xpZW50cy5kZWxldGUoY2xpZW50KTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBjbGllbnRzLCB0aGVuIHJldHVybiB0aGUgbm9kZSdzIGRlZmF1bHRcbiAgICAgKiBzY3JvbGxpbmcgbWV0aG9kc1xuICAgICAqL1xuICAgIGlmICh0aGlzLl9jbGllbnRzLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuX25vZGUuc2Nyb2xsVG8gPSB0aGlzLl9vcmlnaW5hbFNjcm9sbFRvO1xuICAgICAgdGhpcy5fbm9kZS5zY3JvbGxCeSA9IHRoaXMuX29yaWdpbmFsU2Nyb2xsQnk7XG4gICAgICB0aGlzLl9ub2RlLnNjcm9sbCA9IHRoaXMuX29yaWdpbmFsU2Nyb2xsO1xuICAgICAgdGhpcy5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9jaGVja0ZvckFycml2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgX2F0dGFjaChjbGllbnQ6IHVua25vd24pIHtcbiAgICB0aGlzLl9jbGllbnRzLmFkZChjbGllbnQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5vZGUgc2hvdWxkIG9ubHkgaGF2ZSB0aGUgbWV0aG9kcyBzaGltbWVkIHdoZW4gYWRkaW5nIHRoZSBmaXJzdFxuICAgICAqIGNsaWVudCDigJMgb3RoZXJ3aXNlIGl0J3MgcmVkdW5kYW50XG4gICAgICovXG4gICAgaWYgKHRoaXMuX2NsaWVudHMuc2l6ZSA9PT0gMSkge1xuICAgICAgdGhpcy5fbm9kZS5zY3JvbGxUbyA9IHRoaXMuc2Nyb2xsVG87XG4gICAgICB0aGlzLl9ub2RlLnNjcm9sbEJ5ID0gdGhpcy5zY3JvbGxCeTtcbiAgICAgIHRoaXMuX25vZGUuc2Nyb2xsID0gdGhpcy5zY3JvbGxUbztcbiAgICAgIHRoaXMuX25vZGUuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fY2hlY2tGb3JBcnJpdmFsKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/ScrollerController.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/Virtualizer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/Virtualizer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   provideResizeObserver: () => (/* binding */ provideResizeObserver),\n/* harmony export */   virtualizerRef: () => (/* binding */ virtualizerRef)\n/* harmony export */ });\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events.js */ \"./node_modules/@lit-labs/virtualizer/events.js\");\n/* harmony import */ var _ScrollerController_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ScrollerController.js */ \"./node_modules/@lit-labs/virtualizer/ScrollerController.js\");\nvar _window;\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n// Virtualizer depends on `ResizeObserver`, which is supported in\n// all modern browsers. For developers whose browser support\n// matrix includes older browsers, we include a compatible\n// polyfill in the package; this bit of module state facilitates\n// a simple mechanism (see ./polyfillLoaders/ResizeObserver.js.)\n// for loading the polyfill.\nlet _ResizeObserver = (_window = window) === null || _window === void 0 ? void 0 : _window.ResizeObserver;\n/**\n * Call this function to provide a `ResizeObserver` polyfill for Virtualizer to use.\n * @param Ctor Constructor for a `ResizeObserver` polyfill (recommend using the one provided with the Virtualizer package)\n */\nfunction provideResizeObserver(Ctor) {\n  _ResizeObserver = Ctor;\n}\nconst virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\nlet DefaultLayoutConstructor;\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nclass Virtualizer {\n  constructor(config) {\n    this._benchmarkStart = null;\n    this._layout = null;\n    this._clippingAncestors = [];\n    /**\n     * Layout provides these values, we set them on _render().\n     * TODO @straversi: Can we find an XOR type, usable for the key here?\n     */\n    this._scrollSize = null;\n    /**\n     * Difference between scroll target's current and required scroll offsets.\n     * Provided by layout.\n     */\n    this._scrollError = null;\n    /**\n     * A list of the positions (top, left) of the children in the current range.\n     */\n    this._childrenPos = null;\n    // TODO: (graynorton): type\n    this._childMeasurements = null;\n    this._toBeMeasured = new Map();\n    this._rangeChanged = true;\n    this._itemsChanged = true;\n    this._visibilityChanged = true;\n    this._scrollerController = null;\n    this._isScroller = false;\n    this._sizer = null;\n    /**\n     * Resize observer attached to hostElement.\n     */\n    this._hostElementRO = null;\n    /**\n     * Resize observer attached to children.\n     */\n    this._childrenRO = null;\n    this._mutationObserver = null;\n    this._scrollEventListeners = [];\n    this._scrollEventListenerOptions = {\n      passive: true\n    };\n    // TODO (graynorton): Rethink, per longer comment below\n    this._loadListener = this._childLoaded.bind(this);\n    /**\n     * Index of element to scroll into view, plus scroll\n     * behavior options, as imperatively specified via\n     * `element(index).scrollIntoView()`\n     */\n    this._scrollIntoViewTarget = null;\n    this._updateScrollIntoViewCoordinates = null;\n    /**\n     * Items to render. Set by items.\n     */\n    this._items = [];\n    /**\n     * Index of the first child in the range, not necessarily the first visible child.\n     * TODO @straversi: Consider renaming these.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child in the range.\n     */\n    this._last = -1;\n    /**\n     * Index of the first item intersecting the viewport.\n     */\n    this._firstVisible = -1;\n    /**\n     * Index of the last item intersecting the viewport.\n     */\n    this._lastVisible = -1;\n    this._scheduled = new WeakSet();\n    /**\n     * Invoked at the end of each render cycle: children in the range are\n     * measured, and their dimensions passed to this callback. Use it to layout\n     * children as needed.\n     */\n    this._measureCallback = null;\n    this._measureChildOverride = null;\n    /**\n     * State for `layoutComplete` promise\n     */\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n    /**\n     * Layout initialization is async because we dynamically load\n     * the default layout if none is specified. This state is to track\n     * whether init is complete.\n     */\n    this._layoutInitialized = null;\n    if (!config) {\n      throw new Error('Virtualizer constructor requires a configuration object');\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error('Virtualizer configuration requires the \"hostElement\" property');\n    }\n  }\n  set items(items) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n  _init(config) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    const layoutConfig = config.layout || {};\n    // Save the promise returned by `_initLayout` as a state\n    // variable we can check before updating layout config\n    this._layoutInitialized = this._initLayout(layoutConfig);\n  }\n  _initObservers() {\n    this._mutationObserver = new MutationObserver(this._finishDOMUpdate.bind(this));\n    this._hostElementRO = new _ResizeObserver(() => this._hostElementSizeChanged());\n    this._childrenRO = new _ResizeObserver(this._childrenSizeChanged.bind(this));\n  }\n  _initHostElement(config) {\n    const hostElement = this._hostElement = config.hostElement;\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n  connected() {\n    this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(this._hostElement, includeSelf);\n    this._scrollerController = new _ScrollerController_js__WEBPACK_IMPORTED_MODULE_1__.ScrollerController(this, this._clippingAncestors[0]);\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n  }\n  _observeAndListen() {\n    this._mutationObserver.observe(this._hostElement, {\n      childList: true\n    });\n    this._hostElementRO.observe(this._hostElement);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', this, this._scrollEventListenerOptions);\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO.observe(ancestor);\n    });\n    this._hostElementRO.observe(this._scrollerController.element);\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._scrollEventListeners.forEach(target => target.addEventListener('scroll', this, this._scrollEventListenerOptions));\n  }\n  disconnected() {\n    var _this$_scrollerContro, _this$_mutationObserv, _this$_hostElementRO, _this$_childrenRO;\n    this._scrollEventListeners.forEach(target => target.removeEventListener('scroll', this, this._scrollEventListenerOptions));\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    (_this$_scrollerContro = this._scrollerController) === null || _this$_scrollerContro === void 0 || _this$_scrollerContro.detach(this);\n    this._scrollerController = null;\n    (_this$_mutationObserv = this._mutationObserver) === null || _this$_mutationObserv === void 0 || _this$_mutationObserv.disconnect();\n    this._mutationObserver = null;\n    (_this$_hostElementRO = this._hostElementRO) === null || _this$_hostElementRO === void 0 || _this$_hostElementRO.disconnect();\n    this._hostElementRO = null;\n    (_this$_childrenRO = this._childrenRO) === null || _this$_childrenRO === void 0 || _this$_childrenRO.disconnect();\n    this._childrenRO = null;\n    this._rejectLayoutCompletePromise('disconnected');\n  }\n  _applyVirtualizerStyles() {\n    const hostElement = this._hostElement;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style;\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n  _getSizer() {\n    const hostElement = this._hostElement;\n    if (!this._sizer) {\n      // Use a preexisting sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(`[${SIZER_ATTRIBUTE}]`);\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px'\n      });\n      sizer.textContent = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n  async updateLayoutConfig(layoutConfig) {\n    // If layout initialization hasn't finished yet, we wait\n    // for it to finish so we can check whether the new config\n    // is compatible with the existing layout before proceeding.\n    await this._layoutInitialized;\n    const Ctor = layoutConfig.type ||\n    // The new config is compatible with the current layout,\n    // so we update the config and return true to indicate\n    // a successful update\n    DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {\n        ...layoutConfig\n      };\n      delete config.type;\n      this._layout.config = config;\n      // The new config requires a different layout altogether, but\n      // to limit implementation complexity we don't support dynamically\n      // changing the layout of an existing virtualizer instance.\n      // Returning false here lets the caller know that they should\n      // instead make a new virtualizer instance with the desired layout.\n      return true;\n    }\n    return false;\n  }\n  async _initLayout(layoutConfig) {\n    let config;\n    let Ctor;\n    if (typeof layoutConfig.type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = layoutConfig.type;\n      // ...while the rest of the specifier is our layout config\n      const copy = {\n        ...layoutConfig\n      };\n      delete copy.type;\n      config = copy;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig;\n    }\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_lit-labs_virtualizer_layouts_shared_BaseLayout_js\"), __webpack_require__.e(\"vendors-node_modules_lit-labs_virtualizer_layouts_flow_js\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./layouts/flow.js */ \"./node_modules/@lit-labs/virtualizer/layouts/flow.js\"))).FlowLayout;\n    }\n    this._layout = new Ctor(message => this._handleLayoutMessage(message), config);\n    if (this._layout.measureChildren && typeof this._layout.updateItemSizes === 'function') {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement.addEventListener('load', this._loadListener, true);\n    }\n    this._schedule(this._updateLayout);\n  }\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName('uv-virtualizing', 'measure');\n      const virtualizationTime = entries.filter(e => e.startTime >= this._benchmarkStart && e.startTime < now).reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {\n        timeElapsed,\n        virtualizationTime\n      };\n    }\n    return null;\n  }\n  _measureChildren() {\n    const mm = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element) {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {\n      width,\n      height\n    } = element.getBoundingClientRect();\n    return Object.assign({\n      width,\n      height\n    }, getMargins(element));\n  }\n  async _schedule(method) {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n  async _updateDOM(state) {\n    this._scrollSize = state.scrollSize;\n    this._adjustRange(state.range);\n    this._childrenPos = state.childPositions;\n    this._scrollError = state.scrollError || null;\n    const {\n      _rangeChanged,\n      _itemsChanged\n    } = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    }\n    this._finishDOMUpdate();\n  }\n  _finishDOMUpdate() {\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._checkScrollIntoViewTarget(this._childrenPos);\n    this._positionChildren(this._childrenPos);\n    this._sizeHostElement(this._scrollSize);\n    this._correctScrollError();\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      window.performance.mark('uv-end');\n    }\n  }\n  _updateLayout() {\n    // Only update the layout and trigger a re-render if we have:\n    //   a) A layout\n    //   b) A scrollerController, which means we're connected\n    if (this._layout && this._scrollerController) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n  _handleScrollEvent() {\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController.correctingScrollError === false) {\n      var _this$_layout;\n      // This is a user-initiated scroll, so we unpin the layout\n      (_this$_layout = this._layout) === null || _this$_layout === void 0 || _this$_layout.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n  handleEvent(event) {\n    switch (event.type) {\n      case 'scroll':\n        if (event.currentTarget === window || this._clippingAncestors.includes(event.currentTarget)) {\n          this._handleScrollEvent();\n        }\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n  _handleLayoutMessage(message) {\n    if (message.type === 'stateChanged') {\n      this._updateDOM(message);\n    } else if (message.type === 'visibilityChanged') {\n      this._firstVisible = message.firstVisible;\n      this._lastVisible = message.lastVisible;\n      this._notifyVisibility();\n    } else if (message.type === 'unpinned') {\n      this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_0__.UnpinnedEvent());\n    }\n  }\n  get _children() {\n    const arr = [];\n    let next = this._hostElement.firstElementChild;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling;\n    }\n    return arr;\n  }\n  _updateView() {\n    var _this$_scrollerContro2;\n    const hostElement = this._hostElement;\n    const scrollingElement = (_this$_scrollerContro2 = this._scrollerController) === null || _this$_scrollerContro2 === void 0 ? void 0 : _this$_scrollerContro2.element;\n    const layout = this._layout;\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n      const hostElementBounds = hostElement.getBoundingClientRect();\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n      const ancestorBounds = this._clippingAncestors.map(ancestor => ancestor.getBoundingClientRect());\n      ancestorBounds.unshift(hostElementBounds);\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top\n      };\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight\n      };\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n      const height = bottom - top;\n      const width = right - left;\n      layout.viewportSize = {\n        width,\n        height\n      };\n      layout.viewportScroll = {\n        top: scrollTop,\n        left: scrollLeft\n      };\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  _sizeHostElement(size) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement.style;\n      style.minWidth = h ? `${h}px` : '100%';\n      style.minHeight = v ? `${v}px` : '100%';\n    }\n  }\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  _positionChildren(pos) {\n    if (pos) {\n      pos.forEach(({\n        top,\n        left,\n        width,\n        height,\n        xOffset,\n        yOffset\n      }, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          child.style.left = xOffset === undefined ? null : xOffset + 'px';\n          child.style.top = yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n  async _adjustRange(range) {\n    const {\n      _first,\n      _last,\n      _firstVisible,\n      _lastVisible\n    } = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged = this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged = this._visibilityChanged || this._firstVisible !== _firstVisible || this._lastVisible !== _lastVisible;\n  }\n  _correctScrollError() {\n    if (this._scrollError) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = this._scrollerController;\n      const {\n        top,\n        left\n      } = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left\n      });\n    }\n  }\n  element(index) {\n    var _this$_items;\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return ((_this$_items = this._items) === null || _this$_items === void 0 ? void 0 : _this$_items[index]) === undefined ? undefined : {\n      scrollIntoView: (options = {}) => this._scrollElementIntoView({\n        ...options,\n        index\n      })\n    };\n  }\n  _scrollElementIntoView(options) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout.getScrollIntoViewCoordinates(options);\n        const {\n          behavior\n        } = options;\n        this._updateScrollIntoViewCoordinates = this._scrollerController.managedScrollTo(Object.assign(coordinates, {\n          behavior\n        }), () => this._layout.getScrollIntoViewCoordinates(options), () => this._scrollIntoViewTarget = null);\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout.pin = options;\n      }\n    }\n  }\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  _checkScrollIntoViewTarget(pos) {\n    const {\n      index\n    } = this._scrollIntoViewTarget || {};\n    if (index && pos !== null && pos !== void 0 && pos.has(index)) {\n      this._updateScrollIntoViewCoordinates(this._layout.getScrollIntoViewCoordinates(this._scrollIntoViewTarget));\n    }\n  }\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  _notifyRange() {\n    this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_0__.RangeChangedEvent({\n      first: this._first,\n      last: this._last\n    }));\n  }\n  _notifyVisibility() {\n    this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_0__.VisibilityChangedEvent({\n      first: this._firstVisible,\n      last: this._lastVisible\n    }));\n  }\n  get layoutComplete() {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n  _rejectLayoutCompletePromise(reason) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n  _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() => requestAnimationFrame(() => this._resolveLayoutCompletePromise()));\n    }\n  }\n  _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n  _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n  _childLoaded() {}\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  _childrenSizeChanged(changes) {\n    var _this$_layout2;\n    // Only measure if the layout requires it\n    if ((_this$_layout2 = this._layout) !== null && _this$_layout2 !== void 0 && _this$_layout2.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(change.target, change.contentRect);\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\nfunction getMargins(el) {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft)\n  };\n}\nfunction getMarginValue(value) {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return parentNode.host || null;\n  }\n  return null;\n}\n///\nfunction getElementAncestors(el, includeSelf = false) {\n  const ancestors = [];\n  let parent = includeSelf ? el : getParentElement(el);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent);\n  }\n  return ancestors;\n}\nfunction getClippingAncestors(el, includeSelf = false) {\n  let foundFixed = false;\n  return getElementAncestors(el, includeSelf).filter(a => {\n    if (foundFixed) {\n      return false;\n    }\n    const style = getComputedStyle(a);\n    foundFixed = style.position === 'fixed';\n    return style.overflow !== 'visible';\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL1ZpcnR1YWxpemVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7OztBQXVCQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUE0Q0E7QUFFQTs7Ozs7Ozs7QUFRQTtBQW1JQTtBQWxJQTtBQUVBO0FBRUE7QUFFQTs7OztBQUlBO0FBRUE7Ozs7QUFJQTtBQUVBOzs7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQU9BO0FBRUE7QUFFQTtBQUVBOzs7QUFHQTtBQUVBOzs7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7Ozs7O0FBS0E7QUFFQTtBQUlBOzs7QUFHQTtBQUVBOzs7O0FBSUE7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTtBQUVBOzs7OztBQUtBO0FBR0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFJQTtBQUtBO0FBSUE7QUFDQTs7QUFFQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBOztBQUdBOztBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBSUE7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVmlydHVhbGl6ZXIudHM/MmY3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuaW1wb3J0IHtcbiAgSXRlbUJveCxcbiAgTWFyZ2lucyxcbiAgTGF5b3V0Q29uZmlnVmFsdWUsXG4gIENoaWxkUG9zaXRpb25zLFxuICBDaGlsZE1lYXN1cmVtZW50cyxcbiAgTGF5b3V0LFxuICBMYXlvdXRDb25zdHJ1Y3RvcixcbiAgTGF5b3V0U3BlY2lmaWVyLFxuICBTdGF0ZUNoYW5nZWRNZXNzYWdlLFxuICBTaXplLFxuICBJbnRlcm5hbFJhbmdlLFxuICBNZWFzdXJlQ2hpbGRGdW5jdGlvbixcbiAgU2Nyb2xsVG9Db29yZGluYXRlcyxcbiAgQmFzZUxheW91dENvbmZpZyxcbiAgTGF5b3V0SG9zdE1lc3NhZ2UsXG59IGZyb20gJy4vbGF5b3V0cy9zaGFyZWQvTGF5b3V0LmpzJztcbmltcG9ydCB7XG4gIFJhbmdlQ2hhbmdlZEV2ZW50LFxuICBWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50LFxuICBVbnBpbm5lZEV2ZW50LFxufSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQge1Njcm9sbGVyQ29udHJvbGxlcn0gZnJvbSAnLi9TY3JvbGxlckNvbnRyb2xsZXIuanMnO1xuXG4vLyBWaXJ0dWFsaXplciBkZXBlbmRzIG9uIGBSZXNpemVPYnNlcnZlcmAsIHdoaWNoIGlzIHN1cHBvcnRlZCBpblxuLy8gYWxsIG1vZGVybiBicm93c2Vycy4gRm9yIGRldmVsb3BlcnMgd2hvc2UgYnJvd3NlciBzdXBwb3J0XG4vLyBtYXRyaXggaW5jbHVkZXMgb2xkZXIgYnJvd3NlcnMsIHdlIGluY2x1ZGUgYSBjb21wYXRpYmxlXG4vLyBwb2x5ZmlsbCBpbiB0aGUgcGFja2FnZTsgdGhpcyBiaXQgb2YgbW9kdWxlIHN0YXRlIGZhY2lsaXRhdGVzXG4vLyBhIHNpbXBsZSBtZWNoYW5pc20gKHNlZSAuL3BvbHlmaWxsTG9hZGVycy9SZXNpemVPYnNlcnZlci5qcy4pXG4vLyBmb3IgbG9hZGluZyB0aGUgcG9seWZpbGwuXG5sZXQgX1Jlc2l6ZU9ic2VydmVyOiB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgfCB1bmRlZmluZWQgPSB3aW5kb3c/LlJlc2l6ZU9ic2VydmVyO1xuXG4vKipcbiAqIENhbGwgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGEgYFJlc2l6ZU9ic2VydmVyYCBwb2x5ZmlsbCBmb3IgVmlydHVhbGl6ZXIgdG8gdXNlLlxuICogQHBhcmFtIEN0b3IgQ29uc3RydWN0b3IgZm9yIGEgYFJlc2l6ZU9ic2VydmVyYCBwb2x5ZmlsbCAocmVjb21tZW5kIHVzaW5nIHRoZSBvbmUgcHJvdmlkZWQgd2l0aCB0aGUgVmlydHVhbGl6ZXIgcGFja2FnZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3ZpZGVSZXNpemVPYnNlcnZlcihDdG9yOiB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIpIHtcbiAgX1Jlc2l6ZU9ic2VydmVyID0gQ3Rvcjtcbn1cblxuZXhwb3J0IGNvbnN0IHZpcnR1YWxpemVyUmVmID0gU3ltYm9sKCd2aXJ0dWFsaXplclJlZicpO1xuY29uc3QgU0laRVJfQVRUUklCVVRFID0gJ3ZpcnR1YWxpemVyLXNpemVyJztcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgSFRNTEVsZW1lbnRFdmVudE1hcCB7XG4gICAgcmFuZ2VDaGFuZ2VkOiBSYW5nZUNoYW5nZWRFdmVudDtcbiAgICB2aXNpYmlsaXR5Q2hhbmdlZDogVmlzaWJpbGl0eUNoYW5nZWRFdmVudDtcbiAgICB1bnBpbm5lZDogVW5waW5uZWRFdmVudDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpcnR1YWxpemVySG9zdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIFt2aXJ0dWFsaXplclJlZl0/OiBWaXJ0dWFsaXplcjtcbn1cblxuLyoqXG4gKiBBIHZlcnkgbGltaXRlZCBwcm94eSBvYmplY3QgZm9yIGEgdmlydHVhbGl6ZXIgY2hpbGQsXG4gKiByZXR1cm5lZCBieSBWaXJ0dWFsaXplci5lbGVtZW50KGlkeDogbnVtYmVyKS4gSW50cm9kdWNlZFxuICogdG8gZW5hYmxlIHNjcm9sbGluZyBhIHZpcnR1YWwgZWxlbWVudCBpbnRvIHZpZXcgdXNpbmdcbiAqIGEgY2FsbCB0aGF0IGxvb2tzIGFuZCBiZWhhdmVzIGVzc2VudGlhbGx5IHRoZSBzYW1lIGFzIGZvclxuICogYSByZWFsIEVsZW1lbnQuIE1heSBiZSB1c2VmdWwgZm9yIG90aGVyIHRoaW5ncyBsYXRlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWaXJ0dWFsaXplckNoaWxkRWxlbWVudFByb3h5IHtcbiAgc2Nyb2xsSW50b1ZpZXc6IChvcHRpb25zPzogU2Nyb2xsSW50b1ZpZXdPcHRpb25zKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3Igc2Nyb2xsaW5nIGEgKHBvc3NpYmx5IHZpcnR1YWwpIGVsZW1lbnRcbiAqIGludG8gdmlldywgZ2l2ZW4gaXRzIGluZGV4XG4gKi9cbmludGVyZmFjZSBTY3JvbGxFbGVtZW50SW50b1ZpZXdPcHRpb25zIGV4dGVuZHMgU2Nyb2xsSW50b1ZpZXdPcHRpb25zIHtcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaXJ0dWFsaXplckNvbmZpZyB7XG4gIGxheW91dD86IExheW91dENvbmZpZ1ZhbHVlO1xuXG4gIC8qKlxuICAgKiBUaGUgcGFyZW50IG9mIGFsbCBjaGlsZCBub2RlcyB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIGhvc3RFbGVtZW50OiBWaXJ0dWFsaXplckhvc3RFbGVtZW50O1xuXG4gIHNjcm9sbGVyPzogYm9vbGVhbjtcbn1cblxubGV0IERlZmF1bHRMYXlvdXRDb25zdHJ1Y3RvcjogTGF5b3V0Q29uc3RydWN0b3I7XG5cbi8qKlxuICogUHJvdmlkZXMgdmlydHVhbCBzY3JvbGxpbmcgYm9pbGVycGxhdGUuXG4gKlxuICogRXh0ZW5zaW9ucyBvZiB0aGlzIGNsYXNzIG11c3Qgc2V0IGhvc3RFbGVtZW50IGFuZCBsYXlvdXQuXG4gKlxuICogRXh0ZW5zaW9ucyBvZiB0aGlzIGNsYXNzIG11c3QgYWxzbyBvdmVycmlkZSBWaXJ0dWFsUmVwZWF0ZXIncyBET01cbiAqIG1hbmlwdWxhdGlvbiBtZXRob2RzLlxuICovXG5leHBvcnQgY2xhc3MgVmlydHVhbGl6ZXIge1xuICBwcml2YXRlIF9iZW5jaG1hcmtTdGFydDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfbGF5b3V0OiBMYXlvdXQgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIF9jbGlwcGluZ0FuY2VzdG9yczogSFRNTEVsZW1lbnRbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBMYXlvdXQgcHJvdmlkZXMgdGhlc2UgdmFsdWVzLCB3ZSBzZXQgdGhlbSBvbiBfcmVuZGVyKCkuXG4gICAqIFRPRE8gQHN0cmF2ZXJzaTogQ2FuIHdlIGZpbmQgYW4gWE9SIHR5cGUsIHVzYWJsZSBmb3IgdGhlIGtleSBoZXJlP1xuICAgKi9cbiAgcHJpdmF0ZSBfc2Nyb2xsU2l6ZTogU2l6ZSB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBEaWZmZXJlbmNlIGJldHdlZW4gc2Nyb2xsIHRhcmdldCdzIGN1cnJlbnQgYW5kIHJlcXVpcmVkIHNjcm9sbCBvZmZzZXRzLlxuICAgKiBQcm92aWRlZCBieSBsYXlvdXQuXG4gICAqL1xuICBwcml2YXRlIF9zY3JvbGxFcnJvcjoge2xlZnQ6IG51bWJlcjsgdG9wOiBudW1iZXJ9IHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiB0aGUgcG9zaXRpb25zICh0b3AsIGxlZnQpIG9mIHRoZSBjaGlsZHJlbiBpbiB0aGUgY3VycmVudCByYW5nZS5cbiAgICovXG4gIHByaXZhdGUgX2NoaWxkcmVuUG9zOiBDaGlsZFBvc2l0aW9ucyB8IG51bGwgPSBudWxsO1xuXG4gIC8vIFRPRE86IChncmF5bm9ydG9uKTogdHlwZVxuICBwcml2YXRlIF9jaGlsZE1lYXN1cmVtZW50czogQ2hpbGRNZWFzdXJlbWVudHMgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIF90b0JlTWVhc3VyZWQgPSBuZXcgTWFwPEhUTUxFbGVtZW50LCB1bmtub3duPigpO1xuXG4gIHByaXZhdGUgX3JhbmdlQ2hhbmdlZCA9IHRydWU7XG5cbiAgcHJpdmF0ZSBfaXRlbXNDaGFuZ2VkID0gdHJ1ZTtcblxuICBwcml2YXRlIF92aXNpYmlsaXR5Q2hhbmdlZCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFRoZSBIVE1MRWxlbWVudCB0aGF0IGhvc3RzIHRoZSB2aXJ0dWFsaXplci4gU2V0IGJ5IGhvc3RFbGVtZW50LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9ob3N0RWxlbWVudD86IFZpcnR1YWxpemVySG9zdEVsZW1lbnQ7XG5cbiAgcHJpdmF0ZSBfc2Nyb2xsZXJDb250cm9sbGVyOiBTY3JvbGxlckNvbnRyb2xsZXIgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIF9pc1Njcm9sbGVyID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfc2l6ZXI6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBvYnNlcnZlciBhdHRhY2hlZCB0byBob3N0RWxlbWVudC5cbiAgICovXG4gIHByaXZhdGUgX2hvc3RFbGVtZW50Uk86IFJlc2l6ZU9ic2VydmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBvYnNlcnZlciBhdHRhY2hlZCB0byBjaGlsZHJlbi5cbiAgICovXG4gIHByaXZhdGUgX2NoaWxkcmVuUk86IFJlc2l6ZU9ic2VydmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfbXV0YXRpb25PYnNlcnZlcjogTXV0YXRpb25PYnNlcnZlciB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX3Njcm9sbEV2ZW50TGlzdGVuZXJzOiAoRWxlbWVudCB8IFdpbmRvdylbXSA9IFtdO1xuICBwcml2YXRlIF9zY3JvbGxFdmVudExpc3RlbmVyT3B0aW9uczogQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSB7XG4gICAgcGFzc2l2ZTogdHJ1ZSxcbiAgfTtcblxuICAvLyBUT0RPIChncmF5bm9ydG9uKTogUmV0aGluaywgcGVyIGxvbmdlciBjb21tZW50IGJlbG93XG5cbiAgcHJpdmF0ZSBfbG9hZExpc3RlbmVyID0gdGhpcy5fY2hpbGRMb2FkZWQuYmluZCh0aGlzKTtcblxuICAvKipcbiAgICogSW5kZXggb2YgZWxlbWVudCB0byBzY3JvbGwgaW50byB2aWV3LCBwbHVzIHNjcm9sbFxuICAgKiBiZWhhdmlvciBvcHRpb25zLCBhcyBpbXBlcmF0aXZlbHkgc3BlY2lmaWVkIHZpYVxuICAgKiBgZWxlbWVudChpbmRleCkuc2Nyb2xsSW50b1ZpZXcoKWBcbiAgICovXG4gIHByaXZhdGUgX3Njcm9sbEludG9WaWV3VGFyZ2V0OiBTY3JvbGxFbGVtZW50SW50b1ZpZXdPcHRpb25zIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfdXBkYXRlU2Nyb2xsSW50b1ZpZXdDb29yZGluYXRlczpcbiAgICB8ICgoY29vcmRpbmF0ZXM6IFNjcm9sbFRvQ29vcmRpbmF0ZXMpID0+IHZvaWQpXG4gICAgfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogSXRlbXMgdG8gcmVuZGVyLiBTZXQgYnkgaXRlbXMuXG4gICAqL1xuICBwcml2YXRlIF9pdGVtczogQXJyYXk8dW5rbm93bj4gPSBbXTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGZpcnN0IGNoaWxkIGluIHRoZSByYW5nZSwgbm90IG5lY2Vzc2FyaWx5IHRoZSBmaXJzdCB2aXNpYmxlIGNoaWxkLlxuICAgKiBUT0RPIEBzdHJhdmVyc2k6IENvbnNpZGVyIHJlbmFtaW5nIHRoZXNlLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9maXJzdCA9IC0xO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgbGFzdCBjaGlsZCBpbiB0aGUgcmFuZ2UuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2xhc3QgPSAtMTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gaW50ZXJzZWN0aW5nIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIHByaXZhdGUgX2ZpcnN0VmlzaWJsZSA9IC0xO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgbGFzdCBpdGVtIGludGVyc2VjdGluZyB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcml2YXRlIF9sYXN0VmlzaWJsZSA9IC0xO1xuXG4gIHByb3RlY3RlZCBfc2NoZWR1bGVkID0gbmV3IFdlYWtTZXQ8RnVuY3Rpb24+KCk7XG5cbiAgLyoqXG4gICAqIEludm9rZWQgYXQgdGhlIGVuZCBvZiBlYWNoIHJlbmRlciBjeWNsZTogY2hpbGRyZW4gaW4gdGhlIHJhbmdlIGFyZVxuICAgKiBtZWFzdXJlZCwgYW5kIHRoZWlyIGRpbWVuc2lvbnMgcGFzc2VkIHRvIHRoaXMgY2FsbGJhY2suIFVzZSBpdCB0byBsYXlvdXRcbiAgICogY2hpbGRyZW4gYXMgbmVlZGVkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9tZWFzdXJlQ2FsbGJhY2s6ICgoc2l6ZXM6IENoaWxkTWVhc3VyZW1lbnRzKSA9PiB2b2lkKSB8IG51bGwgPVxuICAgIG51bGw7XG5cbiAgcHJvdGVjdGVkIF9tZWFzdXJlQ2hpbGRPdmVycmlkZTogTWVhc3VyZUNoaWxkRnVuY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogU3RhdGUgZm9yIGBsYXlvdXRDb21wbGV0ZWAgcHJvbWlzZVxuICAgKi9cbiAgcHJpdmF0ZSBfbGF5b3V0Q29tcGxldGVQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2xheW91dENvbXBsZXRlUmVzb2x2ZXI6IEZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2xheW91dENvbXBsZXRlUmVqZWN0ZXI6IEZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX3BlbmRpbmdMYXlvdXRDb21wbGV0ZTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIExheW91dCBpbml0aWFsaXphdGlvbiBpcyBhc3luYyBiZWNhdXNlIHdlIGR5bmFtaWNhbGx5IGxvYWRcbiAgICogdGhlIGRlZmF1bHQgbGF5b3V0IGlmIG5vbmUgaXMgc3BlY2lmaWVkLiBUaGlzIHN0YXRlIGlzIHRvIHRyYWNrXG4gICAqIHdoZXRoZXIgaW5pdCBpcyBjb21wbGV0ZS5cbiAgICovXG4gIHByaXZhdGUgX2xheW91dEluaXRpYWxpemVkOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBWaXJ0dWFsaXplckNvbmZpZykge1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdWaXJ0dWFsaXplciBjb25zdHJ1Y3RvciByZXF1aXJlcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0J1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5ob3N0RWxlbWVudCkge1xuICAgICAgdGhpcy5faW5pdChjb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdWaXJ0dWFsaXplciBjb25maWd1cmF0aW9uIHJlcXVpcmVzIHRoZSBcImhvc3RFbGVtZW50XCIgcHJvcGVydHknXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHNldCBpdGVtcyhpdGVtczogQXJyYXk8dW5rbm93bj4gfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykgJiYgaXRlbXMgIT09IHRoaXMuX2l0ZW1zKSB7XG4gICAgICB0aGlzLl9pdGVtc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZUxheW91dCk7XG4gICAgfVxuICB9XG5cbiAgX2luaXQoY29uZmlnOiBWaXJ0dWFsaXplckNvbmZpZykge1xuICAgIHRoaXMuX2lzU2Nyb2xsZXIgPSAhIWNvbmZpZy5zY3JvbGxlcjtcbiAgICB0aGlzLl9pbml0SG9zdEVsZW1lbnQoY29uZmlnKTtcbiAgICAvLyBJZiBubyBsYXlvdXQgaXMgc3BlY2lmaWVkLCB3ZSBtYWtlIGFuIGVtcHR5XG4gICAgLy8gbGF5b3V0IGNvbmZpZywgd2hpY2ggd2lsbCByZXN1bHQgaW4gdGhlIGRlZmF1bHRcbiAgICAvLyBsYXlvdXQgd2l0aCBkZWZhdWx0IHBhcmFtZXRlcnNcbiAgICBjb25zdCBsYXlvdXRDb25maWcgPSBjb25maWcubGF5b3V0IHx8ICh7fSBhcyBCYXNlTGF5b3V0Q29uZmlnKTtcbiAgICAvLyBTYXZlIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IGBfaW5pdExheW91dGAgYXMgYSBzdGF0ZVxuICAgIC8vIHZhcmlhYmxlIHdlIGNhbiBjaGVjayBiZWZvcmUgdXBkYXRpbmcgbGF5b3V0IGNvbmZpZ1xuICAgIHRoaXMuX2xheW91dEluaXRpYWxpemVkID0gdGhpcy5faW5pdExheW91dChsYXlvdXRDb25maWcpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdE9ic2VydmVycygpIHtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoXG4gICAgICB0aGlzLl9maW5pc2hET01VcGRhdGUuYmluZCh0aGlzKVxuICAgICk7XG4gICAgdGhpcy5faG9zdEVsZW1lbnRSTyA9IG5ldyBfUmVzaXplT2JzZXJ2ZXIhKCgpID0+XG4gICAgICB0aGlzLl9ob3N0RWxlbWVudFNpemVDaGFuZ2VkKClcbiAgICApO1xuICAgIHRoaXMuX2NoaWxkcmVuUk8gPSBuZXcgX1Jlc2l6ZU9ic2VydmVyIShcbiAgICAgIHRoaXMuX2NoaWxkcmVuU2l6ZUNoYW5nZWQuYmluZCh0aGlzKVxuICAgICk7XG4gIH1cblxuICBfaW5pdEhvc3RFbGVtZW50KGNvbmZpZzogVmlydHVhbGl6ZXJDb25maWcpIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9ICh0aGlzLl9ob3N0RWxlbWVudCA9IGNvbmZpZy5ob3N0RWxlbWVudCk7XG4gICAgdGhpcy5fYXBwbHlWaXJ0dWFsaXplclN0eWxlcygpO1xuICAgIGhvc3RFbGVtZW50W3ZpcnR1YWxpemVyUmVmXSA9IHRoaXM7XG4gIH1cblxuICBjb25uZWN0ZWQoKSB7XG4gICAgdGhpcy5faW5pdE9ic2VydmVycygpO1xuICAgIGNvbnN0IGluY2x1ZGVTZWxmID0gdGhpcy5faXNTY3JvbGxlcjtcbiAgICB0aGlzLl9jbGlwcGluZ0FuY2VzdG9ycyA9IGdldENsaXBwaW5nQW5jZXN0b3JzKFxuICAgICAgdGhpcy5faG9zdEVsZW1lbnQhLFxuICAgICAgaW5jbHVkZVNlbGZcbiAgICApO1xuXG4gICAgdGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyID0gbmV3IFNjcm9sbGVyQ29udHJvbGxlcihcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLl9jbGlwcGluZ0FuY2VzdG9yc1swXVxuICAgICk7XG5cbiAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLl91cGRhdGVMYXlvdXQpO1xuICAgIHRoaXMuX29ic2VydmVBbmRMaXN0ZW4oKTtcbiAgfVxuXG4gIF9vYnNlcnZlQW5kTGlzdGVuKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIhLm9ic2VydmUodGhpcy5faG9zdEVsZW1lbnQhLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgdGhpcy5faG9zdEVsZW1lbnRSTyEub2JzZXJ2ZSh0aGlzLl9ob3N0RWxlbWVudCEpO1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzLnB1c2god2luZG93KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcywgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICAgIHRoaXMuX2NsaXBwaW5nQW5jZXN0b3JzLmZvckVhY2goKGFuY2VzdG9yKSA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnc2Nyb2xsJyxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnNcbiAgICAgICk7XG4gICAgICB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVycy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgIHRoaXMuX2hvc3RFbGVtZW50Uk8hLm9ic2VydmUoYW5jZXN0b3IpO1xuICAgIH0pO1xuICAgIHRoaXMuX2hvc3RFbGVtZW50Uk8hLm9ic2VydmUodGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyIS5lbGVtZW50KTtcbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gdGhpcy5fY2hpbGRyZW5STyEub2JzZXJ2ZShjaGlsZCkpO1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzLmZvckVhY2goKHRhcmdldCkgPT5cbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLCB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVyT3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkKCkge1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzLmZvckVhY2goKHRhcmdldCkgPT5cbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAnc2Nyb2xsJyxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnNcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fY2xpcHBpbmdBbmNlc3RvcnMgPSBbXTtcbiAgICB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXI/LmRldGFjaCh0aGlzKTtcbiAgICB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLl9ob3N0RWxlbWVudFJPPy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5faG9zdEVsZW1lbnRSTyA9IG51bGw7XG4gICAgdGhpcy5fY2hpbGRyZW5STz8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuX2NoaWxkcmVuUk8gPSBudWxsO1xuICAgIHRoaXMuX3JlamVjdExheW91dENvbXBsZXRlUHJvbWlzZSgnZGlzY29ubmVjdGVkJyk7XG4gIH1cblxuICBwcml2YXRlIF9hcHBseVZpcnR1YWxpemVyU3R5bGVzKCkge1xuICAgIGNvbnN0IGhvc3RFbGVtZW50ID0gdGhpcy5faG9zdEVsZW1lbnQhO1xuICAgIC8vIFdvdWxkIHJhdGhlciBzZXQgdGhlc2UgQ1NTIHByb3BlcnRpZXMgb24gdGhlIGhvc3QgdXNpbmcgU2hhZG93IFJvb3RcbiAgICAvLyBzdHlsZSBzY29waW5nIChhbmQgZmFsbGluZyBiYWNrIHRvIGEgZ2xvYmFsIHN0eWxlc2hlZXQgd2hlcmUgbmF0aXZlXG4gICAgLy8gU2hhZG93IERPTSBpcyBub3QgYXZhaWxhYmxlKSwgYnV0IHRoaXMgTW9iaWxlIFNhZmFyaSBidWcgaXMgcHJldmVudGluZ1xuICAgIC8vIHRoYXQgZnJvbSB3b3JraW5nOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjI2MTk1XG4gICAgY29uc3Qgc3R5bGUgPSBob3N0RWxlbWVudC5zdHlsZSBhcyBDU1NTdHlsZURlY2xhcmF0aW9uICYge2NvbnRhaW46IHN0cmluZ307XG4gICAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgICBzdHlsZS5wb3NpdGlvbiA9IHN0eWxlLnBvc2l0aW9uIHx8ICdyZWxhdGl2ZSc7XG4gICAgc3R5bGUuY29udGFpbiA9IHN0eWxlLmNvbnRhaW4gfHwgJ3NpemUgbGF5b3V0JztcblxuICAgIGlmICh0aGlzLl9pc1Njcm9sbGVyKSB7XG4gICAgICBzdHlsZS5vdmVyZmxvdyA9IHN0eWxlLm92ZXJmbG93IHx8ICdhdXRvJztcbiAgICAgIHN0eWxlLm1pbkhlaWdodCA9IHN0eWxlLm1pbkhlaWdodCB8fCAnMTUwcHgnO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRTaXplcigpIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuX2hvc3RFbGVtZW50ITtcbiAgICBpZiAoIXRoaXMuX3NpemVyKSB7XG4gICAgICAvLyBVc2UgYSBwcmVleGlzdGluZyBzaXplciBlbGVtZW50IGlmIHByb3ZpZGVkIChmb3IgYmV0dGVyIGludGVncmF0aW9uXG4gICAgICAvLyB3aXRoIHZET00gcmVuZGVyZXJzKVxuICAgICAgbGV0IHNpemVyID0gaG9zdEVsZW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgYFske1NJWkVSX0FUVFJJQlVURX1dYFxuICAgICAgKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGlmICghc2l6ZXIpIHtcbiAgICAgICAgc2l6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc2l6ZXIuc2V0QXR0cmlidXRlKFNJWkVSX0FUVFJJQlVURSwgJycpO1xuICAgICAgICBob3N0RWxlbWVudC5hcHBlbmRDaGlsZChzaXplcik7XG4gICAgICB9XG4gICAgICAvLyBXaGVuIHRoZSBzY3JvbGxIZWlnaHQgaXMgbGFyZ2UsIHRoZSBoZWlnaHQgb2YgdGhpcyBlbGVtZW50IG1pZ2h0IGJlXG4gICAgICAvLyBpZ25vcmVkLiBTZXR0aW5nIGNvbnRlbnQgYW5kIGZvbnQtc2l6ZSBlbnN1cmVzIHRoZSBlbGVtZW50IGhhcyBhIHNpemUuXG4gICAgICBPYmplY3QuYXNzaWduKHNpemVyLnN0eWxlLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBtYXJnaW46ICctMnB4IDAgMCAwJyxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICAgIGZvbnRTaXplOiAnMnB4JyxcbiAgICAgIH0pO1xuICAgICAgc2l6ZXIudGV4dENvbnRlbnQgPSAnJm5ic3A7JztcbiAgICAgIHNpemVyLnNldEF0dHJpYnV0ZShTSVpFUl9BVFRSSUJVVEUsICcnKTtcbiAgICAgIHRoaXMuX3NpemVyID0gc2l6ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zaXplcjtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZUxheW91dENvbmZpZyhsYXlvdXRDb25maWc6IExheW91dENvbmZpZ1ZhbHVlKSB7XG4gICAgLy8gSWYgbGF5b3V0IGluaXRpYWxpemF0aW9uIGhhc24ndCBmaW5pc2hlZCB5ZXQsIHdlIHdhaXRcbiAgICAvLyBmb3IgaXQgdG8gZmluaXNoIHNvIHdlIGNhbiBjaGVjayB3aGV0aGVyIHRoZSBuZXcgY29uZmlnXG4gICAgLy8gaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBleGlzdGluZyBsYXlvdXQgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgYXdhaXQgdGhpcy5fbGF5b3V0SW5pdGlhbGl6ZWQ7XG4gICAgY29uc3QgQ3RvciA9XG4gICAgICAoKGxheW91dENvbmZpZyBhcyBMYXlvdXRTcGVjaWZpZXIpLnR5cGUgYXMgTGF5b3V0Q29uc3RydWN0b3IpIHx8XG4gICAgICAvLyBUaGUgbmV3IGNvbmZpZyBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgbGF5b3V0LFxuICAgICAgLy8gc28gd2UgdXBkYXRlIHRoZSBjb25maWcgYW5kIHJldHVybiB0cnVlIHRvIGluZGljYXRlXG4gICAgICAvLyBhIHN1Y2Nlc3NmdWwgdXBkYXRlXG4gICAgICBEZWZhdWx0TGF5b3V0Q29uc3RydWN0b3I7XG4gICAgaWYgKHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIHRoaXMuX2xheW91dCBpbnN0YW5jZW9mIEN0b3IpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHsuLi4obGF5b3V0Q29uZmlnIGFzIExheW91dFNwZWNpZmllcil9IGFzIHtcbiAgICAgICAgdHlwZT86IExheW91dENvbnN0cnVjdG9yO1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBjb25maWcudHlwZTtcbiAgICAgIHRoaXMuX2xheW91dC5jb25maWcgPSBjb25maWcgYXMgQmFzZUxheW91dENvbmZpZztcbiAgICAgIC8vIFRoZSBuZXcgY29uZmlnIHJlcXVpcmVzIGEgZGlmZmVyZW50IGxheW91dCBhbHRvZ2V0aGVyLCBidXRcbiAgICAgIC8vIHRvIGxpbWl0IGltcGxlbWVudGF0aW9uIGNvbXBsZXhpdHkgd2UgZG9uJ3Qgc3VwcG9ydCBkeW5hbWljYWxseVxuICAgICAgLy8gY2hhbmdpbmcgdGhlIGxheW91dCBvZiBhbiBleGlzdGluZyB2aXJ0dWFsaXplciBpbnN0YW5jZS5cbiAgICAgIC8vIFJldHVybmluZyBmYWxzZSBoZXJlIGxldHMgdGhlIGNhbGxlciBrbm93IHRoYXQgdGhleSBzaG91bGRcbiAgICAgIC8vIGluc3RlYWQgbWFrZSBhIG5ldyB2aXJ0dWFsaXplciBpbnN0YW5jZSB3aXRoIHRoZSBkZXNpcmVkIGxheW91dC5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9pbml0TGF5b3V0KGxheW91dENvbmZpZzogTGF5b3V0Q29uZmlnVmFsdWUpIHtcbiAgICBsZXQgY29uZmlnOiBCYXNlTGF5b3V0Q29uZmlnIHwgdW5kZWZpbmVkO1xuICAgIGxldCBDdG9yOiBMYXlvdXRDb25zdHJ1Y3RvciB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIChsYXlvdXRDb25maWcgYXMgTGF5b3V0U3BlY2lmaWVyKS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgZnVsbCBMYXlvdXRTcGVjaWZpZXIsIHRoZSBgdHlwZWAgcHJvcGVydHlcbiAgICAgIC8vIGdpdmVzIHVzIG91ciBjb25zdHJ1Y3Rvci4uLlxuICAgICAgQ3RvciA9IChsYXlvdXRDb25maWcgYXMgTGF5b3V0U3BlY2lmaWVyKS50eXBlIGFzIExheW91dENvbnN0cnVjdG9yO1xuICAgICAgLy8gLi4ud2hpbGUgdGhlIHJlc3Qgb2YgdGhlIHNwZWNpZmllciBpcyBvdXIgbGF5b3V0IGNvbmZpZ1xuICAgICAgY29uc3QgY29weSA9IHsuLi4obGF5b3V0Q29uZmlnIGFzIExheW91dFNwZWNpZmllcil9IGFzIHtcbiAgICAgICAgdHlwZT86IExheW91dENvbnN0cnVjdG9yO1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBjb3B5LnR5cGU7XG4gICAgICBjb25maWcgPSBjb3B5IGFzIEJhc2VMYXlvdXRDb25maWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBmdWxsIExheW91dFNwZWNpZmllciwgd2UganVzdFxuICAgICAgLy8gaGF2ZSBhIGNvbmZpZyBmb3IgdGhlIGRlZmF1bHQgbGF5b3V0XG4gICAgICBjb25maWcgPSBsYXlvdXRDb25maWcgYXMgQmFzZUxheW91dENvbmZpZztcbiAgICB9XG5cbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY29uc3RydWN0b3IgeWV0LCBsb2FkIHRoZSBkZWZhdWx0XG4gICAgICBEZWZhdWx0TGF5b3V0Q29uc3RydWN0b3IgPSBDdG9yID0gKGF3YWl0IGltcG9ydCgnLi9sYXlvdXRzL2Zsb3cuanMnKSlcbiAgICAgICAgLkZsb3dMYXlvdXQgYXMgdW5rbm93biBhcyBMYXlvdXRDb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXlvdXQgPSBuZXcgQ3RvcihcbiAgICAgIChtZXNzYWdlOiBMYXlvdXRIb3N0TWVzc2FnZSkgPT4gdGhpcy5faGFuZGxlTGF5b3V0TWVzc2FnZShtZXNzYWdlKSxcbiAgICAgIGNvbmZpZ1xuICAgICk7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9sYXlvdXQubWVhc3VyZUNoaWxkcmVuICYmXG4gICAgICB0eXBlb2YgdGhpcy5fbGF5b3V0LnVwZGF0ZUl0ZW1TaXplcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9sYXlvdXQubWVhc3VyZUNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX21lYXN1cmVDaGlsZE92ZXJyaWRlID0gdGhpcy5fbGF5b3V0Lm1lYXN1cmVDaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lYXN1cmVDYWxsYmFjayA9IHRoaXMuX2xheW91dC51cGRhdGVJdGVtU2l6ZXMuYmluZCh0aGlzLl9sYXlvdXQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9sYXlvdXQubGlzdGVuRm9yQ2hpbGRMb2FkRXZlbnRzKSB7XG4gICAgICB0aGlzLl9ob3N0RWxlbWVudCEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2xvYWRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgfVxuXG4gIC8vIFRPRE8gKGdyYXlub3J0b24pOiBSZXdvcmsgYmVuY2htYXJraW5nIHNvIHRoYXQgaXQgaGFzIG5vIEFQSSBhbmRcbiAgLy8gaW5zdGVhZCBpcyBhbHdheXMgb24gZXhjZXB0IGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gIHN0YXJ0QmVuY2htYXJraW5nKCkge1xuICAgIGlmICh0aGlzLl9iZW5jaG1hcmtTdGFydCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fYmVuY2htYXJrU3RhcnQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICB9XG5cbiAgc3RvcEJlbmNobWFya2luZygpIHtcbiAgICBpZiAodGhpcy5fYmVuY2htYXJrU3RhcnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gbm93IC0gdGhpcy5fYmVuY2htYXJrU3RhcnQ7XG4gICAgICBjb25zdCBlbnRyaWVzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcbiAgICAgICAgJ3V2LXZpcnR1YWxpemluZycsXG4gICAgICAgICdtZWFzdXJlJ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHZpcnR1YWxpemF0aW9uVGltZSA9IGVudHJpZXNcbiAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAoZSkgPT4gZS5zdGFydFRpbWUgPj0gdGhpcy5fYmVuY2htYXJrU3RhcnQhICYmIGUuc3RhcnRUaW1lIDwgbm93XG4gICAgICAgIClcbiAgICAgICAgLnJlZHVjZSgodCwgbSkgPT4gdCArIG0uZHVyYXRpb24sIDApO1xuICAgICAgdGhpcy5fYmVuY2htYXJrU3RhcnQgPSBudWxsO1xuICAgICAgcmV0dXJuIHt0aW1lRWxhcHNlZCwgdmlydHVhbGl6YXRpb25UaW1lfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwcml2YXRlIF9tZWFzdXJlQ2hpbGRyZW4oKTogdm9pZCB7XG4gICAgY29uc3QgbW06IENoaWxkTWVhc3VyZW1lbnRzID0ge307XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBjb25zdCBmbiA9IHRoaXMuX21lYXN1cmVDaGlsZE92ZXJyaWRlIHx8IHRoaXMuX21lYXN1cmVDaGlsZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgaWR4ID0gdGhpcy5fZmlyc3QgKyBpO1xuICAgICAgaWYgKHRoaXMuX2l0ZW1zQ2hhbmdlZCB8fCB0aGlzLl90b0JlTWVhc3VyZWQuaGFzKGNoaWxkKSkge1xuICAgICAgICBtbVtpZHhdID0gZm4uY2FsbCh0aGlzLCBjaGlsZCwgdGhpcy5faXRlbXNbaWR4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkTWVhc3VyZW1lbnRzID0gbW07XG4gICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgICB0aGlzLl90b0JlTWVhc3VyZWQuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCwgaGVpZ2h0LCBhbmQgbWFyZ2lucyBvZiB0aGUgZ2l2ZW4gY2hpbGQuXG4gICAqL1xuICBfbWVhc3VyZUNoaWxkKGVsZW1lbnQ6IEVsZW1lbnQpOiBJdGVtQm94IHtcbiAgICAvLyBvZmZzZXRXaWR0aCBkb2Vzbid0IHRha2UgdHJhbnNmb3JtcyBpbiBjb25zaWRlcmF0aW9uLCBzbyB3ZSB1c2VcbiAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgd2hpY2ggZG9lcy5cbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt3aWR0aCwgaGVpZ2h0fSwgZ2V0TWFyZ2lucyhlbGVtZW50KSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3NjaGVkdWxlKG1ldGhvZDogRnVuY3Rpb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuX3NjaGVkdWxlZC5oYXMobWV0aG9kKSkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVkLmFkZChtZXRob2QpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9zY2hlZHVsZWQuZGVsZXRlKG1ldGhvZCk7XG4gICAgICBtZXRob2QuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfdXBkYXRlRE9NKHN0YXRlOiBTdGF0ZUNoYW5nZWRNZXNzYWdlKSB7XG4gICAgdGhpcy5fc2Nyb2xsU2l6ZSA9IHN0YXRlLnNjcm9sbFNpemU7XG4gICAgdGhpcy5fYWRqdXN0UmFuZ2Uoc3RhdGUucmFuZ2UpO1xuICAgIHRoaXMuX2NoaWxkcmVuUG9zID0gc3RhdGUuY2hpbGRQb3NpdGlvbnM7XG4gICAgdGhpcy5fc2Nyb2xsRXJyb3IgPSBzdGF0ZS5zY3JvbGxFcnJvciB8fCBudWxsO1xuICAgIGNvbnN0IHtfcmFuZ2VDaGFuZ2VkLCBfaXRlbXNDaGFuZ2VkfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ub3RpZnlWaXNpYmlsaXR5KCk7XG4gICAgICB0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoX3JhbmdlQ2hhbmdlZCB8fCBfaXRlbXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ub3RpZnlSYW5nZSgpO1xuICAgICAgdGhpcy5fcmFuZ2VDaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2ZpbmlzaERPTVVwZGF0ZSgpO1xuICB9XG5cbiAgX2ZpbmlzaERPTVVwZGF0ZSgpIHtcbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gdGhpcy5fY2hpbGRyZW5STyEub2JzZXJ2ZShjaGlsZCkpO1xuICAgIHRoaXMuX2NoZWNrU2Nyb2xsSW50b1ZpZXdUYXJnZXQodGhpcy5fY2hpbGRyZW5Qb3MpO1xuICAgIHRoaXMuX3Bvc2l0aW9uQ2hpbGRyZW4odGhpcy5fY2hpbGRyZW5Qb3MpO1xuICAgIHRoaXMuX3NpemVIb3N0RWxlbWVudCh0aGlzLl9zY3JvbGxTaXplKTtcbiAgICB0aGlzLl9jb3JyZWN0U2Nyb2xsRXJyb3IoKTtcbiAgICBpZiAodGhpcy5fYmVuY2htYXJrU3RhcnQgJiYgJ21hcmsnIGluIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm1hcmsoJ3V2LWVuZCcpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVMYXlvdXQoKSB7XG4gICAgLy8gT25seSB1cGRhdGUgdGhlIGxheW91dCBhbmQgdHJpZ2dlciBhIHJlLXJlbmRlciBpZiB3ZSBoYXZlOlxuICAgIC8vICAgYSkgQSBsYXlvdXRcbiAgICAvLyAgIGIpIEEgc2Nyb2xsZXJDb250cm9sbGVyLCB3aGljaCBtZWFucyB3ZSdyZSBjb25uZWN0ZWRcbiAgICBpZiAodGhpcy5fbGF5b3V0ICYmIHRoaXMuX3Njcm9sbGVyQ29udHJvbGxlcikge1xuICAgICAgdGhpcy5fbGF5b3V0Lml0ZW1zID0gdGhpcy5faXRlbXM7XG4gICAgICB0aGlzLl91cGRhdGVWaWV3KCk7XG4gICAgICBpZiAodGhpcy5fY2hpbGRNZWFzdXJlbWVudHMgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxheW91dCBoYXMgYmVlbiBjaGFuZ2VkLCB3ZSBtYXkgaGF2ZSBtZWFzdXJlbWVudHMgYnV0IG5vIGNhbGxiYWNrXG4gICAgICAgIGlmICh0aGlzLl9tZWFzdXJlQ2FsbGJhY2spIHtcbiAgICAgICAgICB0aGlzLl9tZWFzdXJlQ2FsbGJhY2sodGhpcy5fY2hpbGRNZWFzdXJlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoaWxkTWVhc3VyZW1lbnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xheW91dC5yZWZsb3dJZk5lZWRlZCgpO1xuICAgICAgaWYgKHRoaXMuX2JlbmNobWFya1N0YXJ0ICYmICdtYXJrJyBpbiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm1hcmsoJ3V2LWVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZVNjcm9sbEV2ZW50KCkge1xuICAgIGlmICh0aGlzLl9iZW5jaG1hcmtTdGFydCAmJiAnbWFyaycgaW4gd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2UubWVhc3VyZSgndXYtdmlydHVhbGl6aW5nJywgJ3V2LXN0YXJ0JywgJ3V2LWVuZCcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIG1lYXN1cmluZyBwZXJmb3JtYW5jZSBkYXRhOiAnLCBlKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5tYXJrKCd1di1zdGFydCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyIS5jb3JyZWN0aW5nU2Nyb2xsRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdXNlci1pbml0aWF0ZWQgc2Nyb2xsLCBzbyB3ZSB1bnBpbiB0aGUgbGF5b3V0XG4gICAgICB0aGlzLl9sYXlvdXQ/LnVucGluKCk7XG4gICAgfVxuICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZUxheW91dCk7XG4gIH1cblxuICBoYW5kbGVFdmVudChldmVudDogQ3VzdG9tRXZlbnQpIHtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID09PSB3aW5kb3cgfHxcbiAgICAgICAgICB0aGlzLl9jbGlwcGluZ0FuY2VzdG9ycy5pbmNsdWRlcyhldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50KVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVTY3JvbGxFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKCdldmVudCBub3QgaGFuZGxlZCcsIGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlTGF5b3V0TWVzc2FnZShtZXNzYWdlOiBMYXlvdXRIb3N0TWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdzdGF0ZUNoYW5nZWQnKSB7XG4gICAgICB0aGlzLl91cGRhdGVET00obWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICd2aXNpYmlsaXR5Q2hhbmdlZCcpIHtcbiAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZSA9IG1lc3NhZ2UuZmlyc3RWaXNpYmxlO1xuICAgICAgdGhpcy5fbGFzdFZpc2libGUgPSBtZXNzYWdlLmxhc3RWaXNpYmxlO1xuICAgICAgdGhpcy5fbm90aWZ5VmlzaWJpbGl0eSgpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSAndW5waW5uZWQnKSB7XG4gICAgICB0aGlzLl9ob3N0RWxlbWVudCEuZGlzcGF0Y2hFdmVudChuZXcgVW5waW5uZWRFdmVudCgpKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX2NoaWxkcmVuKCk6IEFycmF5PEhUTUxFbGVtZW50PiB7XG4gICAgY29uc3QgYXJyOiBBcnJheTxIVE1MRWxlbWVudD4gPSBbXTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuX2hvc3RFbGVtZW50IS5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudDtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKCFuZXh0Lmhhc0F0dHJpYnV0ZShTSVpFUl9BVFRSSUJVVEUpKSB7XG4gICAgICAgIGFyci5wdXNoKG5leHQpO1xuICAgICAgfVxuICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nIGFzIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgcHJpdmF0ZSBfdXBkYXRlVmlldygpIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuX2hvc3RFbGVtZW50O1xuICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnQgPSB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXI/LmVsZW1lbnQ7XG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5fbGF5b3V0O1xuXG4gICAgaWYgKGhvc3RFbGVtZW50ICYmIHNjcm9sbGluZ0VsZW1lbnQgJiYgbGF5b3V0KSB7XG4gICAgICBsZXQgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0O1xuXG4gICAgICBjb25zdCBob3N0RWxlbWVudEJvdW5kcyA9IGhvc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB0b3AgPSAwO1xuICAgICAgbGVmdCA9IDA7XG4gICAgICBib3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXG4gICAgICBjb25zdCBhbmNlc3RvckJvdW5kcyA9IHRoaXMuX2NsaXBwaW5nQW5jZXN0b3JzLm1hcCgoYW5jZXN0b3IpID0+XG4gICAgICAgIGFuY2VzdG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICApO1xuICAgICAgYW5jZXN0b3JCb3VuZHMudW5zaGlmdChob3N0RWxlbWVudEJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgYm91bmRzIG9mIGFuY2VzdG9yQm91bmRzKSB7XG4gICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgYm91bmRzLnRvcCk7XG4gICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBib3VuZHMubGVmdCk7XG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgYm91bmRzLmJvdHRvbSk7XG4gICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIGJvdW5kcy5yaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnRCb3VuZHMgPSBzY3JvbGxpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBjb25zdCBvZmZzZXRXaXRoaW5TY3JvbGxlciA9IHtcbiAgICAgICAgbGVmdDogaG9zdEVsZW1lbnRCb3VuZHMubGVmdCAtIHNjcm9sbGluZ0VsZW1lbnRCb3VuZHMubGVmdCxcbiAgICAgICAgdG9wOiBob3N0RWxlbWVudEJvdW5kcy50b3AgLSBzY3JvbGxpbmdFbGVtZW50Qm91bmRzLnRvcCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRvdGFsU2Nyb2xsU2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IHNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGgsXG4gICAgICAgIGhlaWdodDogc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSB0b3AgLSBob3N0RWxlbWVudEJvdW5kcy50b3AgKyBob3N0RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gbGVmdCAtIGhvc3RFbGVtZW50Qm91bmRzLmxlZnQgKyBob3N0RWxlbWVudC5zY3JvbGxMZWZ0O1xuXG4gICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcblxuICAgICAgbGF5b3V0LnZpZXdwb3J0U2l6ZSA9IHt3aWR0aCwgaGVpZ2h0fTtcbiAgICAgIGxheW91dC52aWV3cG9ydFNjcm9sbCA9IHt0b3A6IHNjcm9sbFRvcCwgbGVmdDogc2Nyb2xsTGVmdH07XG4gICAgICBsYXlvdXQudG90YWxTY3JvbGxTaXplID0gdG90YWxTY3JvbGxTaXplO1xuICAgICAgbGF5b3V0Lm9mZnNldFdpdGhpblNjcm9sbGVyID0gb2Zmc2V0V2l0aGluU2Nyb2xsZXI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgaG9zdCBlbGVtZW50IHNvIHRoYXQgaXRzIHNpemUgcmVmbGVjdHMgdGhlXG4gICAqIHRvdGFsIHNpemUgb2YgYWxsIGl0ZW1zLlxuICAgKi9cbiAgcHJpdmF0ZSBfc2l6ZUhvc3RFbGVtZW50KHNpemU/OiBTaXplIHwgbnVsbCkge1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgc2VlbSB0byBjcmFwIG91dCBpZiB0aGUgaG9zdCBlbGVtZW50IGdldHMgbGFyZ2VyIHRoYW5cbiAgICAvLyBhIGNlcnRhaW4gc2l6ZSwgc28gd2UgY2xhbXAgaXQgaGVyZSAodGhpcyB2YWx1ZSBiYXNlZCBvbiBhZCBob2NcbiAgICAvLyB0ZXN0aW5nIGluIENocm9tZSAvIFNhZmFyaSAvIEZpcmVmb3ggTWFjKVxuICAgIGNvbnN0IG1heCA9IDgyMDAwMDA7XG4gICAgY29uc3QgaCA9IHNpemUgJiYgc2l6ZS53aWR0aCAhPT0gbnVsbCA/IE1hdGgubWluKG1heCwgc2l6ZS53aWR0aCkgOiAwO1xuICAgIGNvbnN0IHYgPSBzaXplICYmIHNpemUuaGVpZ2h0ICE9PSBudWxsID8gTWF0aC5taW4obWF4LCBzaXplLmhlaWdodCkgOiAwO1xuXG4gICAgaWYgKHRoaXMuX2lzU2Nyb2xsZXIpIHtcbiAgICAgIHRoaXMuX2dldFNpemVyKCkuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2h9cHgsICR7dn1weClgO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHlsZSA9IHRoaXMuX2hvc3RFbGVtZW50IS5zdHlsZTtcbiAgICAgIChzdHlsZS5taW5XaWR0aCBhcyBzdHJpbmcgfCBudWxsKSA9IGggPyBgJHtofXB4YCA6ICcxMDAlJztcbiAgICAgIChzdHlsZS5taW5IZWlnaHQgYXMgc3RyaW5nIHwgbnVsbCkgPSB2ID8gYCR7dn1weGAgOiAnMTAwJSc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRvcCBhbmQgbGVmdCB0cmFuc2Zvcm0gc3R5bGUgb2YgdGhlIGNoaWxkcmVuIGZyb20gdGhlIHZhbHVlcyBpblxuICAgKiBwb3MuXG4gICAqL1xuICBwcml2YXRlIF9wb3NpdGlvbkNoaWxkcmVuKHBvczogQ2hpbGRQb3NpdGlvbnMgfCBudWxsKSB7XG4gICAgaWYgKHBvcykge1xuICAgICAgcG9zLmZvckVhY2goKHt0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQsIHhPZmZzZXQsIHlPZmZzZXR9LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2luZGV4IC0gdGhpcy5fZmlyc3RdO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBjaGlsZC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgY2hpbGQuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICAgICAgICAgIGNoaWxkLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtsZWZ0fXB4LCAke3RvcH1weClgO1xuICAgICAgICAgIGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGlsZC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGlsZC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoY2hpbGQuc3R5bGUubGVmdCBhcyBzdHJpbmcgfCBudWxsKSA9XG4gICAgICAgICAgICB4T2Zmc2V0ID09PSB1bmRlZmluZWQgPyBudWxsIDogeE9mZnNldCArICdweCc7XG4gICAgICAgICAgKGNoaWxkLnN0eWxlLnRvcCBhcyBzdHJpbmcgfCBudWxsKSA9XG4gICAgICAgICAgICB5T2Zmc2V0ID09PSB1bmRlZmluZWQgPyBudWxsIDogeU9mZnNldCArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2FkanVzdFJhbmdlKHJhbmdlOiBJbnRlcm5hbFJhbmdlKSB7XG4gICAgY29uc3Qge19maXJzdCwgX2xhc3QsIF9maXJzdFZpc2libGUsIF9sYXN0VmlzaWJsZX0gPSB0aGlzO1xuICAgIHRoaXMuX2ZpcnN0ID0gcmFuZ2UuZmlyc3Q7XG4gICAgdGhpcy5fbGFzdCA9IHJhbmdlLmxhc3Q7XG4gICAgdGhpcy5fZmlyc3RWaXNpYmxlID0gcmFuZ2UuZmlyc3RWaXNpYmxlO1xuICAgIHRoaXMuX2xhc3RWaXNpYmxlID0gcmFuZ2UubGFzdFZpc2libGU7XG4gICAgdGhpcy5fcmFuZ2VDaGFuZ2VkID1cbiAgICAgIHRoaXMuX3JhbmdlQ2hhbmdlZCB8fCB0aGlzLl9maXJzdCAhPT0gX2ZpcnN0IHx8IHRoaXMuX2xhc3QgIT09IF9sYXN0O1xuICAgIHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkID1cbiAgICAgIHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkIHx8XG4gICAgICB0aGlzLl9maXJzdFZpc2libGUgIT09IF9maXJzdFZpc2libGUgfHxcbiAgICAgIHRoaXMuX2xhc3RWaXNpYmxlICE9PSBfbGFzdFZpc2libGU7XG4gIH1cblxuICBwcml2YXRlIF9jb3JyZWN0U2Nyb2xsRXJyb3IoKSB7XG4gICAgaWYgKHRoaXMuX3Njcm9sbEVycm9yKSB7XG4gICAgICBjb25zdCB7c2Nyb2xsVG9wLCBzY3JvbGxMZWZ0fSA9IHRoaXMuX3Njcm9sbGVyQ29udHJvbGxlciE7XG4gICAgICBjb25zdCB7dG9wLCBsZWZ0fSA9IHRoaXMuX3Njcm9sbEVycm9yO1xuICAgICAgdGhpcy5fc2Nyb2xsRXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyIS5jb3JyZWN0U2Nyb2xsRXJyb3Ioe1xuICAgICAgICB0b3A6IHNjcm9sbFRvcCAtIHRvcCxcbiAgICAgICAgbGVmdDogc2Nyb2xsTGVmdCAtIGxlZnQsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZWxlbWVudChpbmRleDogbnVtYmVyKTogVmlydHVhbGl6ZXJDaGlsZEVsZW1lbnRQcm94eSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKGluZGV4ID09PSBJbmZpbml0eSkge1xuICAgICAgaW5kZXggPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faXRlbXM/LltpbmRleF0gPT09IHVuZGVmaW5lZFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDoge1xuICAgICAgICAgIHNjcm9sbEludG9WaWV3OiAob3B0aW9uczogU2Nyb2xsSW50b1ZpZXdPcHRpb25zID0ge30pID0+XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50SW50b1ZpZXcoey4uLm9wdGlvbnMsIGluZGV4fSksXG4gICAgICAgIH07XG4gIH1cblxuICBwcml2YXRlIF9zY3JvbGxFbGVtZW50SW50b1ZpZXcob3B0aW9uczogU2Nyb2xsRWxlbWVudEludG9WaWV3T3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmluZGV4ID49IHRoaXMuX2ZpcnN0ICYmIG9wdGlvbnMuaW5kZXggPD0gdGhpcy5fbGFzdCkge1xuICAgICAgdGhpcy5fY2hpbGRyZW5bb3B0aW9ucy5pbmRleCAtIHRoaXMuX2ZpcnN0XS5zY3JvbGxJbnRvVmlldyhvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5pbmRleCA9IE1hdGgubWluKG9wdGlvbnMuaW5kZXgsIHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKG9wdGlvbnMuYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gdGhpcy5fbGF5b3V0IS5nZXRTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7YmVoYXZpb3J9ID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsSW50b1ZpZXdDb29yZGluYXRlcyA9XG4gICAgICAgICAgdGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyIS5tYW5hZ2VkU2Nyb2xsVG8oXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNvb3JkaW5hdGVzLCB7YmVoYXZpb3J9KSxcbiAgICAgICAgICAgICgpID0+IHRoaXMuX2xheW91dCEuZ2V0U2Nyb2xsSW50b1ZpZXdDb29yZGluYXRlcyhvcHRpb25zKSxcbiAgICAgICAgICAgICgpID0+ICh0aGlzLl9zY3JvbGxJbnRvVmlld1RhcmdldCA9IG51bGwpXG4gICAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsSW50b1ZpZXdUYXJnZXQgPSBvcHRpb25zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0IS5waW4gPSBvcHRpb25zO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB3ZSBhcmUgc21vb3RobHkgc2Nyb2xsaW5nIHRvIGFuIGVsZW1lbnQgYW5kIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgKiBpcyBpbiB0aGUgRE9NLCB3ZSB1cGRhdGUgb3VyIHRhcmdldCBjb29yZGluYXRlcyBhcyBuZWVkZWRcbiAgICovXG4gIHByaXZhdGUgX2NoZWNrU2Nyb2xsSW50b1ZpZXdUYXJnZXQocG9zOiBDaGlsZFBvc2l0aW9ucyB8IG51bGwpIHtcbiAgICBjb25zdCB7aW5kZXh9ID0gdGhpcy5fc2Nyb2xsSW50b1ZpZXdUYXJnZXQgfHwge307XG4gICAgaWYgKGluZGV4ICYmIHBvcz8uaGFzKGluZGV4KSkge1xuICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsSW50b1ZpZXdDb29yZGluYXRlcyEoXG4gICAgICAgIHRoaXMuX2xheW91dCEuZ2V0U2Nyb2xsSW50b1ZpZXdDb29yZGluYXRlcyh0aGlzLl9zY3JvbGxJbnRvVmlld1RhcmdldCEpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIHJhbmdlY2hhbmdlIGV2ZW50IHdpdGggdGhlIGN1cnJlbnQgZmlyc3QsIGxhc3QsIGZpcnN0VmlzaWJsZSwgYW5kXG4gICAqIGxhc3RWaXNpYmxlLlxuICAgKi9cbiAgcHJpdmF0ZSBfbm90aWZ5UmFuZ2UoKSB7XG4gICAgdGhpcy5faG9zdEVsZW1lbnQhLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgUmFuZ2VDaGFuZ2VkRXZlbnQoe2ZpcnN0OiB0aGlzLl9maXJzdCwgbGFzdDogdGhpcy5fbGFzdH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgX25vdGlmeVZpc2liaWxpdHkoKSB7XG4gICAgdGhpcy5faG9zdEVsZW1lbnQhLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgVmlzaWJpbGl0eUNoYW5nZWRFdmVudCh7XG4gICAgICAgIGZpcnN0OiB0aGlzLl9maXJzdFZpc2libGUsXG4gICAgICAgIGxhc3Q6IHRoaXMuX2xhc3RWaXNpYmxlLFxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldCBsYXlvdXRDb21wbGV0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBMYXppbHkgY3JlYXRlIHByb21pc2VcbiAgICBpZiAoIXRoaXMuX2xheW91dENvbXBsZXRlUHJvbWlzZSkge1xuICAgICAgdGhpcy5fbGF5b3V0Q29tcGxldGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgICAgdGhpcy5fbGF5b3V0Q29tcGxldGVSZWplY3RlciA9IHJlamVjdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGF5b3V0Q29tcGxldGVQcm9taXNlO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVqZWN0TGF5b3V0Q29tcGxldGVQcm9taXNlKHJlYXNvbjogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX2xheW91dENvbXBsZXRlUmVqZWN0ZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2xheW91dENvbXBsZXRlUmVqZWN0ZXIocmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5fcmVzZXRMYXlvdXRDb21wbGV0ZVN0YXRlKCk7XG4gIH1cblxuICBwcml2YXRlIF9zY2hlZHVsZUxheW91dENvbXBsZXRlKCkge1xuICAgIC8vIERvbid0IGRvIGFueXRoaW5nIHVubGVzcyB3ZSBoYXZlIGEgcGVuZGluZyBwcm9taXNlXG4gICAgLy8gQW5kIG9ubHkgcmVxdWVzdCBhIGZyYW1lIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBkb25lIHNvXG4gICAgaWYgKHRoaXMuX2xheW91dENvbXBsZXRlUHJvbWlzZSAmJiB0aGlzLl9wZW5kaW5nTGF5b3V0Q29tcGxldGUgPT09IG51bGwpIHtcbiAgICAgIC8vIFdhaXQgb25lIGFkZGl0aW9uYWwgZnJhbWUgdG8gYmUgc3VyZSB0aGUgbGF5b3V0IGlzIHN0YWJsZVxuICAgICAgdGhpcy5fcGVuZGluZ0xheW91dENvbXBsZXRlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLl9yZXNvbHZlTGF5b3V0Q29tcGxldGVQcm9taXNlKCkpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3Jlc29sdmVMYXlvdXRDb21wbGV0ZVByb21pc2UoKSB7XG4gICAgaWYgKHRoaXMuX2xheW91dENvbXBsZXRlUmVzb2x2ZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2xheW91dENvbXBsZXRlUmVzb2x2ZXIoKTtcbiAgICB9XG4gICAgdGhpcy5fcmVzZXRMYXlvdXRDb21wbGV0ZVN0YXRlKCk7XG4gIH1cblxuICBwcml2YXRlIF9yZXNldExheW91dENvbXBsZXRlU3RhdGUoKSB7XG4gICAgdGhpcy5fbGF5b3V0Q29tcGxldGVQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVJlc29sdmVyID0gbnVsbDtcbiAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVJlamVjdGVyID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nTGF5b3V0Q29tcGxldGUgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhbmQgdXBkYXRlIHRoZSB2aWV3IGF0IHRoZSBuZXh0IG9wcG9ydHVuaXR5IHdpdGggdGhlIGdpdmVuXG4gICAqIGhvc3RFbGVtZW50IHNpemUuXG4gICAqL1xuICBwcml2YXRlIF9ob3N0RWxlbWVudFNpemVDaGFuZ2VkKCkge1xuICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZUxheW91dCk7XG4gIH1cblxuICAvLyBUT0RPIChncmF5bm9ydG9uKTogUmV0aGluayBob3cgdGhpcyB3b3Jrcy4gUHJvYmFibHkgY2hpbGQgbG9hZGluZyBpcyB0b28gc3BlY2lmaWNcbiAgLy8gdG8gaGF2ZSBkZWRpY2F0ZWQgc3VwcG9ydCBmb3I7IG1pZ2h0IHdhbnQgc29tZSBtb3JlIGdlbmVyaWMgbGlmZWN5Y2xlIGhvb2tzIGZvclxuICAvLyBsYXlvdXRzIHRvIHVzZS4gUG9zc2libHkgaGFuZGxlIG1lYXN1cmVtZW50IHRoaXMgd2F5LCB0b28sIG9yIG1heWJlIHRoYXQgcmVtYWluc1xuICAvLyBhIGZpcnN0LWNsYXNzIGZlYXR1cmU/XG5cbiAgcHJpdmF0ZSBfY2hpbGRMb2FkZWQoKSB7fVxuXG4gIC8vIFRoaXMgaXMgdGhlIGNhbGxiYWNrIGZvciB0aGUgUmVzaXplT2JzZXJ2ZXIgdGhhdCB3YXRjaGVzIHRoZVxuICAvLyB2aXJ0dWFsaXplcidzIGNoaWxkcmVuLiBXZSBsYW5kIGhlcmUgYXQgdGhlIGVuZCBvZiBldmVyeSB2aXJ0dWFsaXplclxuICAvLyB1cGRhdGUgY3ljbGUgdGhhdCByZXN1bHRzIGluIGNoYW5nZXMgdG8gcGh5c2ljYWwgaXRlbXMsIGFuZCB3ZSBhbHNvXG4gIC8vIGVuZCB1cCBoZXJlIGlmIG9uZSBvciBtb3JlIGNoaWxkcmVuIGNoYW5nZSBzaXplIGluZGVwZW5kZW50bHkgb2ZcbiAgLy8gdGhlIHZpcnR1YWxpemVyIHVwZGF0ZSBjeWNsZS5cbiAgcHJpdmF0ZSBfY2hpbGRyZW5TaXplQ2hhbmdlZChjaGFuZ2VzOiBSZXNpemVPYnNlcnZlckVudHJ5W10pIHtcbiAgICAvLyBPbmx5IG1lYXN1cmUgaWYgdGhlIGxheW91dCByZXF1aXJlcyBpdFxuICAgIGlmICh0aGlzLl9sYXlvdXQ/Lm1lYXN1cmVDaGlsZHJlbikge1xuICAgICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICB0aGlzLl90b0JlTWVhc3VyZWQuc2V0KFxuICAgICAgICAgIGNoYW5nZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQsXG4gICAgICAgICAgY2hhbmdlLmNvbnRlbnRSZWN0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tZWFzdXJlQ2hpbGRyZW4oKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgZW5kIG9mIGFuIHVwZGF0ZSBjeWNsZSwgd2UgbmVlZCB0byByZXNldCBzb21lXG4gICAgLy8gaW50ZXJuYWwgc3RhdGUuIFRoaXMgc2hvdWxkIGJlIGEgaGFybWxlc3Mgbm8tb3AgaWYgd2UncmUgaGFuZGxpbmdcbiAgICAvLyBhbiBvdXQtb2YtY3ljbGUgUmVzaXplT2JzZXJ2ZXIgY2FsbGJhY2ssIHNvIHdlIGRvbid0IG5lZWQgdG9cbiAgICAvLyBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSB0d28gY2FzZXMuXG4gICAgdGhpcy5fc2NoZWR1bGVMYXlvdXRDb21wbGV0ZSgpO1xuICAgIHRoaXMuX2l0ZW1zQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlQ2hhbmdlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1hcmdpbnMoZWw6IEVsZW1lbnQpOiBNYXJnaW5zIHtcbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHJldHVybiB7XG4gICAgbWFyZ2luVG9wOiBnZXRNYXJnaW5WYWx1ZShzdHlsZS5tYXJnaW5Ub3ApLFxuICAgIG1hcmdpblJpZ2h0OiBnZXRNYXJnaW5WYWx1ZShzdHlsZS5tYXJnaW5SaWdodCksXG4gICAgbWFyZ2luQm90dG9tOiBnZXRNYXJnaW5WYWx1ZShzdHlsZS5tYXJnaW5Cb3R0b20pLFxuICAgIG1hcmdpbkxlZnQ6IGdldE1hcmdpblZhbHVlKHN0eWxlLm1hcmdpbkxlZnQpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRNYXJnaW5WYWx1ZSh2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgZmxvYXQgPSB2YWx1ZSA/IHBhcnNlRmxvYXQodmFsdWUpIDogTmFOO1xuICByZXR1cm4gTnVtYmVyLmlzTmFOKGZsb2F0KSA/IDAgOiBmbG9hdDtcbn1cblxuLy8gVE9ETyAoZ3JheW5vcnRvbik6IERlYWwgd2l0aCBpZnJhbWVzP1xuZnVuY3Rpb24gZ2V0UGFyZW50RWxlbWVudChlbDogRWxlbWVudCkge1xuICBpZiAoZWwuYXNzaWduZWRTbG90ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsLmFzc2lnbmVkU2xvdDtcbiAgfVxuICBpZiAoZWwucGFyZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBlbC5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICByZXR1cm4gKHBhcmVudE5vZGUgYXMgU2hhZG93Um9vdCkuaG9zdCB8fCBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLy9cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEFuY2VzdG9ycyhlbDogSFRNTEVsZW1lbnQsIGluY2x1ZGVTZWxmID0gZmFsc2UpIHtcbiAgY29uc3QgYW5jZXN0b3JzOiBBcnJheTxIVE1MRWxlbWVudD4gPSBbXTtcbiAgbGV0IHBhcmVudCA9IGluY2x1ZGVTZWxmID8gZWwgOiAoZ2V0UGFyZW50RWxlbWVudChlbCkgYXMgSFRNTEVsZW1lbnQpO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgYW5jZXN0b3JzLnB1c2gocGFyZW50KTtcbiAgICBwYXJlbnQgPSBnZXRQYXJlbnRFbGVtZW50KHBhcmVudCkgYXMgSFRNTEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdBbmNlc3RvcnMoZWw6IEhUTUxFbGVtZW50LCBpbmNsdWRlU2VsZiA9IGZhbHNlKSB7XG4gIGxldCBmb3VuZEZpeGVkID0gZmFsc2U7XG4gIHJldHVybiBnZXRFbGVtZW50QW5jZXN0b3JzKGVsLCBpbmNsdWRlU2VsZikuZmlsdGVyKChhKSA9PiB7XG4gICAgaWYgKGZvdW5kRml4ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGEpO1xuICAgIGZvdW5kRml4ZWQgPSBzdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJztcbiAgICByZXR1cm4gc3R5bGUub3ZlcmZsb3cgIT09ICd2aXNpYmxlJztcbiAgfSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/Virtualizer.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/events.js":
/*!******************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/events.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RangeChangedEvent: () => (/* binding */ RangeChangedEvent),\n/* harmony export */   UnpinnedEvent: () => (/* binding */ UnpinnedEvent),\n/* harmony export */   VisibilityChangedEvent: () => (/* binding */ VisibilityChangedEvent)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nclass RangeChangedEvent extends Event {\n  constructor(range) {\n    super(RangeChangedEvent.eventName, {\n      bubbles: false\n    });\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\nRangeChangedEvent.eventName = 'rangeChanged';\nclass VisibilityChangedEvent extends Event {\n  constructor(range) {\n    super(VisibilityChangedEvent.eventName, {\n      bubbles: false\n    });\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\nVisibilityChangedEvent.eventName = 'visibilityChanged';\nclass UnpinnedEvent extends Event {\n  constructor() {\n    super(UnpinnedEvent.eventName, {\n      bubbles: false\n    });\n  }\n}\nUnpinnedEvent.eventName = 'unpinned';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7QUFNQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQVRBO0FBWUE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFUQTtBQVlBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFKQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9ldmVudHMudHM/MzE1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0IGNsYXNzIFJhbmdlQ2hhbmdlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICBzdGF0aWMgZXZlbnROYW1lID0gJ3JhbmdlQ2hhbmdlZCc7XG5cbiAgZmlyc3Q6IG51bWJlcjtcbiAgbGFzdDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHJhbmdlOiBSYW5nZSkge1xuICAgIHN1cGVyKFJhbmdlQ2hhbmdlZEV2ZW50LmV2ZW50TmFtZSwge2J1YmJsZXM6IGZhbHNlfSk7XG4gICAgdGhpcy5maXJzdCA9IHJhbmdlLmZpcnN0O1xuICAgIHRoaXMubGFzdCA9IHJhbmdlLmxhc3Q7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFZpc2liaWxpdHlDaGFuZ2VkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIHN0YXRpYyBldmVudE5hbWUgPSAndmlzaWJpbGl0eUNoYW5nZWQnO1xuXG4gIGZpcnN0OiBudW1iZXI7XG4gIGxhc3Q6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihyYW5nZTogUmFuZ2UpIHtcbiAgICBzdXBlcihWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50LmV2ZW50TmFtZSwge2J1YmJsZXM6IGZhbHNlfSk7XG4gICAgdGhpcy5maXJzdCA9IHJhbmdlLmZpcnN0O1xuICAgIHRoaXMubGFzdCA9IHJhbmdlLmxhc3Q7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVucGlubmVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIHN0YXRpYyBldmVudE5hbWUgPSAndW5waW5uZWQnO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFVucGlubmVkRXZlbnQuZXZlbnROYW1lLCB7YnViYmxlczogZmFsc2V9KTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUmFuZ2Uge1xuICBmaXJzdDogbnVtYmVyO1xuICBsYXN0OiBudW1iZXI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/events.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/lit-virtualizer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/lit-virtualizer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LitVirtualizer: () => (/* reexport safe */ _LitVirtualizer_js__WEBPACK_IMPORTED_MODULE_0__.LitVirtualizer),\n/* harmony export */   RangeChangedEvent: () => (/* reexport safe */ _events_js__WEBPACK_IMPORTED_MODULE_1__.RangeChangedEvent),\n/* harmony export */   VisibilityChangedEvent: () => (/* reexport safe */ _events_js__WEBPACK_IMPORTED_MODULE_1__.VisibilityChangedEvent)\n/* harmony export */ });\n/* harmony import */ var _LitVirtualizer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LitVirtualizer.js */ \"./node_modules/@lit-labs/virtualizer/LitVirtualizer.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ \"./node_modules/@lit-labs/virtualizer/events.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\n/**\n * Import this module to declare the lit-virtualizer custom element.\n */\ncustomElements.define('lit-virtualizer', _LitVirtualizer_js__WEBPACK_IMPORTED_MODULE_0__.LitVirtualizer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xpdC12aXJ0dWFsaXplci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9saXQtdmlydHVhbGl6ZXIudHM/MzhiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuaW1wb3J0IHtMaXRWaXJ0dWFsaXplcn0gZnJvbSAnLi9MaXRWaXJ0dWFsaXplci5qcyc7XG5leHBvcnQge0xpdFZpcnR1YWxpemVyfTtcbmV4cG9ydCB7UmFuZ2VDaGFuZ2VkRXZlbnQsIFZpc2liaWxpdHlDaGFuZ2VkRXZlbnR9IGZyb20gJy4vZXZlbnRzLmpzJztcblxuLyoqXG4gKiBJbXBvcnQgdGhpcyBtb2R1bGUgdG8gZGVjbGFyZSB0aGUgbGl0LXZpcnR1YWxpemVyIGN1c3RvbSBlbGVtZW50LlxuICovXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2xpdC12aXJ0dWFsaXplcicsIExpdFZpcnR1YWxpemVyKTtcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgSFRNTEVsZW1lbnRUYWdOYW1lTWFwIHtcbiAgICAnbGl0LXZpcnR1YWxpemVyJzogTGl0VmlydHVhbGl6ZXI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/lit-virtualizer.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/virtualize.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/virtualize.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultKeyFunction: () => (/* binding */ defaultKeyFunction),\n/* harmony export */   defaultRenderItem: () => (/* binding */ defaultRenderItem),\n/* harmony export */   virtualize: () => (/* binding */ virtualize),\n/* harmony export */   virtualizerRef: () => (/* reexport safe */ _Virtualizer_js__WEBPACK_IMPORTED_MODULE_4__.virtualizerRef)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var lit_async_directive_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/async-directive.js */ \"./node_modules/lit/async-directive.js\");\n/* harmony import */ var lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit/directives/repeat.js */ \"./node_modules/lit/directives/repeat.js\");\n/* harmony import */ var _Virtualizer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Virtualizer.js */ \"./node_modules/@lit-labs/virtualizer/Virtualizer.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\n\n\n\nconst defaultKeyFunction = item => item;\nconst defaultRenderItem = (item, idx) => (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)`${idx}: ${JSON.stringify(item, null, 2)}`;\nclass VirtualizeDirective extends lit_async_directive_js__WEBPACK_IMPORTED_MODULE_2__.AsyncDirective {\n  constructor(part) {\n    super(part);\n    this._virtualizer = null;\n    this._first = 0;\n    this._last = -1;\n    this._renderItem = (item, idx) => defaultRenderItem(item, idx + this._first);\n    this._keyFunction = (item, idx) => defaultKeyFunction(item, idx + this._first);\n    this._items = [];\n    if (part.type !== lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.PartType.CHILD) {\n      throw new Error('The virtualize directive can only be used in child expressions');\n    }\n  }\n  render(config) {\n    if (config) {\n      this._setFunctions(config);\n    }\n    const itemsToRender = [];\n    if (this._first >= 0 && this._last >= this._first) {\n      for (let i = this._first; i <= this._last; i++) {\n        itemsToRender.push(this._items[i]);\n      }\n    }\n    return (0,lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_3__.repeat)(itemsToRender, this._keyFunction, this._renderItem);\n  }\n  update(part, [config]) {\n    this._setFunctions(config);\n    const itemsChanged = this._items !== config.items;\n    this._items = config.items || [];\n    if (this._virtualizer) {\n      this._updateVirtualizerConfig(part, config);\n    } else {\n      this._initialize(part, config);\n    }\n    return itemsChanged ? lit__WEBPACK_IMPORTED_MODULE_0__.noChange : this.render();\n  }\n  async _updateVirtualizerConfig(part, config) {\n    const compatible = await this._virtualizer.updateLayoutConfig(config.layout || {});\n    if (!compatible) {\n      const hostElement = part.parentNode;\n      this._makeVirtualizer(hostElement, config);\n    }\n    this._virtualizer.items = this._items;\n  }\n  _setFunctions(config) {\n    const {\n      renderItem,\n      keyFunction\n    } = config;\n    if (renderItem) {\n      this._renderItem = (item, idx) => renderItem(item, idx + this._first);\n    }\n    if (keyFunction) {\n      this._keyFunction = (item, idx) => keyFunction(item, idx + this._first);\n    }\n  }\n  _makeVirtualizer(hostElement, config) {\n    if (this._virtualizer) {\n      this._virtualizer.disconnected();\n    }\n    const {\n      layout,\n      scroller,\n      items\n    } = config;\n    this._virtualizer = new _Virtualizer_js__WEBPACK_IMPORTED_MODULE_4__.Virtualizer({\n      hostElement,\n      layout,\n      scroller\n    });\n    this._virtualizer.items = items;\n    this._virtualizer.connected();\n  }\n  _initialize(part, config) {\n    const hostElement = part.parentNode;\n    if (hostElement && hostElement.nodeType === 1) {\n      hostElement.addEventListener('rangeChanged', e => {\n        this._first = e.first;\n        this._last = e.last;\n        this.setValue(this.render());\n      });\n      this._makeVirtualizer(hostElement, config);\n    }\n  }\n  disconnected() {\n    var _this$_virtualizer;\n    (_this$_virtualizer = this._virtualizer) === null || _this$_virtualizer === void 0 || _this$_virtualizer.disconnected();\n  }\n  reconnected() {\n    var _this$_virtualizer2;\n    (_this$_virtualizer2 = this._virtualizer) === null || _this$_virtualizer2 === void 0 || _this$_virtualizer2.connected();\n  }\n}\nconst virtualize = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(VirtualizeDirective);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL3ZpcnR1YWxpemUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBOEJBO0FBQ0E7QUFLQTtBQVVBO0FBQ0E7QUFWQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFJQTtBQUNBOztBQUlBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFJQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBSUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdmlydHVhbGl6ZS50cz81ZTg3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5pbXBvcnQge1RlbXBsYXRlUmVzdWx0LCBDaGlsZFBhcnQsIGh0bWwsIG5vQ2hhbmdlfSBmcm9tICdsaXQnO1xuaW1wb3J0IHtkaXJlY3RpdmUsIERpcmVjdGl2ZVJlc3VsdCwgUGFydEluZm8sIFBhcnRUeXBlfSBmcm9tICdsaXQvZGlyZWN0aXZlLmpzJztcbmltcG9ydCB7QXN5bmNEaXJlY3RpdmV9IGZyb20gJ2xpdC9hc3luYy1kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHtyZXBlYXQsIEtleUZufSBmcm9tICdsaXQvZGlyZWN0aXZlcy9yZXBlYXQuanMnO1xuaW1wb3J0IHtWaXJ0dWFsaXplcn0gZnJvbSAnLi9WaXJ0dWFsaXplci5qcyc7XG5pbXBvcnQge1JhbmdlQ2hhbmdlZEV2ZW50fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQge0xheW91dENvbmZpZ1ZhbHVlfSBmcm9tICcuL2xheW91dHMvc2hhcmVkL0xheW91dC5qcyc7XG5cbmV4cG9ydCB7dmlydHVhbGl6ZXJSZWYsIFZpcnR1YWxpemVySG9zdEVsZW1lbnR9IGZyb20gJy4vVmlydHVhbGl6ZXIuanMnO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHZpcnR1YWxpemUgZGlyZWN0aXZlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZpcnR1YWxpemVEaXJlY3RpdmVDb25maWc8VD4ge1xuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBsaXQtaHRtbCBUZW1wbGF0ZVJlc3VsdC4gSXQgd2lsbCBiZSB1c2VkXG4gICAqIHRvIGdlbmVyYXRlIHRoZSBET00gZm9yIGVhY2ggaXRlbSBpbiB0aGUgdmlydHVhbCBsaXN0LlxuICAgKi9cbiAgcmVuZGVySXRlbT86IFJlbmRlckl0ZW1GdW5jdGlvbjxUPjtcblxuICBrZXlGdW5jdGlvbj86IEtleUZuPFQ+O1xuXG4gIHNjcm9sbGVyPzogYm9vbGVhbjtcblxuICAvLyBUT0RPIChncmF5bm9ydG9uKTogRG9jdW1lbnQuLi5cbiAgbGF5b3V0PzogTGF5b3V0Q29uZmlnVmFsdWU7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGl0ZW1zIHRvIGRpc3BsYXkgdmlhIHRoZSByZW5kZXJJdGVtIGZ1bmN0aW9uLlxuICAgKi9cbiAgaXRlbXM/OiBBcnJheTxUPjtcbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVySXRlbUZ1bmN0aW9uPFQgPSB1bmtub3duPiA9IChcbiAgaXRlbTogVCxcbiAgaW5kZXg6IG51bWJlclxuKSA9PiBUZW1wbGF0ZVJlc3VsdDtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRLZXlGdW5jdGlvbjogS2V5Rm48dW5rbm93bj4gPSAoaXRlbTogdW5rbm93bikgPT4gaXRlbTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0UmVuZGVySXRlbTogUmVuZGVySXRlbUZ1bmN0aW9uPHVua25vd24+ID0gKFxuICBpdGVtOiB1bmtub3duLFxuICBpZHg6IG51bWJlclxuKSA9PiBodG1sYCR7aWR4fTogJHtKU09OLnN0cmluZ2lmeShpdGVtLCBudWxsLCAyKX1gO1xuXG5jbGFzcyBWaXJ0dWFsaXplRGlyZWN0aXZlPFQgPSB1bmtub3duPiBleHRlbmRzIEFzeW5jRGlyZWN0aXZlIHtcbiAgX3ZpcnR1YWxpemVyOiBWaXJ0dWFsaXplciB8IG51bGwgPSBudWxsO1xuICBfZmlyc3QgPSAwO1xuICBfbGFzdCA9IC0xO1xuICBfcmVuZGVySXRlbTogUmVuZGVySXRlbUZ1bmN0aW9uPFQ+ID0gKGl0ZW06IFQsIGlkeDogbnVtYmVyKSA9PlxuICAgIGRlZmF1bHRSZW5kZXJJdGVtKGl0ZW0sIGlkeCArIHRoaXMuX2ZpcnN0KTtcbiAgX2tleUZ1bmN0aW9uOiBLZXlGbjxUPiA9IChpdGVtOiBULCBpZHg6IG51bWJlcikgPT5cbiAgICBkZWZhdWx0S2V5RnVuY3Rpb24oaXRlbSwgaWR4ICsgdGhpcy5fZmlyc3QpO1xuICBfaXRlbXM6IEFycmF5PFQ+ID0gW107XG5cbiAgY29uc3RydWN0b3IocGFydDogUGFydEluZm8pIHtcbiAgICBzdXBlcihwYXJ0KTtcbiAgICBpZiAocGFydC50eXBlICE9PSBQYXJ0VHlwZS5DSElMRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHZpcnR1YWxpemUgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgaW4gY2hpbGQgZXhwcmVzc2lvbnMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcihjb25maWc/OiBWaXJ0dWFsaXplRGlyZWN0aXZlQ29uZmlnPFQ+KSB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5fc2V0RnVuY3Rpb25zKGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zVG9SZW5kZXI6IEFycmF5PFQ+ID0gW107XG5cbiAgICBpZiAodGhpcy5fZmlyc3QgPj0gMCAmJiB0aGlzLl9sYXN0ID49IHRoaXMuX2ZpcnN0KSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5fZmlyc3Q7IGkgPD0gdGhpcy5fbGFzdDsgaSsrKSB7XG4gICAgICAgIGl0ZW1zVG9SZW5kZXIucHVzaCh0aGlzLl9pdGVtc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBlYXQoaXRlbXNUb1JlbmRlciwgdGhpcy5fa2V5RnVuY3Rpb24sIHRoaXMuX3JlbmRlckl0ZW0pO1xuICB9XG5cbiAgdXBkYXRlKHBhcnQ6IENoaWxkUGFydCwgW2NvbmZpZ106IFtWaXJ0dWFsaXplRGlyZWN0aXZlQ29uZmlnPFQ+XSkge1xuICAgIHRoaXMuX3NldEZ1bmN0aW9ucyhjb25maWcpO1xuICAgIGNvbnN0IGl0ZW1zQ2hhbmdlZCA9IHRoaXMuX2l0ZW1zICE9PSBjb25maWcuaXRlbXM7XG4gICAgdGhpcy5faXRlbXMgPSBjb25maWcuaXRlbXMgfHwgW107XG4gICAgaWYgKHRoaXMuX3ZpcnR1YWxpemVyKSB7XG4gICAgICB0aGlzLl91cGRhdGVWaXJ0dWFsaXplckNvbmZpZyhwYXJ0LCBjb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbml0aWFsaXplKHBhcnQsIGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtc0NoYW5nZWQgPyBub0NoYW5nZSA6IHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF91cGRhdGVWaXJ0dWFsaXplckNvbmZpZyhcbiAgICBwYXJ0OiBDaGlsZFBhcnQsXG4gICAgY29uZmlnOiBWaXJ0dWFsaXplRGlyZWN0aXZlQ29uZmlnPFQ+XG4gICkge1xuICAgIGNvbnN0IGNvbXBhdGlibGUgPSBhd2FpdCB0aGlzLl92aXJ0dWFsaXplciEudXBkYXRlTGF5b3V0Q29uZmlnKFxuICAgICAgY29uZmlnLmxheW91dCB8fCB7fVxuICAgICk7XG4gICAgaWYgKCFjb21wYXRpYmxlKSB7XG4gICAgICBjb25zdCBob3N0RWxlbWVudCA9IHBhcnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIHRoaXMuX21ha2VWaXJ0dWFsaXplcihob3N0RWxlbWVudCwgY29uZmlnKTtcbiAgICB9XG4gICAgdGhpcy5fdmlydHVhbGl6ZXIhLml0ZW1zID0gdGhpcy5faXRlbXM7XG4gIH1cblxuICBwcml2YXRlIF9zZXRGdW5jdGlvbnMoY29uZmlnOiBWaXJ0dWFsaXplRGlyZWN0aXZlQ29uZmlnPFQ+KSB7XG4gICAgY29uc3Qge3JlbmRlckl0ZW0sIGtleUZ1bmN0aW9ufSA9IGNvbmZpZztcbiAgICBpZiAocmVuZGVySXRlbSkge1xuICAgICAgdGhpcy5fcmVuZGVySXRlbSA9IChpdGVtLCBpZHgpID0+IHJlbmRlckl0ZW0oaXRlbSwgaWR4ICsgdGhpcy5fZmlyc3QpO1xuICAgIH1cbiAgICBpZiAoa2V5RnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX2tleUZ1bmN0aW9uID0gKGl0ZW0sIGlkeCkgPT4ga2V5RnVuY3Rpb24oaXRlbSwgaWR4ICsgdGhpcy5fZmlyc3QpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX21ha2VWaXJ0dWFsaXplcihcbiAgICBob3N0RWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgY29uZmlnOiBWaXJ0dWFsaXplRGlyZWN0aXZlQ29uZmlnPFQ+XG4gICkge1xuICAgIGlmICh0aGlzLl92aXJ0dWFsaXplcikge1xuICAgICAgdGhpcy5fdmlydHVhbGl6ZXIuZGlzY29ubmVjdGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHtsYXlvdXQsIHNjcm9sbGVyLCBpdGVtc30gPSBjb25maWc7XG4gICAgdGhpcy5fdmlydHVhbGl6ZXIgPSBuZXcgVmlydHVhbGl6ZXIoe2hvc3RFbGVtZW50LCBsYXlvdXQsIHNjcm9sbGVyfSk7XG4gICAgdGhpcy5fdmlydHVhbGl6ZXIuaXRlbXMgPSBpdGVtcztcbiAgICB0aGlzLl92aXJ0dWFsaXplci5jb25uZWN0ZWQoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRpYWxpemUocGFydDogQ2hpbGRQYXJ0LCBjb25maWc6IFZpcnR1YWxpemVEaXJlY3RpdmVDb25maWc8VD4pIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IHBhcnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudDtcbiAgICBpZiAoaG9zdEVsZW1lbnQgJiYgaG9zdEVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGhvc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JhbmdlQ2hhbmdlZCcsIChlOiBSYW5nZUNoYW5nZWRFdmVudCkgPT4ge1xuICAgICAgICB0aGlzLl9maXJzdCA9IGUuZmlyc3Q7XG4gICAgICAgIHRoaXMuX2xhc3QgPSBlLmxhc3Q7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5yZW5kZXIoKSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX21ha2VWaXJ0dWFsaXplcihob3N0RWxlbWVudCwgY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgdGhpcy5fdmlydHVhbGl6ZXI/LmRpc2Nvbm5lY3RlZCgpO1xuICB9XG5cbiAgcmVjb25uZWN0ZWQoKSB7XG4gICAgdGhpcy5fdmlydHVhbGl6ZXI/LmNvbm5lY3RlZCgpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB2aXJ0dWFsaXplID0gZGlyZWN0aXZlKFZpcnR1YWxpemVEaXJlY3RpdmUpIGFzIDxUPihcbiAgY29uZmlnPzogVmlydHVhbGl6ZURpcmVjdGl2ZUNvbmZpZzxUPlxuKSA9PiBEaXJlY3RpdmVSZXN1bHQ8dHlwZW9mIFZpcnR1YWxpemVEaXJlY3RpdmU+O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/virtualize.js\n");

/***/ }),

/***/ "./node_modules/lit-html/development/async-directive.js":
/*!**************************************************************!*\
  !*** ./node_modules/lit-html/development/async-directive.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncDirective: () => (/* binding */ AsyncDirective),\n/* harmony export */   Directive: () => (/* reexport safe */ _directive_js__WEBPACK_IMPORTED_MODULE_1__.Directive),\n/* harmony export */   PartType: () => (/* reexport safe */ _directive_js__WEBPACK_IMPORTED_MODULE_1__.PartType),\n/* harmony export */   directive: () => (/* reexport safe */ _directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)\n/* harmony export */ });\n/* harmony import */ var _directive_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./directive-helpers.js */ \"./node_modules/lit-html/development/directive-helpers.js\");\n/* harmony import */ var _directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./directive.js */ \"./node_modules/lit-html/development/directive.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\nconst DEV_MODE = true;\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (parent, isConnected) => {\n  var _a, _b;\n  const children = parent._$disconnectableChildren;\n  if (children === undefined) {\n    return false;\n  }\n  for (const obj of children) {\n    // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n    // disambiguate AsyncDirectives from other DisconnectableChildren\n    // (as opposed to using an instanceof check to know when to call it); the\n    // redundancy of \"Directive\" in the API name is to avoid conflicting with\n    // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n    // this list\n    // Disconnect Directive (and any nested directives contained within)\n    // This property needs to remain unminified.\n    (_b = (_a = obj)['_$notifyDirectiveConnectionChanged']) === null || _b === void 0 ? void 0 : _b.call(_a, isConnected, false);\n    // Disconnect Part/TemplateInstance\n    notifyChildrenConnectedChanged(obj, isConnected);\n  }\n  return true;\n};\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = obj => {\n  let parent, children;\n  do {\n    if ((parent = obj._$parent) === undefined) {\n      break;\n    }\n    children = parent._$disconnectableChildren;\n    children.delete(obj);\n    obj = parent;\n  } while ((children === null || children === void 0 ? void 0 : children.size) === 0);\n};\nconst addDisconnectableToParent = obj => {\n  // Climb the parent tree, creating a sparse tree of children needing\n  // disconnection\n  for (let parent; parent = obj._$parent; obj = parent) {\n    let children = parent._$disconnectableChildren;\n    if (children === undefined) {\n      parent._$disconnectableChildren = children = new Set();\n    } else if (children.has(obj)) {\n      // Once we've reached a parent that already contains this child, we\n      // can short-circuit\n      break;\n    }\n    children.add(obj);\n    installDisconnectAPI(parent);\n  }\n};\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(newParent) {\n  if (this._$disconnectableChildren !== undefined) {\n    removeDisconnectableFromParent(this);\n    this._$parent = newParent;\n    addDisconnectableToParent(this);\n  } else {\n    this._$parent = newParent;\n  }\n}\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {\n  const value = this._$committedValue;\n  const children = this._$disconnectableChildren;\n  if (children === undefined || children.size === 0) {\n    return;\n  }\n  if (isClearingValue) {\n    if (Array.isArray(value)) {\n      // Iterable case: Any ChildParts created by the iterable should be\n      // disconnected and removed from this ChildPart's disconnectable\n      // children (starting at `fromPartIndex` in the case of truncation)\n      for (let i = fromPartIndex; i < value.length; i++) {\n        notifyChildrenConnectedChanged(value[i], false);\n        removeDisconnectableFromParent(value[i]);\n      }\n    } else if (value != null) {\n      // TemplateInstance case: If the value has disconnectable children (will\n      // only be in the case that it is a TemplateInstance), we disconnect it\n      // and remove it from this ChildPart's disconnectable children\n      notifyChildrenConnectedChanged(value, false);\n      removeDisconnectableFromParent(value);\n    }\n  } else {\n    notifyChildrenConnectedChanged(this, isConnected);\n  }\n}\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = obj => {\n  var _a, _b;\n  var _c, _d;\n  if (obj.type == _directive_js__WEBPACK_IMPORTED_MODULE_1__.PartType.CHILD) {\n    (_a = (_c = obj)._$notifyConnectionChanged) !== null && _a !== void 0 ? _a : _c._$notifyConnectionChanged = notifyChildPartConnectedChanged;\n    (_b = (_d = obj)._$reparentDisconnectables) !== null && _b !== void 0 ? _b : _d._$reparentDisconnectables = reparentDisconnectables;\n  }\n};\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nclass AsyncDirective extends _directive_js__WEBPACK_IMPORTED_MODULE_1__.Directive {\n  constructor() {\n    super(...arguments);\n    // @internal\n    this._$disconnectableChildren = undefined;\n  }\n  /**\n   * Initialize the part with internal fields\n   * @param part\n   * @param parent\n   * @param attributeIndex\n   */\n  _$initialize(part, parent, attributeIndex) {\n    super._$initialize(part, parent, attributeIndex);\n    addDisconnectableToParent(this);\n    this.isConnected = part._$isConnected;\n  }\n  // This property needs to remain unminified.\n  /**\n   * Called from the core code when a directive is going away from a part (in\n   * which case `shouldRemoveFromParent` should be true), and from the\n   * `setChildrenConnected` helper function when recursively changing the\n   * connection state of a tree (in which case `shouldRemoveFromParent` should\n   * be false).\n   *\n   * @param isConnected\n   * @param isClearingDirective - True when the directive itself is being\n   *     removed; false when the tree is being disconnected\n   * @internal\n   */\n  ['_$notifyDirectiveConnectionChanged'](isConnected, isClearingDirective = true) {\n    var _a, _b;\n    if (isConnected !== this.isConnected) {\n      this.isConnected = isConnected;\n      if (isConnected) {\n        (_a = this.reconnected) === null || _a === void 0 ? void 0 : _a.call(this);\n      } else {\n        (_b = this.disconnected) === null || _b === void 0 ? void 0 : _b.call(this);\n      }\n    }\n    if (isClearingDirective) {\n      notifyChildrenConnectedChanged(this, isConnected);\n      removeDisconnectableFromParent(this);\n    }\n  }\n  /**\n   * Sets the value of the directive's Part outside the normal `update`/`render`\n   * lifecycle of a directive.\n   *\n   * This method should not be called synchronously from a directive's `update`\n   * or `render`.\n   *\n   * @param directive The directive to update\n   * @param value The value to set\n   */\n  setValue(value) {\n    if ((0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isSingleExpression)(this.__part)) {\n      this.__part._$setValue(value, this);\n    } else {\n      // this.__attributeIndex will be defined in this case, but\n      // assert it in dev mode\n      if (DEV_MODE && this.__attributeIndex === undefined) {\n        throw new Error(`Expected this.__attributeIndex to be a number`);\n      }\n      const newValues = [...this.__part._$committedValue];\n      newValues[this.__attributeIndex] = value;\n      this.__part._$setValue(newValues, this, 0);\n    }\n  }\n  /**\n   * User callbacks for implementing logic to release any resources/subscriptions\n   * that may have been retained by this directive. Since directives may also be\n   * re-connected, `reconnected` should also be implemented to restore the\n   * working state of the directive prior to the next render.\n   */\n  disconnected() {}\n  reconnected() {}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvZGV2ZWxvcG1lbnQvYXN5bmMtZGlyZWN0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7OztBQXlIQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7O0FBT0E7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBOzs7QUFHQTs7O0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQUE7O0FBV0E7QUFDQTtBQWdGQTtBQS9FQTs7Ozs7O0FBTUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOzs7Ozs7QUFNQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2FzeW5jLWRpcmVjdGl2ZS50cz82YTEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIE92ZXJ2aWV3OlxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIGRlc2lnbmVkIHRvIGFkZCBzdXBwb3J0IGZvciBhbiBhc3luYyBgc2V0VmFsdWVgIEFQSSBhbmRcbiAqIGBkaXNjb25uZWN0ZWRgIGNhbGxiYWNrIHRvIGRpcmVjdGl2ZXMgd2l0aCB0aGUgbGVhc3QgaW1wYWN0IG9uIHRoZSBjb3JlXG4gKiBydW50aW1lIG9yIHBheWxvYWQgd2hlbiB0aGF0IGZlYXR1cmUgaXMgbm90IHVzZWQuXG4gKlxuICogVGhlIHN0cmF0ZWd5IGlzIHRvIGludHJvZHVjZSBhIGBBc3luY0RpcmVjdGl2ZWAgc3ViY2xhc3Mgb2ZcbiAqIGBEaXJlY3RpdmVgIHRoYXQgY2xpbWJzIHRoZSBcInBhcmVudFwiIHRyZWUgaW4gaXRzIGNvbnN0cnVjdG9yIHRvIG5vdGUgd2hpY2hcbiAqIGJyYW5jaGVzIG9mIGxpdC1odG1sJ3MgXCJsb2dpY2FsIHRyZWVcIiBvZiBkYXRhIHN0cnVjdHVyZXMgY29udGFpbiBzdWNoXG4gKiBkaXJlY3RpdmVzIGFuZCB0aHVzIG5lZWQgdG8gYmUgY3Jhd2xlZCB3aGVuIGEgc3VidHJlZSBpcyBiZWluZyBjbGVhcmVkIChvclxuICogbWFudWFsbHkgZGlzY29ubmVjdGVkKSBpbiBvcmRlciB0byBydW4gdGhlIGBkaXNjb25uZWN0ZWRgIGNhbGxiYWNrLlxuICpcbiAqIFRoZSBcIm5vZGVzXCIgb2YgdGhlIGxvZ2ljYWwgdHJlZSBpbmNsdWRlIFBhcnRzLCBUZW1wbGF0ZUluc3RhbmNlcyAoZm9yIHdoZW4gYVxuICogVGVtcGxhdGVSZXN1bHQgaXMgY29tbWl0dGVkIHRvIGEgdmFsdWUgb2YgYSBDaGlsZFBhcnQpLCBhbmQgRGlyZWN0aXZlczsgdGhlc2VcbiAqIGFsbCBpbXBsZW1lbnQgYSBjb21tb24gaW50ZXJmYWNlIGNhbGxlZCBgRGlzY29ubmVjdGFibGVDaGlsZGAuIEVhY2ggaGFzIGFcbiAqIGBfJHBhcmVudGAgcmVmZXJlbmNlIHdoaWNoIGlzIHNldCBkdXJpbmcgY29uc3RydWN0aW9uIGluIHRoZSBjb3JlIGNvZGUsIGFuZCBhXG4gKiBgXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuYCBmaWVsZCB3aGljaCBpcyBpbml0aWFsbHkgdW5kZWZpbmVkLlxuICpcbiAqIFRoZSBzcGFyc2UgdHJlZSBjcmVhdGVkIGJ5IG1lYW5zIG9mIHRoZSBgQXN5bmNEaXJlY3RpdmVgIGNvbnN0cnVjdG9yXG4gKiBjcmF3bGluZyB1cCB0aGUgYF8kcGFyZW50YCB0cmVlIGFuZCBwbGFjaW5nIGEgYF8kZGlzY29ubmVjdGFibGVDaGlsZHJlbmAgU2V0XG4gKiBvbiBlYWNoIHBhcmVudCB0aGF0IGluY2x1ZGVzIGVhY2ggY2hpbGQgdGhhdCBjb250YWlucyBhXG4gKiBgQXN5bmNEaXJlY3RpdmVgIGRpcmVjdGx5IG9yIHRyYW5zaXRpdmVseSB2aWEgaXRzIGNoaWxkcmVuLiBJbiBvcmRlciB0b1xuICogbm90aWZ5IGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcyBhbmQgZGlzY29ubmVjdCAob3IgcmVjb25uZWN0KSBhIHRyZWUsIHRoZVxuICogYF8kbm90aWZ5Q29ubmVjdGlvbkNoYW5nZWRgIEFQSSBpcyBwYXRjaGVkIG9udG8gQ2hpbGRQYXJ0cyBhcyBhIGRpcmVjdGl2ZVxuICogY2xpbWJzIHRoZSBwYXJlbnQgdHJlZSwgd2hpY2ggaXMgY2FsbGVkIGJ5IHRoZSBjb3JlIHdoZW4gY2xlYXJpbmcgYSBwYXJ0IGlmXG4gKiBpdCBleGlzdHMuIFdoZW4gY2FsbGVkLCB0aGF0IG1ldGhvZCBpdGVyYXRlcyBvdmVyIHRoZSBzcGFyc2UgdHJlZSBvZlxuICogU2V0PERpc2Nvbm5lY3RhYmxlQ2hpbGRyZW4+IGJ1aWx0IHVwIGJ5IEFzeW5jRGlyZWN0aXZlcywgYW5kIGNhbGxzXG4gKiBgXyRub3RpZnlEaXJlY3RpdmVDb25uZWN0aW9uQ2hhbmdlZGAgb24gYW55IGRpcmVjdGl2ZXMgdGhhdCBhcmUgZW5jb3VudGVyZWRcbiAqIGluIHRoYXQgdHJlZSwgcnVubmluZyB0aGUgcmVxdWlyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEEgZ2l2ZW4gXCJsb2dpY2FsIHRyZWVcIiBvZiBsaXQtaHRtbCBkYXRhLXN0cnVjdHVyZXMgbWlnaHQgbG9vayBsaWtlIHRoaXM6XG4gKlxuICogIENoaWxkUGFydChOMSkgXyRkQz1bRDIsVDNdXG4gKiAgIC5fZGlyZWN0aXZlXG4gKiAgICAgQXN5bmNEaXJlY3RpdmUoRDIpXG4gKiAgIC5fdmFsdWUgLy8gdXNlciB2YWx1ZSB3YXMgVGVtcGxhdGVSZXN1bHRcbiAqICAgICBUZW1wbGF0ZUluc3RhbmNlKFQzKSBfJGRDPVtBNCxBNixOMTAsTjEyXVxuICogICAgICAuXyRwYXJ0c1tdXG4gKiAgICAgICAgQXR0cmlidXRlUGFydChBNCkgXyRkQz1bRDVdXG4gKiAgICAgICAgIC5fZGlyZWN0aXZlc1tdXG4gKiAgICAgICAgICAgQXN5bmNEaXJlY3RpdmUoRDUpXG4gKiAgICAgICAgQXR0cmlidXRlUGFydChBNikgXyRkQz1bRDcsRDhdXG4gKiAgICAgICAgIC5fZGlyZWN0aXZlc1tdXG4gKiAgICAgICAgICAgQXN5bmNEaXJlY3RpdmUoRDcpXG4gKiAgICAgICAgICAgRGlyZWN0aXZlKEQ4KSBfJGRDPVtEOV1cbiAqICAgICAgICAgICAgLl9kaXJlY3RpdmVcbiAqICAgICAgICAgICAgICBBc3luY0RpcmVjdGl2ZShEOSlcbiAqICAgICAgICBDaGlsZFBhcnQoTjEwKSBfJGRDPVtEMTFdXG4gKiAgICAgICAgIC5fZGlyZWN0aXZlXG4gKiAgICAgICAgICAgQXN5bmNEaXJlY3RpdmUoRDExKVxuICogICAgICAgICAuX3ZhbHVlXG4gKiAgICAgICAgICAgc3RyaW5nXG4gKiAgICAgICAgQ2hpbGRQYXJ0KE4xMikgXyRkQz1bRDEzLE4xNCxOMTZdXG4gKiAgICAgICAgIC5fZGlyZWN0aXZlXG4gKiAgICAgICAgICAgQXN5bmNEaXJlY3RpdmUoRDEzKVxuICogICAgICAgICAuX3ZhbHVlIC8vIHVzZXIgdmFsdWUgd2FzIGl0ZXJhYmxlXG4gKiAgICAgICAgICAgQXJyYXk8Q2hpbGRQYXJ0PlxuICogICAgICAgICAgICAgQ2hpbGRQYXJ0KE4xNCkgXyRkQz1bRDE1XVxuICogICAgICAgICAgICAgIC5fdmFsdWVcbiAqICAgICAgICAgICAgICAgIHN0cmluZ1xuICogICAgICAgICAgICAgQ2hpbGRQYXJ0KE4xNikgXyRkQz1bRDE3LFQxOF1cbiAqICAgICAgICAgICAgICAuX2RpcmVjdGl2ZVxuICogICAgICAgICAgICAgICAgQXN5bmNEaXJlY3RpdmUoRDE3KVxuICogICAgICAgICAgICAgIC5fdmFsdWUgLy8gdXNlciB2YWx1ZSB3YXMgVGVtcGxhdGVSZXN1bHRcbiAqICAgICAgICAgICAgICAgIFRlbXBsYXRlSW5zdGFuY2UoVDE4KSBfJGRDPVtBMTksQTIxLE4yNV1cbiAqICAgICAgICAgICAgICAgICAuXyRwYXJ0c1tdXG4gKiAgICAgICAgICAgICAgICAgICBBdHRyaWJ1dGVQYXJ0KEExOSkgXyRkQz1bRDIwXVxuICogICAgICAgICAgICAgICAgICAgIC5fZGlyZWN0aXZlc1tdXG4gKiAgICAgICAgICAgICAgICAgICAgICBBc3luY0RpcmVjdGl2ZShEMjApXG4gKiAgICAgICAgICAgICAgICAgICBBdHRyaWJ1dGVQYXJ0KEEyMSkgXyRkQz1bMjIsMjNdXG4gKiAgICAgICAgICAgICAgICAgICAgLl9kaXJlY3RpdmVzW11cbiAqICAgICAgICAgICAgICAgICAgICAgIEFzeW5jRGlyZWN0aXZlKEQyMilcbiAqICAgICAgICAgICAgICAgICAgICAgIERpcmVjdGl2ZShEMjMpIF8kZEM9W0QyNF1cbiAqICAgICAgICAgICAgICAgICAgICAgICAuX2RpcmVjdGl2ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgQXN5bmNEaXJlY3RpdmUoRDI0KVxuICogICAgICAgICAgICAgICAgICAgQ2hpbGRQYXJ0KE4yNSkgXyRkQz1bRDI2XVxuICogICAgICAgICAgICAgICAgICAgIC5fZGlyZWN0aXZlXG4gKiAgICAgICAgICAgICAgICAgICAgICBBc3luY0RpcmVjdGl2ZShEMjYpXG4gKiAgICAgICAgICAgICAgICAgICAgLl92YWx1ZVxuICogICAgICAgICAgICAgICAgICAgICAgc3RyaW5nXG4gKlxuICogRXhhbXBsZSAxOiBUaGUgZGlyZWN0aXZlIGluIENoaWxkUGFydChOMTIpIHVwZGF0ZXMgYW5kIHJldHVybnMgYG5vdGhpbmdgLiBUaGVcbiAqIENoaWxkUGFydCB3aWxsIF9jbGVhcigpIGl0c2VsZiwgYW5kIHNvIHdlIG5lZWQgdG8gZGlzY29ubmVjdCB0aGUgXCJ2YWx1ZVwiIG9mXG4gKiB0aGUgQ2hpbGRQYXJ0IChidXQgbm90IGl0cyBkaXJlY3RpdmUpLiBJbiB0aGlzIGNhc2UsIHdoZW4gYF9jbGVhcigpYCBjYWxsc1xuICogYF8kbm90aWZ5Q29ubmVjdGlvbkNoYW5nZWQoKWAsIHdlIGRvbid0IGl0ZXJhdGUgYWxsIG9mIHRoZVxuICogXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuLCByYXRoZXIgd2UgZG8gYSB2YWx1ZS1zcGVjaWZpYyBkaXNjb25uZWN0aW9uOiBpLmUuXG4gKiBzaW5jZSB0aGUgX3ZhbHVlIHdhcyBhbiBBcnJheTxDaGlsZFBhcnQ+IChiZWNhdXNlIGFuIGl0ZXJhYmxlIGhhZCBiZWVuXG4gKiBjb21taXR0ZWQpLCB3ZSBpdGVyYXRlIHRoZSBhcnJheSBvZiBDaGlsZFBhcnRzIChOMTQsIE4xNikgYW5kIHJ1blxuICogYHNldENvbm5lY3RlZGAgb24gdGhlbSAod2hpY2ggZG9lcyByZWN1cnNlIGRvd24gdGhlIGZ1bGwgdHJlZSBvZlxuICogYF8kZGlzY29ubmVjdGFibGVDaGlsZHJlbmAgYmVsb3cgaXQsIGFuZCBhbHNvIHJlbW92ZXMgTjE0IGFuZCBOMTYgZnJvbSBOMTInc1xuICogYF8kZGlzY29ubmVjdGFibGVDaGlsZHJlbmApLiBPbmNlIHRoZSB2YWx1ZXMgaGF2ZSBiZWVuIGRpc2Nvbm5lY3RlZCwgd2UgdGhlblxuICogY2hlY2sgd2hldGhlciB0aGUgQ2hpbGRQYXJ0KE4xMikncyBsaXN0IG9mIGBfJGRpc2Nvbm5lY3RhYmxlQ2hpbGRyZW5gIGlzIGVtcHR5XG4gKiAoYW5kIHdvdWxkIHJlbW92ZSBpdCBmcm9tIGl0cyBwYXJlbnQgVGVtcGxhdGVJbnN0YW5jZShUMykgaWYgc28pLCBidXQgc2luY2VcbiAqIGl0IHdvdWxkIHN0aWxsIGNvbnRhaW4gaXRzIGRpcmVjdGl2ZSBEMTMsIGl0IHN0YXlzIGluIHRoZSBkaXNjb25uZWN0YWJsZVxuICogdHJlZS5cbiAqXG4gKiBFeGFtcGxlIDI6IEluIHRoZSBjb3Vyc2Ugb2YgRXhhbXBsZSAxLCBgc2V0Q29ubmVjdGVkYCB3aWxsIHJlYWNoXG4gKiBDaGlsZFBhcnQoTjE2KTsgaW4gdGhpcyBjYXNlIHRoZSBlbnRpcmUgcGFydCBpcyBiZWluZyBkaXNjb25uZWN0ZWQsIHNvIHdlXG4gKiBzaW1wbHkgaXRlcmF0ZSBhbGwgb2YgTjE2J3MgYF8kZGlzY29ubmVjdGFibGVDaGlsZHJlbmAgKEQxNyxUMTgpIGFuZFxuICogcmVjdXJzaXZlbHkgcnVuIGBzZXRDb25uZWN0ZWRgIG9uIHRoZW0uIE5vdGUgdGhhdCB3ZSBvbmx5IHJlbW92ZSBjaGlsZHJlblxuICogZnJvbSBgXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuYCBmb3IgdGhlIHRvcC1sZXZlbCB2YWx1ZXMgYmVpbmcgZGlzY29ubmVjdGVkXG4gKiBvbiBhIGNsZWFyOyBkb2luZyB0aGlzIGJvb2trZWVwaW5nIGxvd2VyIGluIHRoZSB0cmVlIGlzIHdhc3RlZnVsIHNpbmNlIGl0J3NcbiAqIGFsbCBiZWluZyB0aHJvd24gYXdheS5cbiAqXG4gKiBFeGFtcGxlIDM6IElmIHRoZSBMaXRFbGVtZW50IGNvbnRhaW5pbmcgdGhlIGVudGlyZSB0cmVlIGFib3ZlIGJlY29tZXNcbiAqIGRpc2Nvbm5lY3RlZCwgaXQgd2lsbCBydW4gYGNoaWxkUGFydC5zZXRDb25uZWN0ZWQoKWAgKHdoaWNoIGNhbGxzXG4gKiBgY2hpbGRQYXJ0Ll8kbm90aWZ5Q29ubmVjdGlvbkNoYW5nZWQoKWAgaWYgaXQgZXhpc3RzKTsgaW4gdGhpcyBjYXNlLCB3ZVxuICogcmVjdXJzaXZlbHkgcnVuIGBzZXRDb25uZWN0ZWQoKWAgb3ZlciB0aGUgZW50aXJlIHRyZWUsIHdpdGhvdXQgcmVtb3ZpbmcgYW55XG4gKiBjaGlsZHJlbiBmcm9tIGBfJGRpc2Nvbm5lY3RhYmxlQ2hpbGRyZW5gLCBzaW5jZSB0aGlzIHRyZWUgaXMgcmVxdWlyZWQgdG9cbiAqIHJlLWNvbm5lY3QgdGhlIHRyZWUsIHdoaWNoIGRvZXMgdGhlIHNhbWUgb3BlcmF0aW9uLCBzaW1wbHkgcGFzc2luZ1xuICogYGlzQ29ubmVjdGVkOiB0cnVlYCBkb3duIHRoZSB0cmVlLCBzaWduYWxpbmcgd2hpY2ggY2FsbGJhY2sgdG8gcnVuLlxuICovXG5cbmltcG9ydCB7QXR0cmlidXRlUGFydCwgQ2hpbGRQYXJ0LCBEaXNjb25uZWN0YWJsZSwgUGFydH0gZnJvbSAnLi9saXQtaHRtbC5qcyc7XG5pbXBvcnQge2lzU2luZ2xlRXhwcmVzc2lvbn0gZnJvbSAnLi9kaXJlY3RpdmUtaGVscGVycy5qcyc7XG5pbXBvcnQge0RpcmVjdGl2ZSwgUGFydEluZm8sIFBhcnRUeXBlfSBmcm9tICcuL2RpcmVjdGl2ZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2RpcmVjdGl2ZS5qcyc7XG5cbmNvbnN0IERFVl9NT0RFID0gdHJ1ZTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB3YWxrcyBkb3duIHRoZSB0cmVlIG9mIFBhcnRzL1RlbXBsYXRlSW5zdGFuY2VzL0RpcmVjdGl2ZXMgdG8gc2V0XG4gKiB0aGUgY29ubmVjdGVkIHN0YXRlIG9mIGRpcmVjdGl2ZXMgYW5kIHJ1biBgZGlzY29ubmVjdGVkYC8gYHJlY29ubmVjdGVkYFxuICogY2FsbGJhY2tzLlxuICpcbiAqIEByZXR1cm4gVHJ1ZSBpZiB0aGVyZSB3ZXJlIGNoaWxkcmVuIHRvIGRpc2Nvbm5lY3Q7IGZhbHNlIG90aGVyd2lzZVxuICovXG5jb25zdCBub3RpZnlDaGlsZHJlbkNvbm5lY3RlZENoYW5nZWQgPSAoXG4gIHBhcmVudDogRGlzY29ubmVjdGFibGUsXG4gIGlzQ29ubmVjdGVkOiBib29sZWFuXG4pOiBib29sZWFuID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IG9iaiBvZiBjaGlsZHJlbikge1xuICAgIC8vIFRoZSBleGlzdGVuY2Ugb2YgYF8kbm90aWZ5RGlyZWN0aXZlQ29ubmVjdGlvbkNoYW5nZWRgIGlzIHVzZWQgYXMgYSBcImJyYW5kXCIgdG9cbiAgICAvLyBkaXNhbWJpZ3VhdGUgQXN5bmNEaXJlY3RpdmVzIGZyb20gb3RoZXIgRGlzY29ubmVjdGFibGVDaGlsZHJlblxuICAgIC8vIChhcyBvcHBvc2VkIHRvIHVzaW5nIGFuIGluc3RhbmNlb2YgY2hlY2sgdG8ga25vdyB3aGVuIHRvIGNhbGwgaXQpOyB0aGVcbiAgICAvLyByZWR1bmRhbmN5IG9mIFwiRGlyZWN0aXZlXCIgaW4gdGhlIEFQSSBuYW1lIGlzIHRvIGF2b2lkIGNvbmZsaWN0aW5nIHdpdGhcbiAgICAvLyBgXyRub3RpZnlDb25uZWN0aW9uQ2hhbmdlZGAsIHdoaWNoIGV4aXN0cyBgQ2hpbGRQYXJ0c2Agd2hpY2ggYXJlIGFsc28gaW5cbiAgICAvLyB0aGlzIGxpc3RcbiAgICAvLyBEaXNjb25uZWN0IERpcmVjdGl2ZSAoYW5kIGFueSBuZXN0ZWQgZGlyZWN0aXZlcyBjb250YWluZWQgd2l0aGluKVxuICAgIC8vIFRoaXMgcHJvcGVydHkgbmVlZHMgdG8gcmVtYWluIHVubWluaWZpZWQuXG4gICAgKG9iaiBhcyBBc3luY0RpcmVjdGl2ZSlbJ18kbm90aWZ5RGlyZWN0aXZlQ29ubmVjdGlvbkNoYW5nZWQnXT8uKFxuICAgICAgaXNDb25uZWN0ZWQsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgLy8gRGlzY29ubmVjdCBQYXJ0L1RlbXBsYXRlSW5zdGFuY2VcbiAgICBub3RpZnlDaGlsZHJlbkNvbm5lY3RlZENoYW5nZWQob2JqLCBpc0Nvbm5lY3RlZCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIGNoaWxkIGZyb20gaXRzIHBhcmVudCBsaXN0IG9mIGRpc2Nvbm5lY3RhYmxlIGNoaWxkcmVuLCBhbmRcbiAqIGlmIHRoZSBwYXJlbnQgbGlzdCBiZWNvbWVzIGVtcHR5IGFzIGEgcmVzdWx0LCByZW1vdmVzIHRoZSBwYXJlbnQgZnJvbSBpdHNcbiAqIHBhcmVudCwgYW5kIHNvIGZvcnRoIHVwIHRoZSB0cmVlIHdoZW4gdGhhdCBjYXVzZXMgc3Vic2VxdWVudCBwYXJlbnQgbGlzdHMgdG9cbiAqIGJlY29tZSBlbXB0eS5cbiAqL1xuY29uc3QgcmVtb3ZlRGlzY29ubmVjdGFibGVGcm9tUGFyZW50ID0gKG9iajogRGlzY29ubmVjdGFibGUpID0+IHtcbiAgbGV0IHBhcmVudCwgY2hpbGRyZW47XG4gIGRvIHtcbiAgICBpZiAoKHBhcmVudCA9IG9iai5fJHBhcmVudCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNoaWxkcmVuID0gcGFyZW50Ll8kZGlzY29ubmVjdGFibGVDaGlsZHJlbiE7XG4gICAgY2hpbGRyZW4uZGVsZXRlKG9iaik7XG4gICAgb2JqID0gcGFyZW50O1xuICB9IHdoaWxlIChjaGlsZHJlbj8uc2l6ZSA9PT0gMCk7XG59O1xuXG5jb25zdCBhZGREaXNjb25uZWN0YWJsZVRvUGFyZW50ID0gKG9iajogRGlzY29ubmVjdGFibGUpID0+IHtcbiAgLy8gQ2xpbWIgdGhlIHBhcmVudCB0cmVlLCBjcmVhdGluZyBhIHNwYXJzZSB0cmVlIG9mIGNoaWxkcmVuIG5lZWRpbmdcbiAgLy8gZGlzY29ubmVjdGlvblxuICBmb3IgKGxldCBwYXJlbnQ7IChwYXJlbnQgPSBvYmouXyRwYXJlbnQpOyBvYmogPSBwYXJlbnQpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBwYXJlbnQuXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJlbnQuXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuID0gY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZHJlbi5oYXMob2JqKSkge1xuICAgICAgLy8gT25jZSB3ZSd2ZSByZWFjaGVkIGEgcGFyZW50IHRoYXQgYWxyZWFkeSBjb250YWlucyB0aGlzIGNoaWxkLCB3ZVxuICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXRcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjaGlsZHJlbi5hZGQob2JqKTtcbiAgICBpbnN0YWxsRGlzY29ubmVjdEFQSShwYXJlbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIHBhcmVudCByZWZlcmVuY2Ugb2YgdGhlIENoaWxkUGFydCwgYW5kIHVwZGF0ZXMgdGhlIHNwYXJzZSB0cmVlIG9mXG4gKiBEaXNjb25uZWN0YWJsZSBjaGlsZHJlbiBhY2NvcmRpbmdseS5cbiAqXG4gKiBOb3RlLCB0aGlzIG1ldGhvZCB3aWxsIGJlIHBhdGNoZWQgb250byBDaGlsZFBhcnQgaW5zdGFuY2VzIGFuZCBjYWxsZWQgZnJvbVxuICogdGhlIGNvcmUgY29kZSB3aGVuIHBhcnRzIGFyZSBtb3ZlZCBiZXR3ZWVuIGRpZmZlcmVudCBwYXJlbnRzLlxuICovXG5mdW5jdGlvbiByZXBhcmVudERpc2Nvbm5lY3RhYmxlcyh0aGlzOiBDaGlsZFBhcnQsIG5ld1BhcmVudDogRGlzY29ubmVjdGFibGUpIHtcbiAgaWYgKHRoaXMuXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICByZW1vdmVEaXNjb25uZWN0YWJsZUZyb21QYXJlbnQodGhpcyk7XG4gICAgdGhpcy5fJHBhcmVudCA9IG5ld1BhcmVudDtcbiAgICBhZGREaXNjb25uZWN0YWJsZVRvUGFyZW50KHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuXyRwYXJlbnQgPSBuZXdQYXJlbnQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBjb25uZWN0ZWQgc3RhdGUgb24gYW55IGRpcmVjdGl2ZXMgY29udGFpbmVkIHdpdGhpbiB0aGUgY29tbWl0dGVkXG4gKiB2YWx1ZSBvZiB0aGlzIHBhcnQgKGkuZS4gd2l0aGluIGEgVGVtcGxhdGVJbnN0YW5jZSBvciBpdGVyYWJsZSBvZlxuICogQ2hpbGRQYXJ0cykgYW5kIHJ1bnMgdGhlaXIgYGRpc2Nvbm5lY3RlZGAvYHJlY29ubmVjdGVkYHMsIGFzIHdlbGwgYXMgd2l0aGluXG4gKiBhbnkgZGlyZWN0aXZlcyBzdG9yZWQgb24gdGhlIENoaWxkUGFydCAod2hlbiBgdmFsdWVPbmx5YCBpcyBmYWxzZSkuXG4gKlxuICogYGlzQ2xlYXJpbmdWYWx1ZWAgc2hvdWxkIGJlIHBhc3NlZCBhcyBgdHJ1ZWAgb24gYSB0b3AtbGV2ZWwgcGFydCB0aGF0IGlzXG4gKiBjbGVhcmluZyBpdHNlbGYsIGFuZCBub3QgYXMgYSByZXN1bHQgb2YgcmVjdXJzaXZlbHkgZGlzY29ubmVjdGluZyBkaXJlY3RpdmVzXG4gKiBhcyBwYXJ0IG9mIGEgYGNsZWFyYCBvcGVyYXRpb24gaGlnaGVyIHVwIHRoZSB0cmVlLiBUaGlzIGJvdGggZW5zdXJlcyB0aGF0IGFueVxuICogZGlyZWN0aXZlIG9uIHRoaXMgQ2hpbGRQYXJ0IHRoYXQgcHJvZHVjZWQgYSB2YWx1ZSB0aGF0IGNhdXNlZCB0aGUgY2xlYXJcbiAqIG9wZXJhdGlvbiBpcyBub3QgZGlzY29ubmVjdGVkLCBhbmQgYWxzbyBzZXJ2ZXMgYXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25cbiAqIHRvIGF2b2lkIG5lZWRsZXNzIGJvb2trZWVwaW5nIHdoZW4gYSBzdWJ0cmVlIGlzIGdvaW5nIGF3YXk7IHdoZW4gY2xlYXJpbmcgYVxuICogc3VidHJlZSwgb25seSB0aGUgdG9wLW1vc3QgcGFydCBuZWVkIHRvIHJlbW92ZSBpdHNlbGYgZnJvbSB0aGUgcGFyZW50LlxuICpcbiAqIGBmcm9tUGFydEluZGV4YCBpcyBwYXNzZWQgb25seSBpbiB0aGUgY2FzZSBvZiBhIHBhcnRpYWwgYF9jbGVhcmAgcnVubmluZyBhcyBhXG4gKiByZXN1bHQgb2YgdHJ1bmNhdGluZyBhbiBpdGVyYWJsZS5cbiAqXG4gKiBOb3RlLCB0aGlzIG1ldGhvZCB3aWxsIGJlIHBhdGNoZWQgb250byBDaGlsZFBhcnQgaW5zdGFuY2VzIGFuZCBjYWxsZWQgZnJvbSB0aGVcbiAqIGNvcmUgY29kZSB3aGVuIHBhcnRzIGFyZSBjbGVhcmVkIG9yIHRoZSBjb25uZWN0aW9uIHN0YXRlIGlzIGNoYW5nZWQgYnkgdGhlXG4gKiB1c2VyLlxuICovXG5mdW5jdGlvbiBub3RpZnlDaGlsZFBhcnRDb25uZWN0ZWRDaGFuZ2VkKFxuICB0aGlzOiBDaGlsZFBhcnQsXG4gIGlzQ29ubmVjdGVkOiBib29sZWFuLFxuICBpc0NsZWFyaW5nVmFsdWUgPSBmYWxzZSxcbiAgZnJvbVBhcnRJbmRleCA9IDBcbikge1xuICBjb25zdCB2YWx1ZSA9IHRoaXMuXyRjb21taXR0ZWRWYWx1ZTtcbiAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl8kZGlzY29ubmVjdGFibGVDaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuID09PSB1bmRlZmluZWQgfHwgY2hpbGRyZW4uc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNDbGVhcmluZ1ZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBJdGVyYWJsZSBjYXNlOiBBbnkgQ2hpbGRQYXJ0cyBjcmVhdGVkIGJ5IHRoZSBpdGVyYWJsZSBzaG91bGQgYmVcbiAgICAgIC8vIGRpc2Nvbm5lY3RlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoaXMgQ2hpbGRQYXJ0J3MgZGlzY29ubmVjdGFibGVcbiAgICAgIC8vIGNoaWxkcmVuIChzdGFydGluZyBhdCBgZnJvbVBhcnRJbmRleGAgaW4gdGhlIGNhc2Ugb2YgdHJ1bmNhdGlvbilcbiAgICAgIGZvciAobGV0IGkgPSBmcm9tUGFydEluZGV4OyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm90aWZ5Q2hpbGRyZW5Db25uZWN0ZWRDaGFuZ2VkKHZhbHVlW2ldLCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZURpc2Nvbm5lY3RhYmxlRnJvbVBhcmVudCh2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBUZW1wbGF0ZUluc3RhbmNlIGNhc2U6IElmIHRoZSB2YWx1ZSBoYXMgZGlzY29ubmVjdGFibGUgY2hpbGRyZW4gKHdpbGxcbiAgICAgIC8vIG9ubHkgYmUgaW4gdGhlIGNhc2UgdGhhdCBpdCBpcyBhIFRlbXBsYXRlSW5zdGFuY2UpLCB3ZSBkaXNjb25uZWN0IGl0XG4gICAgICAvLyBhbmQgcmVtb3ZlIGl0IGZyb20gdGhpcyBDaGlsZFBhcnQncyBkaXNjb25uZWN0YWJsZSBjaGlsZHJlblxuICAgICAgbm90aWZ5Q2hpbGRyZW5Db25uZWN0ZWRDaGFuZ2VkKHZhbHVlIGFzIERpc2Nvbm5lY3RhYmxlLCBmYWxzZSk7XG4gICAgICByZW1vdmVEaXNjb25uZWN0YWJsZUZyb21QYXJlbnQodmFsdWUgYXMgRGlzY29ubmVjdGFibGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub3RpZnlDaGlsZHJlbkNvbm5lY3RlZENoYW5nZWQodGhpcywgaXNDb25uZWN0ZWQpO1xuICB9XG59XG5cbi8qKlxuICogUGF0Y2hlcyBkaXNjb25uZWN0aW9uIEFQSSBvbnRvIENoaWxkUGFydHMuXG4gKi9cbmNvbnN0IGluc3RhbGxEaXNjb25uZWN0QVBJID0gKG9iajogRGlzY29ubmVjdGFibGUpID0+IHtcbiAgaWYgKChvYmogYXMgQ2hpbGRQYXJ0KS50eXBlID09IFBhcnRUeXBlLkNISUxEKSB7XG4gICAgKG9iaiBhcyBDaGlsZFBhcnQpLl8kbm90aWZ5Q29ubmVjdGlvbkNoYW5nZWQgPz89XG4gICAgICBub3RpZnlDaGlsZFBhcnRDb25uZWN0ZWRDaGFuZ2VkO1xuICAgIChvYmogYXMgQ2hpbGRQYXJ0KS5fJHJlcGFyZW50RGlzY29ubmVjdGFibGVzID8/PSByZXBhcmVudERpc2Nvbm5lY3RhYmxlcztcbiAgfVxufTtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBgRGlyZWN0aXZlYCBiYXNlIGNsYXNzIHdob3NlIGBkaXNjb25uZWN0ZWRgIG1ldGhvZCB3aWxsIGJlXG4gKiBjYWxsZWQgd2hlbiB0aGUgcGFydCBjb250YWluaW5nIHRoZSBkaXJlY3RpdmUgaXMgY2xlYXJlZCBhcyBhIHJlc3VsdCBvZlxuICogcmUtcmVuZGVyaW5nLCBvciB3aGVuIHRoZSB1c2VyIGNhbGxzIGBwYXJ0LnNldENvbm5lY3RlZChmYWxzZSlgIG9uXG4gKiBhIHBhcnQgdGhhdCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBjb250YWluaW5nIHRoZSBkaXJlY3RpdmUgKGFzIGhhcHBlbnNcbiAqIHdoZW4gZS5nLiBhIExpdEVsZW1lbnQgZGlzY29ubmVjdHMgZnJvbSB0aGUgRE9NKS5cbiAqXG4gKiBJZiBgcGFydC5zZXRDb25uZWN0ZWQodHJ1ZSlgIGlzIHN1YnNlcXVlbnRseSBjYWxsZWQgb24gYVxuICogY29udGFpbmluZyBwYXJ0LCB0aGUgZGlyZWN0aXZlJ3MgYHJlY29ubmVjdGVkYCBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgcHJpb3JcbiAqIHRvIGl0cyBuZXh0IGB1cGRhdGVgL2ByZW5kZXJgIGNhbGxiYWNrcy4gV2hlbiBpbXBsZW1lbnRpbmcgYGRpc2Nvbm5lY3RlZGAsXG4gKiBgcmVjb25uZWN0ZWRgIHNob3VsZCBhbHNvIGJlIGltcGxlbWVudGVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aCByZWNvbm5lY3Rpb24uXG4gKlxuICogTm90ZSB0aGF0IHVwZGF0ZXMgbWF5IG9jY3VyIHdoaWxlIHRoZSBkaXJlY3RpdmUgaXMgZGlzY29ubmVjdGVkLiBBcyBzdWNoLFxuICogZGlyZWN0aXZlcyBzaG91bGQgZ2VuZXJhbGx5IGNoZWNrIHRoZSBgdGhpcy5pc0Nvbm5lY3RlZGAgZmxhZyBkdXJpbmdcbiAqIHJlbmRlci91cGRhdGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgaXQgaXMgc2FmZSB0byBzdWJzY3JpYmUgdG8gcmVzb3VyY2VzXG4gKiB0aGF0IG1heSBwcmV2ZW50IGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFzeW5jRGlyZWN0aXZlIGV4dGVuZHMgRGlyZWN0aXZlIHtcbiAgLy8gQXMgb3Bwb3NlZCB0byBvdGhlciBEaXNjb25uZWN0YWJsZXMsIEFzeW5jRGlyZWN0aXZlcyBhbHdheXMgZ2V0IG5vdGlmaWVkXG4gIC8vIHdoZW4gdGhlIFJvb3RQYXJ0IGNvbm5lY3Rpb24gY2hhbmdlcywgc28gdGhlIHB1YmxpYyBgaXNDb25uZWN0ZWRgXG4gIC8vIGlzIGEgbG9jYWxseSBzdG9yZWQgdmFyaWFibGUgaW5pdGlhbGl6ZWQgdmlhIGl0cyBwYXJ0J3MgZ2V0dGVyIGFuZCBzeW5jZWRcbiAgLy8gdmlhIGBfJG5vdGlmeURpcmVjdGl2ZUNvbm5lY3Rpb25DaGFuZ2VkYC4gVGhpcyBpcyBjaGVhcGVyIHRoYW4gdXNpbmdcbiAgLy8gdGhlIF8kaXNDb25uZWN0ZWQgZ2V0dGVyLCB3aGljaCBoYXMgdG8gbG9vayBiYWNrIHVwIHRoZSB0cmVlIGVhY2ggdGltZS5cbiAgLyoqXG4gICAqIFRoZSBjb25uZWN0aW9uIHN0YXRlIGZvciB0aGlzIERpcmVjdGl2ZS5cbiAgICovXG4gIGlzQ29ubmVjdGVkITogYm9vbGVhbjtcblxuICAvLyBAaW50ZXJuYWxcbiAgb3ZlcnJpZGUgXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuPzogU2V0PERpc2Nvbm5lY3RhYmxlPiA9IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHBhcnQgd2l0aCBpbnRlcm5hbCBmaWVsZHNcbiAgICogQHBhcmFtIHBhcnRcbiAgICogQHBhcmFtIHBhcmVudFxuICAgKiBAcGFyYW0gYXR0cmlidXRlSW5kZXhcbiAgICovXG4gIG92ZXJyaWRlIF8kaW5pdGlhbGl6ZShcbiAgICBwYXJ0OiBQYXJ0LFxuICAgIHBhcmVudDogRGlzY29ubmVjdGFibGUsXG4gICAgYXR0cmlidXRlSW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZFxuICApIHtcbiAgICBzdXBlci5fJGluaXRpYWxpemUocGFydCwgcGFyZW50LCBhdHRyaWJ1dGVJbmRleCk7XG4gICAgYWRkRGlzY29ubmVjdGFibGVUb1BhcmVudCh0aGlzKTtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gcGFydC5fJGlzQ29ubmVjdGVkO1xuICB9XG4gIC8vIFRoaXMgcHJvcGVydHkgbmVlZHMgdG8gcmVtYWluIHVubWluaWZpZWQuXG4gIC8qKlxuICAgKiBDYWxsZWQgZnJvbSB0aGUgY29yZSBjb2RlIHdoZW4gYSBkaXJlY3RpdmUgaXMgZ29pbmcgYXdheSBmcm9tIGEgcGFydCAoaW5cbiAgICogd2hpY2ggY2FzZSBgc2hvdWxkUmVtb3ZlRnJvbVBhcmVudGAgc2hvdWxkIGJlIHRydWUpLCBhbmQgZnJvbSB0aGVcbiAgICogYHNldENoaWxkcmVuQ29ubmVjdGVkYCBoZWxwZXIgZnVuY3Rpb24gd2hlbiByZWN1cnNpdmVseSBjaGFuZ2luZyB0aGVcbiAgICogY29ubmVjdGlvbiBzdGF0ZSBvZiBhIHRyZWUgKGluIHdoaWNoIGNhc2UgYHNob3VsZFJlbW92ZUZyb21QYXJlbnRgIHNob3VsZFxuICAgKiBiZSBmYWxzZSkuXG4gICAqXG4gICAqIEBwYXJhbSBpc0Nvbm5lY3RlZFxuICAgKiBAcGFyYW0gaXNDbGVhcmluZ0RpcmVjdGl2ZSAtIFRydWUgd2hlbiB0aGUgZGlyZWN0aXZlIGl0c2VsZiBpcyBiZWluZ1xuICAgKiAgICAgcmVtb3ZlZDsgZmFsc2Ugd2hlbiB0aGUgdHJlZSBpcyBiZWluZyBkaXNjb25uZWN0ZWRcbiAgICogQGludGVybmFsXG4gICAqL1xuICBvdmVycmlkZSBbJ18kbm90aWZ5RGlyZWN0aXZlQ29ubmVjdGlvbkNoYW5nZWQnXShcbiAgICBpc0Nvbm5lY3RlZDogYm9vbGVhbixcbiAgICBpc0NsZWFyaW5nRGlyZWN0aXZlID0gdHJ1ZVxuICApIHtcbiAgICBpZiAoaXNDb25uZWN0ZWQgIT09IHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBpc0Nvbm5lY3RlZDtcbiAgICAgIGlmIChpc0Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdGVkPy4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdGVkPy4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQ2xlYXJpbmdEaXJlY3RpdmUpIHtcbiAgICAgIG5vdGlmeUNoaWxkcmVuQ29ubmVjdGVkQ2hhbmdlZCh0aGlzLCBpc0Nvbm5lY3RlZCk7XG4gICAgICByZW1vdmVEaXNjb25uZWN0YWJsZUZyb21QYXJlbnQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBkaXJlY3RpdmUncyBQYXJ0IG91dHNpZGUgdGhlIG5vcm1hbCBgdXBkYXRlYC9gcmVuZGVyYFxuICAgKiBsaWZlY3ljbGUgb2YgYSBkaXJlY3RpdmUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgZnJvbSBhIGRpcmVjdGl2ZSdzIGB1cGRhdGVgXG4gICAqIG9yIGByZW5kZXJgLlxuICAgKlxuICAgKiBAcGFyYW0gZGlyZWN0aXZlIFRoZSBkaXJlY3RpdmUgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0XG4gICAqL1xuICBzZXRWYWx1ZSh2YWx1ZTogdW5rbm93bikge1xuICAgIGlmIChpc1NpbmdsZUV4cHJlc3Npb24odGhpcy5fX3BhcnQgYXMgdW5rbm93biBhcyBQYXJ0SW5mbykpIHtcbiAgICAgIHRoaXMuX19wYXJ0Ll8kc2V0VmFsdWUodmFsdWUsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGlzLl9fYXR0cmlidXRlSW5kZXggd2lsbCBiZSBkZWZpbmVkIGluIHRoaXMgY2FzZSwgYnV0XG4gICAgICAvLyBhc3NlcnQgaXQgaW4gZGV2IG1vZGVcbiAgICAgIGlmIChERVZfTU9ERSAmJiB0aGlzLl9fYXR0cmlidXRlSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHRoaXMuX19hdHRyaWJ1dGVJbmRleCB0byBiZSBhIG51bWJlcmApO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3VmFsdWVzID0gWy4uLih0aGlzLl9fcGFydC5fJGNvbW1pdHRlZFZhbHVlIGFzIEFycmF5PHVua25vd24+KV07XG4gICAgICBuZXdWYWx1ZXNbdGhpcy5fX2F0dHJpYnV0ZUluZGV4IV0gPSB2YWx1ZTtcbiAgICAgICh0aGlzLl9fcGFydCBhcyBBdHRyaWJ1dGVQYXJ0KS5fJHNldFZhbHVlKG5ld1ZhbHVlcywgdGhpcywgMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZXIgY2FsbGJhY2tzIGZvciBpbXBsZW1lbnRpbmcgbG9naWMgdG8gcmVsZWFzZSBhbnkgcmVzb3VyY2VzL3N1YnNjcmlwdGlvbnNcbiAgICogdGhhdCBtYXkgaGF2ZSBiZWVuIHJldGFpbmVkIGJ5IHRoaXMgZGlyZWN0aXZlLiBTaW5jZSBkaXJlY3RpdmVzIG1heSBhbHNvIGJlXG4gICAqIHJlLWNvbm5lY3RlZCwgYHJlY29ubmVjdGVkYCBzaG91bGQgYWxzbyBiZSBpbXBsZW1lbnRlZCB0byByZXN0b3JlIHRoZVxuICAgKiB3b3JraW5nIHN0YXRlIG9mIHRoZSBkaXJlY3RpdmUgcHJpb3IgdG8gdGhlIG5leHQgcmVuZGVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGRpc2Nvbm5lY3RlZCgpIHt9XG4gIHByb3RlY3RlZCByZWNvbm5lY3RlZCgpIHt9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-html/development/async-directive.js\n");

/***/ }),

/***/ "./node_modules/lit-html/development/directive-helpers.js":
/*!****************************************************************!*\
  !*** ./node_modules/lit-html/development/directive-helpers.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TemplateResultType: () => (/* binding */ TemplateResultType),\n/* harmony export */   clearPart: () => (/* binding */ clearPart),\n/* harmony export */   getCommittedValue: () => (/* binding */ getCommittedValue),\n/* harmony export */   getDirectiveClass: () => (/* binding */ getDirectiveClass),\n/* harmony export */   insertPart: () => (/* binding */ insertPart),\n/* harmony export */   isCompiledTemplateResult: () => (/* binding */ isCompiledTemplateResult),\n/* harmony export */   isDirectiveResult: () => (/* binding */ isDirectiveResult),\n/* harmony export */   isPrimitive: () => (/* binding */ isPrimitive),\n/* harmony export */   isSingleExpression: () => (/* binding */ isSingleExpression),\n/* harmony export */   isTemplateResult: () => (/* binding */ isTemplateResult),\n/* harmony export */   removePart: () => (/* binding */ removePart),\n/* harmony export */   setChildPartValue: () => (/* binding */ setChildPartValue),\n/* harmony export */   setCommittedValue: () => (/* binding */ setCommittedValue)\n/* harmony export */ });\n/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lit-html.js */ \"./node_modules/lit-html/development/lit-html.js\");\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar _a, _b;\n\nconst {\n  _ChildPart: ChildPart\n} = _lit_html_js__WEBPACK_IMPORTED_MODULE_0__._$LH;\nconst ENABLE_SHADYDOM_NOPATCH = true;\nconst wrap = ENABLE_SHADYDOM_NOPATCH && ((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) && ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.noPatch) === true ? window.ShadyDOM.wrap : node => node;\n/**\n * Tests if a value is a primitive value.\n *\n * See https://tc39.github.io/ecma262/#sec-typeof-operator\n */\nconst isPrimitive = value => value === null || typeof value != 'object' && typeof value != 'function';\nconst TemplateResultType = {\n  HTML: 1,\n  SVG: 2\n};\n/**\n * Tests if a value is a TemplateResult or a CompiledTemplateResult.\n */\nconst isTemplateResult = (value, type) => type === undefined ?\n// This property needs to remain unminified.\n(value === null || value === void 0 ? void 0 : value['_$litType$']) !== undefined : (value === null || value === void 0 ? void 0 : value['_$litType$']) === type;\n/**\n * Tests if a value is a CompiledTemplateResult.\n */\nconst isCompiledTemplateResult = value => {\n  var _a;\n  return ((_a = value === null || value === void 0 ? void 0 : value['_$litType$']) === null || _a === void 0 ? void 0 : _a.h) != null;\n};\n/**\n * Tests if a value is a DirectiveResult.\n */\nconst isDirectiveResult = value =>\n// This property needs to remain unminified.\n(value === null || value === void 0 ? void 0 : value['_$litDirective$']) !== undefined;\n/**\n * Retrieves the Directive class for a DirectiveResult\n */\nconst getDirectiveClass = value =>\n// This property needs to remain unminified.\nvalue === null || value === void 0 ? void 0 : value['_$litDirective$'];\n/**\n * Tests whether a part has only a single-expression with no strings to\n * interpolate between.\n *\n * Only AttributePart and PropertyPart can have multiple expressions.\n * Multi-expression parts have a `strings` property and single-expression\n * parts do not.\n */\nconst isSingleExpression = part => part.strings === undefined;\nconst createMarker = () => document.createComment('');\n/**\n * Inserts a ChildPart into the given container ChildPart's DOM, either at the\n * end of the container ChildPart, or before the optional `refPart`.\n *\n * This does not add the part to the containerPart's committed value. That must\n * be done by callers.\n *\n * @param containerPart Part within which to add the new ChildPart\n * @param refPart Part before which to add the new ChildPart; when omitted the\n *     part added to the end of the `containerPart`\n * @param part Part to insert, or undefined to create a new part\n */\nconst insertPart = (containerPart, refPart, part) => {\n  var _a;\n  const container = wrap(containerPart._$startNode).parentNode;\n  const refNode = refPart === undefined ? containerPart._$endNode : refPart._$startNode;\n  if (part === undefined) {\n    const startNode = wrap(container).insertBefore(createMarker(), refNode);\n    const endNode = wrap(container).insertBefore(createMarker(), refNode);\n    part = new ChildPart(startNode, endNode, containerPart, containerPart.options);\n  } else {\n    const endNode = wrap(part._$endNode).nextSibling;\n    const oldParent = part._$parent;\n    const parentChanged = oldParent !== containerPart;\n    if (parentChanged) {\n      (_a = part._$reparentDisconnectables) === null || _a === void 0 ? void 0 : _a.call(part, containerPart);\n      // Note that although `_$reparentDisconnectables` updates the part's\n      // `_$parent` reference after unlinking from its current parent, that\n      // method only exists if Disconnectables are present, so we need to\n      // unconditionally set it here\n      part._$parent = containerPart;\n      // Since the _$isConnected getter is somewhat costly, only\n      // read it once we know the subtree has directives that need\n      // to be notified\n      let newConnectionState;\n      if (part._$notifyConnectionChanged !== undefined && (newConnectionState = containerPart._$isConnected) !== oldParent._$isConnected) {\n        part._$notifyConnectionChanged(newConnectionState);\n      }\n    }\n    if (endNode !== refNode || parentChanged) {\n      let start = part._$startNode;\n      while (start !== endNode) {\n        const n = wrap(start).nextSibling;\n        wrap(container).insertBefore(start, refNode);\n        start = n;\n      }\n    }\n  }\n  return part;\n};\n/**\n * Sets the value of a Part.\n *\n * Note that this should only be used to set/update the value of user-created\n * parts (i.e. those created using `insertPart`); it should not be used\n * by directives to set the value of the directive's container part. Directives\n * should return a value from `update`/`render` to update their part state.\n *\n * For directives that require setting their part value asynchronously, they\n * should extend `AsyncDirective` and call `this.setValue()`.\n *\n * @param part Part to set\n * @param value Value to set\n * @param index For `AttributePart`s, the index to set\n * @param directiveParent Used internally; should not be set by user\n */\nconst setChildPartValue = (part, value, directiveParent = part) => {\n  part._$setValue(value, directiveParent);\n  return part;\n};\n// A sentinel value that can never appear as a part value except when set by\n// live(). Used to force a dirty-check to fail and cause a re-render.\nconst RESET_VALUE = {};\n/**\n * Sets the committed value of a ChildPart directly without triggering the\n * commit stage of the part.\n *\n * This is useful in cases where a directive needs to update the part such\n * that the next update detects a value change or not. When value is omitted,\n * the next update will be guaranteed to be detected as a change.\n *\n * @param part\n * @param value\n */\nconst setCommittedValue = (part, value = RESET_VALUE) => part._$committedValue = value;\n/**\n * Returns the committed value of a ChildPart.\n *\n * The committed value is used for change detection and efficient updates of\n * the part. It can differ from the value set by the template or directive in\n * cases where the template value is transformed before being committed.\n *\n * - `TemplateResult`s are committed as a `TemplateInstance`\n * - Iterables are committed as `Array<ChildPart>`\n * - All other types are committed as the template value or value returned or\n *   set by a directive.\n *\n * @param part\n */\nconst getCommittedValue = part => part._$committedValue;\n/**\n * Removes a ChildPart from the DOM, including any of its content.\n *\n * @param part The Part to remove\n */\nconst removePart = part => {\n  var _a;\n  (_a = part._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(part, false, true);\n  let start = part._$startNode;\n  const end = wrap(part._$endNode).nextSibling;\n  while (start !== end) {\n    const n = wrap(start).nextSibling;\n    wrap(start).remove();\n    start = n;\n  }\n};\nconst clearPart = part => {\n  part._$clear();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvZGV2ZWxvcG1lbnQvZGlyZWN0aXZlLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0FBTUE7QUFlQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBT0E7Ozs7O0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQWFBOzs7QUFHQTtBQUtBO0FBQ0E7QUFHQTs7O0FBR0E7O0FBR0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBUUE7QUFHQTtBQUVBOzs7Ozs7Ozs7Ozs7QUFZQTs7QUFLQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUdBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBRUE7Ozs7O0FBS0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvZGlyZWN0aXZlLWhlbHBlcnMudHM/Yjc4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuaW1wb3J0IHtcbiAgXyRMSCxcbiAgUGFydCxcbiAgRGlyZWN0aXZlUGFyZW50LFxuICBUZW1wbGF0ZVJlc3VsdCxcbiAgQ29tcGlsZWRUZW1wbGF0ZVJlc3VsdCxcbn0gZnJvbSAnLi9saXQtaHRtbC5qcyc7XG5pbXBvcnQge1xuICBEaXJlY3RpdmVSZXN1bHQsXG4gIERpcmVjdGl2ZUNsYXNzLFxuICBQYXJ0SW5mbyxcbiAgQXR0cmlidXRlUGFydEluZm8sXG59IGZyb20gJy4vZGlyZWN0aXZlLmpzJztcbnR5cGUgUHJpbWl0aXZlID0gbnVsbCB8IHVuZGVmaW5lZCB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmcgfCBzeW1ib2wgfCBiaWdpbnQ7XG5cbmNvbnN0IHtfQ2hpbGRQYXJ0OiBDaGlsZFBhcnR9ID0gXyRMSDtcblxudHlwZSBDaGlsZFBhcnQgPSBJbnN0YW5jZVR5cGU8dHlwZW9mIENoaWxkUGFydD47XG5cbmNvbnN0IEVOQUJMRV9TSEFEWURPTV9OT1BBVENIID0gdHJ1ZTtcblxuY29uc3Qgd3JhcCA9XG4gIEVOQUJMRV9TSEFEWURPTV9OT1BBVENIICYmXG4gIHdpbmRvdy5TaGFkeURPTT8uaW5Vc2UgJiZcbiAgd2luZG93LlNoYWR5RE9NPy5ub1BhdGNoID09PSB0cnVlXG4gICAgPyB3aW5kb3cuU2hhZHlET00hLndyYXBcbiAgICA6IChub2RlOiBOb2RlKSA9PiBub2RlO1xuXG4vKipcbiAqIFRlc3RzIGlmIGEgdmFsdWUgaXMgYSBwcmltaXRpdmUgdmFsdWUuXG4gKlxuICogU2VlIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVvZi1vcGVyYXRvclxuICovXG5leHBvcnQgY29uc3QgaXNQcmltaXRpdmUgPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBQcmltaXRpdmUgPT5cbiAgdmFsdWUgPT09IG51bGwgfHwgKHR5cGVvZiB2YWx1ZSAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT0gJ2Z1bmN0aW9uJyk7XG5cbmV4cG9ydCBjb25zdCBUZW1wbGF0ZVJlc3VsdFR5cGUgPSB7XG4gIEhUTUw6IDEsXG4gIFNWRzogMixcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIFRlbXBsYXRlUmVzdWx0VHlwZSA9XG4gICh0eXBlb2YgVGVtcGxhdGVSZXN1bHRUeXBlKVtrZXlvZiB0eXBlb2YgVGVtcGxhdGVSZXN1bHRUeXBlXTtcblxudHlwZSBJc1RlbXBsYXRlUmVzdWx0ID0ge1xuICAodmFsOiB1bmtub3duKTogdmFsIGlzIFRlbXBsYXRlUmVzdWx0IHwgQ29tcGlsZWRUZW1wbGF0ZVJlc3VsdDtcbiAgPFQgZXh0ZW5kcyBUZW1wbGF0ZVJlc3VsdFR5cGU+KFxuICAgIHZhbDogdW5rbm93bixcbiAgICB0eXBlOiBUXG4gICk6IHZhbCBpcyBUZW1wbGF0ZVJlc3VsdDxUPjtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgYSB2YWx1ZSBpcyBhIFRlbXBsYXRlUmVzdWx0IG9yIGEgQ29tcGlsZWRUZW1wbGF0ZVJlc3VsdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVGVtcGxhdGVSZXN1bHQ6IElzVGVtcGxhdGVSZXN1bHQgPSAoXG4gIHZhbHVlOiB1bmtub3duLFxuICB0eXBlPzogVGVtcGxhdGVSZXN1bHRUeXBlXG4pOiB2YWx1ZSBpcyBUZW1wbGF0ZVJlc3VsdCA9PlxuICB0eXBlID09PSB1bmRlZmluZWRcbiAgICA/IC8vIFRoaXMgcHJvcGVydHkgbmVlZHMgdG8gcmVtYWluIHVubWluaWZpZWQuXG4gICAgICAodmFsdWUgYXMgVGVtcGxhdGVSZXN1bHQpPy5bJ18kbGl0VHlwZSQnXSAhPT0gdW5kZWZpbmVkXG4gICAgOiAodmFsdWUgYXMgVGVtcGxhdGVSZXN1bHQpPy5bJ18kbGl0VHlwZSQnXSA9PT0gdHlwZTtcblxuLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgQ29tcGlsZWRUZW1wbGF0ZVJlc3VsdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQ29tcGlsZWRUZW1wbGF0ZVJlc3VsdCA9IChcbiAgdmFsdWU6IHVua25vd25cbik6IHZhbHVlIGlzIENvbXBpbGVkVGVtcGxhdGVSZXN1bHQgPT4ge1xuICByZXR1cm4gKHZhbHVlIGFzIENvbXBpbGVkVGVtcGxhdGVSZXN1bHQpPy5bJ18kbGl0VHlwZSQnXT8uaCAhPSBudWxsO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiBhIHZhbHVlIGlzIGEgRGlyZWN0aXZlUmVzdWx0LlxuICovXG5leHBvcnQgY29uc3QgaXNEaXJlY3RpdmVSZXN1bHQgPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBEaXJlY3RpdmVSZXN1bHQgPT5cbiAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgKHZhbHVlIGFzIERpcmVjdGl2ZVJlc3VsdCk/LlsnXyRsaXREaXJlY3RpdmUkJ10gIT09IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIERpcmVjdGl2ZSBjbGFzcyBmb3IgYSBEaXJlY3RpdmVSZXN1bHRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldERpcmVjdGl2ZUNsYXNzID0gKHZhbHVlOiB1bmtub3duKTogRGlyZWN0aXZlQ2xhc3MgfCB1bmRlZmluZWQgPT5cbiAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgKHZhbHVlIGFzIERpcmVjdGl2ZVJlc3VsdCk/LlsnXyRsaXREaXJlY3RpdmUkJ107XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBhIHBhcnQgaGFzIG9ubHkgYSBzaW5nbGUtZXhwcmVzc2lvbiB3aXRoIG5vIHN0cmluZ3MgdG9cbiAqIGludGVycG9sYXRlIGJldHdlZW4uXG4gKlxuICogT25seSBBdHRyaWJ1dGVQYXJ0IGFuZCBQcm9wZXJ0eVBhcnQgY2FuIGhhdmUgbXVsdGlwbGUgZXhwcmVzc2lvbnMuXG4gKiBNdWx0aS1leHByZXNzaW9uIHBhcnRzIGhhdmUgYSBgc3RyaW5nc2AgcHJvcGVydHkgYW5kIHNpbmdsZS1leHByZXNzaW9uXG4gKiBwYXJ0cyBkbyBub3QuXG4gKi9cbmV4cG9ydCBjb25zdCBpc1NpbmdsZUV4cHJlc3Npb24gPSAocGFydDogUGFydEluZm8pID0+XG4gIChwYXJ0IGFzIEF0dHJpYnV0ZVBhcnRJbmZvKS5zdHJpbmdzID09PSB1bmRlZmluZWQ7XG5cbmNvbnN0IGNyZWF0ZU1hcmtlciA9ICgpID0+IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpO1xuXG4vKipcbiAqIEluc2VydHMgYSBDaGlsZFBhcnQgaW50byB0aGUgZ2l2ZW4gY29udGFpbmVyIENoaWxkUGFydCdzIERPTSwgZWl0aGVyIGF0IHRoZVxuICogZW5kIG9mIHRoZSBjb250YWluZXIgQ2hpbGRQYXJ0LCBvciBiZWZvcmUgdGhlIG9wdGlvbmFsIGByZWZQYXJ0YC5cbiAqXG4gKiBUaGlzIGRvZXMgbm90IGFkZCB0aGUgcGFydCB0byB0aGUgY29udGFpbmVyUGFydCdzIGNvbW1pdHRlZCB2YWx1ZS4gVGhhdCBtdXN0XG4gKiBiZSBkb25lIGJ5IGNhbGxlcnMuXG4gKlxuICogQHBhcmFtIGNvbnRhaW5lclBhcnQgUGFydCB3aXRoaW4gd2hpY2ggdG8gYWRkIHRoZSBuZXcgQ2hpbGRQYXJ0XG4gKiBAcGFyYW0gcmVmUGFydCBQYXJ0IGJlZm9yZSB3aGljaCB0byBhZGQgdGhlIG5ldyBDaGlsZFBhcnQ7IHdoZW4gb21pdHRlZCB0aGVcbiAqICAgICBwYXJ0IGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGBjb250YWluZXJQYXJ0YFxuICogQHBhcmFtIHBhcnQgUGFydCB0byBpbnNlcnQsIG9yIHVuZGVmaW5lZCB0byBjcmVhdGUgYSBuZXcgcGFydFxuICovXG5leHBvcnQgY29uc3QgaW5zZXJ0UGFydCA9IChcbiAgY29udGFpbmVyUGFydDogQ2hpbGRQYXJ0LFxuICByZWZQYXJ0PzogQ2hpbGRQYXJ0LFxuICBwYXJ0PzogQ2hpbGRQYXJ0XG4pOiBDaGlsZFBhcnQgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSB3cmFwKGNvbnRhaW5lclBhcnQuXyRzdGFydE5vZGUpLnBhcmVudE5vZGUhO1xuXG4gIGNvbnN0IHJlZk5vZGUgPVxuICAgIHJlZlBhcnQgPT09IHVuZGVmaW5lZCA/IGNvbnRhaW5lclBhcnQuXyRlbmROb2RlIDogcmVmUGFydC5fJHN0YXJ0Tm9kZTtcblxuICBpZiAocGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgc3RhcnROb2RlID0gd3JhcChjb250YWluZXIpLmluc2VydEJlZm9yZShjcmVhdGVNYXJrZXIoKSwgcmVmTm9kZSk7XG4gICAgY29uc3QgZW5kTm9kZSA9IHdyYXAoY29udGFpbmVyKS5pbnNlcnRCZWZvcmUoY3JlYXRlTWFya2VyKCksIHJlZk5vZGUpO1xuICAgIHBhcnQgPSBuZXcgQ2hpbGRQYXJ0KFxuICAgICAgc3RhcnROb2RlLFxuICAgICAgZW5kTm9kZSxcbiAgICAgIGNvbnRhaW5lclBhcnQsXG4gICAgICBjb250YWluZXJQYXJ0Lm9wdGlvbnNcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGVuZE5vZGUgPSB3cmFwKHBhcnQuXyRlbmROb2RlISkubmV4dFNpYmxpbmc7XG4gICAgY29uc3Qgb2xkUGFyZW50ID0gcGFydC5fJHBhcmVudDtcbiAgICBjb25zdCBwYXJlbnRDaGFuZ2VkID0gb2xkUGFyZW50ICE9PSBjb250YWluZXJQYXJ0O1xuICAgIGlmIChwYXJlbnRDaGFuZ2VkKSB7XG4gICAgICBwYXJ0Ll8kcmVwYXJlbnREaXNjb25uZWN0YWJsZXM/Lihjb250YWluZXJQYXJ0KTtcbiAgICAgIC8vIE5vdGUgdGhhdCBhbHRob3VnaCBgXyRyZXBhcmVudERpc2Nvbm5lY3RhYmxlc2AgdXBkYXRlcyB0aGUgcGFydCdzXG4gICAgICAvLyBgXyRwYXJlbnRgIHJlZmVyZW5jZSBhZnRlciB1bmxpbmtpbmcgZnJvbSBpdHMgY3VycmVudCBwYXJlbnQsIHRoYXRcbiAgICAgIC8vIG1ldGhvZCBvbmx5IGV4aXN0cyBpZiBEaXNjb25uZWN0YWJsZXMgYXJlIHByZXNlbnQsIHNvIHdlIG5lZWQgdG9cbiAgICAgIC8vIHVuY29uZGl0aW9uYWxseSBzZXQgaXQgaGVyZVxuICAgICAgcGFydC5fJHBhcmVudCA9IGNvbnRhaW5lclBhcnQ7XG4gICAgICAvLyBTaW5jZSB0aGUgXyRpc0Nvbm5lY3RlZCBnZXR0ZXIgaXMgc29tZXdoYXQgY29zdGx5LCBvbmx5XG4gICAgICAvLyByZWFkIGl0IG9uY2Ugd2Uga25vdyB0aGUgc3VidHJlZSBoYXMgZGlyZWN0aXZlcyB0aGF0IG5lZWRcbiAgICAgIC8vIHRvIGJlIG5vdGlmaWVkXG4gICAgICBsZXQgbmV3Q29ubmVjdGlvblN0YXRlO1xuICAgICAgaWYgKFxuICAgICAgICBwYXJ0Ll8kbm90aWZ5Q29ubmVjdGlvbkNoYW5nZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAobmV3Q29ubmVjdGlvblN0YXRlID0gY29udGFpbmVyUGFydC5fJGlzQ29ubmVjdGVkKSAhPT1cbiAgICAgICAgICBvbGRQYXJlbnQhLl8kaXNDb25uZWN0ZWRcbiAgICAgICkge1xuICAgICAgICBwYXJ0Ll8kbm90aWZ5Q29ubmVjdGlvbkNoYW5nZWQobmV3Q29ubmVjdGlvblN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZE5vZGUgIT09IHJlZk5vZGUgfHwgcGFyZW50Q2hhbmdlZCkge1xuICAgICAgbGV0IHN0YXJ0OiBOb2RlIHwgbnVsbCA9IHBhcnQuXyRzdGFydE5vZGU7XG4gICAgICB3aGlsZSAoc3RhcnQgIT09IGVuZE5vZGUpIHtcbiAgICAgICAgY29uc3QgbjogTm9kZSB8IG51bGwgPSB3cmFwKHN0YXJ0ISkubmV4dFNpYmxpbmc7XG4gICAgICAgIHdyYXAoY29udGFpbmVyKS5pbnNlcnRCZWZvcmUoc3RhcnQhLCByZWZOb2RlKTtcbiAgICAgICAgc3RhcnQgPSBuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0O1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIFBhcnQuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byBzZXQvdXBkYXRlIHRoZSB2YWx1ZSBvZiB1c2VyLWNyZWF0ZWRcbiAqIHBhcnRzIChpLmUuIHRob3NlIGNyZWF0ZWQgdXNpbmcgYGluc2VydFBhcnRgKTsgaXQgc2hvdWxkIG5vdCBiZSB1c2VkXG4gKiBieSBkaXJlY3RpdmVzIHRvIHNldCB0aGUgdmFsdWUgb2YgdGhlIGRpcmVjdGl2ZSdzIGNvbnRhaW5lciBwYXJ0LiBEaXJlY3RpdmVzXG4gKiBzaG91bGQgcmV0dXJuIGEgdmFsdWUgZnJvbSBgdXBkYXRlYC9gcmVuZGVyYCB0byB1cGRhdGUgdGhlaXIgcGFydCBzdGF0ZS5cbiAqXG4gKiBGb3IgZGlyZWN0aXZlcyB0aGF0IHJlcXVpcmUgc2V0dGluZyB0aGVpciBwYXJ0IHZhbHVlIGFzeW5jaHJvbm91c2x5LCB0aGV5XG4gKiBzaG91bGQgZXh0ZW5kIGBBc3luY0RpcmVjdGl2ZWAgYW5kIGNhbGwgYHRoaXMuc2V0VmFsdWUoKWAuXG4gKlxuICogQHBhcmFtIHBhcnQgUGFydCB0byBzZXRcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAqIEBwYXJhbSBpbmRleCBGb3IgYEF0dHJpYnV0ZVBhcnRgcywgdGhlIGluZGV4IHRvIHNldFxuICogQHBhcmFtIGRpcmVjdGl2ZVBhcmVudCBVc2VkIGludGVybmFsbHk7IHNob3VsZCBub3QgYmUgc2V0IGJ5IHVzZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHNldENoaWxkUGFydFZhbHVlID0gPFQgZXh0ZW5kcyBDaGlsZFBhcnQ+KFxuICBwYXJ0OiBULFxuICB2YWx1ZTogdW5rbm93bixcbiAgZGlyZWN0aXZlUGFyZW50OiBEaXJlY3RpdmVQYXJlbnQgPSBwYXJ0XG4pOiBUID0+IHtcbiAgcGFydC5fJHNldFZhbHVlKHZhbHVlLCBkaXJlY3RpdmVQYXJlbnQpO1xuICByZXR1cm4gcGFydDtcbn07XG5cbi8vIEEgc2VudGluZWwgdmFsdWUgdGhhdCBjYW4gbmV2ZXIgYXBwZWFyIGFzIGEgcGFydCB2YWx1ZSBleGNlcHQgd2hlbiBzZXQgYnlcbi8vIGxpdmUoKS4gVXNlZCB0byBmb3JjZSBhIGRpcnR5LWNoZWNrIHRvIGZhaWwgYW5kIGNhdXNlIGEgcmUtcmVuZGVyLlxuY29uc3QgUkVTRVRfVkFMVUUgPSB7fTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21taXR0ZWQgdmFsdWUgb2YgYSBDaGlsZFBhcnQgZGlyZWN0bHkgd2l0aG91dCB0cmlnZ2VyaW5nIHRoZVxuICogY29tbWl0IHN0YWdlIG9mIHRoZSBwYXJ0LlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VzIHdoZXJlIGEgZGlyZWN0aXZlIG5lZWRzIHRvIHVwZGF0ZSB0aGUgcGFydCBzdWNoXG4gKiB0aGF0IHRoZSBuZXh0IHVwZGF0ZSBkZXRlY3RzIGEgdmFsdWUgY2hhbmdlIG9yIG5vdC4gV2hlbiB2YWx1ZSBpcyBvbWl0dGVkLFxuICogdGhlIG5leHQgdXBkYXRlIHdpbGwgYmUgZ3VhcmFudGVlZCB0byBiZSBkZXRlY3RlZCBhcyBhIGNoYW5nZS5cbiAqXG4gKiBAcGFyYW0gcGFydFxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRDb21taXR0ZWRWYWx1ZSA9IChwYXJ0OiBQYXJ0LCB2YWx1ZTogdW5rbm93biA9IFJFU0VUX1ZBTFVFKSA9PlxuICAocGFydC5fJGNvbW1pdHRlZFZhbHVlID0gdmFsdWUpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbW1pdHRlZCB2YWx1ZSBvZiBhIENoaWxkUGFydC5cbiAqXG4gKiBUaGUgY29tbWl0dGVkIHZhbHVlIGlzIHVzZWQgZm9yIGNoYW5nZSBkZXRlY3Rpb24gYW5kIGVmZmljaWVudCB1cGRhdGVzIG9mXG4gKiB0aGUgcGFydC4gSXQgY2FuIGRpZmZlciBmcm9tIHRoZSB2YWx1ZSBzZXQgYnkgdGhlIHRlbXBsYXRlIG9yIGRpcmVjdGl2ZSBpblxuICogY2FzZXMgd2hlcmUgdGhlIHRlbXBsYXRlIHZhbHVlIGlzIHRyYW5zZm9ybWVkIGJlZm9yZSBiZWluZyBjb21taXR0ZWQuXG4gKlxuICogLSBgVGVtcGxhdGVSZXN1bHRgcyBhcmUgY29tbWl0dGVkIGFzIGEgYFRlbXBsYXRlSW5zdGFuY2VgXG4gKiAtIEl0ZXJhYmxlcyBhcmUgY29tbWl0dGVkIGFzIGBBcnJheTxDaGlsZFBhcnQ+YFxuICogLSBBbGwgb3RoZXIgdHlwZXMgYXJlIGNvbW1pdHRlZCBhcyB0aGUgdGVtcGxhdGUgdmFsdWUgb3IgdmFsdWUgcmV0dXJuZWQgb3JcbiAqICAgc2V0IGJ5IGEgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSBwYXJ0XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDb21taXR0ZWRWYWx1ZSA9IChwYXJ0OiBDaGlsZFBhcnQpID0+IHBhcnQuXyRjb21taXR0ZWRWYWx1ZTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgQ2hpbGRQYXJ0IGZyb20gdGhlIERPTSwgaW5jbHVkaW5nIGFueSBvZiBpdHMgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gcGFydCBUaGUgUGFydCB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZVBhcnQgPSAocGFydDogQ2hpbGRQYXJ0KSA9PiB7XG4gIHBhcnQuXyRub3RpZnlDb25uZWN0aW9uQ2hhbmdlZD8uKGZhbHNlLCB0cnVlKTtcbiAgbGV0IHN0YXJ0OiBDaGlsZE5vZGUgfCBudWxsID0gcGFydC5fJHN0YXJ0Tm9kZTtcbiAgY29uc3QgZW5kOiBDaGlsZE5vZGUgfCBudWxsID0gd3JhcChwYXJ0Ll8kZW5kTm9kZSEpLm5leHRTaWJsaW5nO1xuICB3aGlsZSAoc3RhcnQgIT09IGVuZCkge1xuICAgIGNvbnN0IG46IENoaWxkTm9kZSB8IG51bGwgPSB3cmFwKHN0YXJ0ISkubmV4dFNpYmxpbmc7XG4gICAgKHdyYXAoc3RhcnQhKSBhcyBDaGlsZE5vZGUpLnJlbW92ZSgpO1xuICAgIHN0YXJ0ID0gbjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNsZWFyUGFydCA9IChwYXJ0OiBDaGlsZFBhcnQpID0+IHtcbiAgcGFydC5fJGNsZWFyKCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lit-html/development/directive-helpers.js\n");

/***/ }),

/***/ "./node_modules/lit/async-directive.js":
/*!*********************************************!*\
  !*** ./node_modules/lit/async-directive.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncDirective: () => (/* reexport safe */ lit_html_async_directive_js__WEBPACK_IMPORTED_MODULE_0__.AsyncDirective),
/* harmony export */   Directive: () => (/* reexport safe */ lit_html_async_directive_js__WEBPACK_IMPORTED_MODULE_0__.Directive),
/* harmony export */   PartType: () => (/* reexport safe */ lit_html_async_directive_js__WEBPACK_IMPORTED_MODULE_0__.PartType),
/* harmony export */   directive: () => (/* reexport safe */ lit_html_async_directive_js__WEBPACK_IMPORTED_MODULE_0__.directive)
/* harmony export */ });
/* harmony import */ var lit_html_async_directive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/async-directive.js */ "./node_modules/lit-html/development/async-directive.js");


/***/ }),

/***/ "./node_modules/lit/decorators/property.js":
/*!*************************************************!*\
  !*** ./node_modules/lit/decorators/property.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   property: () => (/* reexport safe */ _lit_reactive_element_decorators_property_js__WEBPACK_IMPORTED_MODULE_0__.property)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element_decorators_property_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element/decorators/property.js */ "./node_modules/@lit/reactive-element/development/decorators/property.js");


/***/ }),

/***/ "./node_modules/lit/directive.js":
/*!***************************************!*\
  !*** ./node_modules/lit/directive.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Directive: () => (/* reexport safe */ lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__.Directive),
/* harmony export */   PartType: () => (/* reexport safe */ lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__.PartType),
/* harmony export */   directive: () => (/* reexport safe */ lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__.directive)
/* harmony export */ });
/* harmony import */ var lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directive.js */ "./node_modules/lit-html/development/directive.js");


/***/ })

};
