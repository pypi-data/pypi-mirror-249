/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
export const id = "vendors-node_modules_node-vibrant_dist_vibrant_js";
export const ids = ["vendors-node_modules_node-vibrant_dist_vibrant_js"];
export const modules = {

/***/ "./node_modules/node-vibrant/dist/vibrant.js":
/*!***************************************************!*\
  !*** ./node_modules/node-vibrant/dist/vibrant.js ***!
  \***************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true) module.exports = factory();else {}\n})(window, function () {\n  return /******/function (modules) {\n    // webpackBootstrap\n    /******/ // The module cache\n    /******/\n    var installedModules = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __nested_webpack_require_559__(moduleId) {\n      /******/\n      /******/ // Check if module is in cache\n      /******/if (installedModules[moduleId]) {\n        /******/return installedModules[moduleId].exports;\n        /******/\n      }\n      /******/ // Create a new module (and put it into the cache)\n      /******/\n      var module = installedModules[moduleId] = {\n        /******/i: moduleId,\n        /******/l: false,\n        /******/exports: {}\n        /******/\n      };\n      /******/\n      /******/ // Execute the module function\n      /******/\n      modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_559__);\n      /******/\n      /******/ // Flag the module as loaded\n      /******/\n      module.l = true;\n      /******/\n      /******/ // Return the exports of the module\n      /******/\n      return module.exports;\n      /******/\n    }\n    /******/\n    /******/\n    /******/ // expose the modules object (__webpack_modules__)\n    /******/\n    __nested_webpack_require_559__.m = modules;\n    /******/\n    /******/ // expose the module cache\n    /******/\n    __nested_webpack_require_559__.c = installedModules;\n    /******/\n    /******/ // define getter function for harmony exports\n    /******/\n    __nested_webpack_require_559__.d = function (exports, name, getter) {\n      /******/if (!__nested_webpack_require_559__.o(exports, name)) {\n        /******/Object.defineProperty(exports, name, {\n          enumerable: true,\n          get: getter\n        });\n        /******/\n      }\n      /******/\n    };\n    /******/\n    /******/ // define __esModule on exports\n    /******/\n    __nested_webpack_require_559__.r = function (exports) {\n      /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n        /******/Object.defineProperty(exports, Symbol.toStringTag, {\n          value: 'Module'\n        });\n        /******/\n      }\n      /******/\n      Object.defineProperty(exports, '__esModule', {\n        value: true\n      });\n      /******/\n    };\n    /******/\n    /******/ // create a fake namespace object\n    /******/ // mode & 1: value is a module id, require it\n    /******/ // mode & 2: merge all properties of value into the ns\n    /******/ // mode & 4: return value when already ns object\n    /******/ // mode & 8|1: behave like require\n    /******/\n    __nested_webpack_require_559__.t = function (value, mode) {\n      /******/if (mode & 1) value = __nested_webpack_require_559__(value);\n      /******/\n      if (mode & 8) return value;\n      /******/\n      if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n      /******/\n      var ns = Object.create(null);\n      /******/\n      __nested_webpack_require_559__.r(ns);\n      /******/\n      Object.defineProperty(ns, 'default', {\n        enumerable: true,\n        value: value\n      });\n      /******/\n      if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_559__.d(ns, key, function (key) {\n        return value[key];\n      }.bind(null, key));\n      /******/\n      return ns;\n      /******/\n    };\n    /******/\n    /******/ // getDefaultExport function for compatibility with non-harmony modules\n    /******/\n    __nested_webpack_require_559__.n = function (module) {\n      /******/var getter = module && module.__esModule ? /******/function getDefault() {\n        return module['default'];\n      } : /******/function getModuleExports() {\n        return module;\n      };\n      /******/\n      __nested_webpack_require_559__.d(getter, 'a', getter);\n      /******/\n      return getter;\n      /******/\n    };\n    /******/\n    /******/ // Object.prototype.hasOwnProperty.call\n    /******/\n    __nested_webpack_require_559__.o = function (object, property) {\n      return Object.prototype.hasOwnProperty.call(object, property);\n    };\n    /******/\n    /******/ // __webpack_public_path__\n    /******/\n    __nested_webpack_require_559__.p = \"\";\n    /******/\n    /******/\n    /******/ // Load entry module and return exports\n    /******/\n    return __nested_webpack_require_559__(__nested_webpack_require_559__.s = 10);\n    /******/\n  }\n  /************************************************************************/\n  /******/([( /* 0 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.assignDeep = exports.mapValues = void 0;\n    function mapValues(o, mapper) {\n      var result = {};\n      for (var key in o) {\n        if (o.hasOwnProperty(key)) {\n          var v = o[key];\n          result[key] = mapper(v);\n        }\n      }\n      return result;\n    }\n    exports.mapValues = mapValues;\n    /**\n     * Overwrite values or properties on objects and lists recursively.\n     * A shallow copy will be created for each array value.\n     */\n    function assignDeep(target) {\n      var sources = [];\n      for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n      }\n      sources.forEach(function (s) {\n        if (!s) return;\n        for (var key in s) {\n          if (s.hasOwnProperty(key)) {\n            var v = s[key];\n            if (Array.isArray(v)) {\n              // Shallow copy\n              target[key] = v.slice(0);\n            } else if (typeof v === 'object') {\n              if (!target[key]) target[key] = {};\n              assignDeep(target[key], v);\n            } else {\n              target[key] = v;\n            }\n          }\n        }\n      });\n      return target;\n    }\n    exports.assignDeep = assignDeep;\n\n    /***/\n  }), ( /* 1 */\n  /***/function (module, exports, __nested_webpack_require_6005__) {\n    \"use strict\";\n\n    var __importDefault = this && this.__importDefault || function (mod) {\n      return mod && mod.__esModule ? mod : {\n        \"default\": mod\n      };\n    };\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var options_1 = __nested_webpack_require_6005__(7);\n    var builder_1 = __importDefault(__nested_webpack_require_6005__(8));\n    var utils_1 = __nested_webpack_require_6005__(0);\n    var Vibrant = /** @class */function () {\n      function Vibrant(_src, opts) {\n        this._src = _src;\n        this.opts = utils_1.assignDeep({}, Vibrant.DefaultOpts, opts);\n      }\n      Vibrant.use = function (pipeline) {\n        this._pipeline = pipeline;\n      };\n      Vibrant.from = function (src) {\n        return new builder_1.default(src);\n      };\n      Object.defineProperty(Vibrant.prototype, \"result\", {\n        get: function () {\n          return this._result;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Vibrant.prototype._process = function (image, opts) {\n        var quantizer = this.opts.quantizer;\n        image.scaleDown(this.opts);\n        var processOpts = options_1.buildProcessOptions(this.opts, opts);\n        return Vibrant._pipeline.process(image.getImageData(), processOpts);\n      };\n      Vibrant.prototype.palette = function () {\n        return this.swatches();\n      };\n      Vibrant.prototype.swatches = function () {\n        throw new Error('Method deprecated. Use `Vibrant.result.palettes[name]` instead');\n      };\n      Vibrant.prototype.getPalette = function () {\n        var _this = this;\n        var arg0 = arguments[0];\n        var arg1 = arguments[1];\n        var name = typeof arg0 === 'string' ? arg0 : 'default';\n        var cb = typeof arg0 === 'string' ? arg1 : arg0;\n        var image = new this.opts.ImageClass();\n        return image.load(this._src).then(function (image) {\n          return _this._process(image, {\n            generators: [name]\n          });\n        }).then(function (result) {\n          _this._result = result;\n          return result.palettes[name];\n        }).then(function (res) {\n          image.remove();\n          if (cb) {\n            cb(undefined, res);\n          }\n          return res;\n        }).catch(function (err) {\n          image.remove();\n          if (cb) {\n            cb(err);\n          }\n          return Promise.reject(err);\n        });\n      };\n      Vibrant.prototype.getPalettes = function () {\n        var _this = this;\n        var arg0 = arguments[0];\n        var arg1 = arguments[1];\n        var names = Array.isArray(arg0) ? arg0 : ['*'];\n        var cb = Array.isArray(arg0) ? arg1 : arg0;\n        var image = new this.opts.ImageClass();\n        return image.load(this._src).then(function (image) {\n          return _this._process(image, {\n            generators: names\n          });\n        }).then(function (result) {\n          _this._result = result;\n          return result.palettes;\n        }).then(function (res) {\n          image.remove();\n          if (cb) {\n            cb(undefined, res);\n          }\n          return res;\n        }).catch(function (err) {\n          image.remove();\n          if (cb) {\n            cb(err);\n          }\n          return Promise.reject(err);\n        });\n      };\n      Vibrant.DefaultOpts = {\n        colorCount: 64,\n        quality: 5,\n        filters: []\n      };\n      return Vibrant;\n    }();\n    exports.default = Vibrant;\n\n    /***/\n  }), ( /* 2 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.applyFilters = exports.ImageBase = void 0;\n    var ImageBase = /** @class */function () {\n      function ImageBase() {}\n      ImageBase.prototype.scaleDown = function (opts) {\n        var width = this.getWidth();\n        var height = this.getHeight();\n        var ratio = 1;\n        if (opts.maxDimension > 0) {\n          var maxSide = Math.max(width, height);\n          if (maxSide > opts.maxDimension) ratio = opts.maxDimension / maxSide;\n        } else {\n          ratio = 1 / opts.quality;\n        }\n        if (ratio < 1) this.resize(width * ratio, height * ratio, ratio);\n      };\n      return ImageBase;\n    }();\n    exports.ImageBase = ImageBase;\n    function applyFilters(imageData, filters) {\n      if (filters.length > 0) {\n        var pixels = imageData.data;\n        var n = pixels.length / 4;\n        var offset = void 0;\n        var r = void 0;\n        var g = void 0;\n        var b = void 0;\n        var a = void 0;\n        for (var i = 0; i < n; i++) {\n          offset = i * 4;\n          r = pixels[offset + 0];\n          g = pixels[offset + 1];\n          b = pixels[offset + 2];\n          a = pixels[offset + 3];\n          // Mark ignored color\n          for (var j = 0; j < filters.length; j++) {\n            if (!filters[j](r, g, b, a)) {\n              pixels[offset + 3] = 0;\n              break;\n            }\n          }\n        }\n      }\n      return imageData;\n    }\n    exports.applyFilters = applyFilters;\n\n    /***/\n  }), ( /* 3 */\n  /***/function (module, exports, __nested_webpack_require_11129__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.Swatch = void 0;\n    var converter_1 = __nested_webpack_require_11129__(4);\n    var Swatch = /** @class */function () {\n      function Swatch(rgb, population) {\n        this._rgb = rgb;\n        this._population = population;\n      }\n      Swatch.applyFilters = function (colors, filters) {\n        return filters.length > 0 ? colors.filter(function (_a) {\n          var r = _a.r,\n            g = _a.g,\n            b = _a.b;\n          for (var j = 0; j < filters.length; j++) {\n            if (!filters[j](r, g, b, 255)) return false;\n          }\n          return true;\n        }) : colors;\n      };\n      /**\n       * Make a value copy of a swatch based on a previous one. Returns a new Swatch instance\n       * @param {Swatch} swatch\n       */\n      Swatch.clone = function (swatch) {\n        return new Swatch(swatch._rgb, swatch._population);\n      };\n      Object.defineProperty(Swatch.prototype, \"r\", {\n        /**\n         * The red value in the RGB value\n         */\n        get: function () {\n          return this._rgb[0];\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(Swatch.prototype, \"g\", {\n        /**\n         * The green value in the RGB value\n         */\n        get: function () {\n          return this._rgb[1];\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(Swatch.prototype, \"b\", {\n        /**\n         * The blue value in the RGB value\n         */\n        get: function () {\n          return this._rgb[2];\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(Swatch.prototype, \"rgb\", {\n        /**\n         * The color value as a rgb value\n         */\n        get: function () {\n          return this._rgb;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(Swatch.prototype, \"hsl\", {\n        /**\n         * The color value as a hsl value\n         */\n        get: function () {\n          if (!this._hsl) {\n            var _a = this._rgb,\n              r = _a[0],\n              g = _a[1],\n              b = _a[2];\n            this._hsl = converter_1.rgbToHsl(r, g, b);\n          }\n          return this._hsl;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(Swatch.prototype, \"hex\", {\n        /**\n         * The color value as a hex string\n         */\n        get: function () {\n          if (!this._hex) {\n            var _a = this._rgb,\n              r = _a[0],\n              g = _a[1],\n              b = _a[2];\n            this._hex = converter_1.rgbToHex(r, g, b);\n          }\n          return this._hex;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(Swatch.prototype, \"population\", {\n        get: function () {\n          return this._population;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      /**\n       * Get the JSON object for the swatch\n       */\n      Swatch.prototype.toJSON = function () {\n        return {\n          rgb: this.rgb,\n          population: this.population\n        };\n      };\n      /**\n       * Get the color value as a rgb value\n       * @deprecated Use property instead\n       */\n      // TODO: deprecate internally, use property instead\n      Swatch.prototype.getRgb = function () {\n        return this._rgb;\n      };\n      /**\n       * Get the color value as a hsl value\n       * @deprecated Use property instead\n       */\n      // TODO: deprecate internally, use property instead\n      Swatch.prototype.getHsl = function () {\n        return this.hsl;\n      };\n      /**\n       * @deprecated Use property instead\n       */\n      // TODO: deprecate internally, use property instead\n      Swatch.prototype.getPopulation = function () {\n        return this._population;\n      };\n      /**\n       * Get the color value as a hex string\n       * @deprecated Use property instead\n       */\n      // TODO: deprecate internally, use property instead\n      Swatch.prototype.getHex = function () {\n        return this.hex;\n      };\n      Swatch.prototype.getYiq = function () {\n        if (!this._yiq) {\n          var rgb = this._rgb;\n          this._yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n        }\n        return this._yiq;\n      };\n      Object.defineProperty(Swatch.prototype, \"titleTextColor\", {\n        get: function () {\n          if (this._titleTextColor) {\n            this._titleTextColor = this.getYiq() < 200 ? '#fff' : '#000';\n          }\n          return this._titleTextColor;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(Swatch.prototype, \"bodyTextColor\", {\n        get: function () {\n          if (this._bodyTextColor) {\n            this._bodyTextColor = this.getYiq() < 150 ? '#fff' : '#000';\n          }\n          return this._bodyTextColor;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Swatch.prototype.getTitleTextColor = function () {\n        return this.titleTextColor;\n      };\n      Swatch.prototype.getBodyTextColor = function () {\n        return this.bodyTextColor;\n      };\n      return Swatch;\n    }();\n    exports.Swatch = Swatch;\n\n    /***/\n  }), ( /* 4 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.getColorDiffStatus = exports.hexDiff = exports.rgbDiff = exports.deltaE94 = exports.rgbToCIELab = exports.xyzToCIELab = exports.rgbToXyz = exports.hslToRgb = exports.rgbToHsl = exports.rgbToHex = exports.hexToRgb = exports.DELTAE94_DIFF_STATUS = void 0;\n    exports.DELTAE94_DIFF_STATUS = {\n      NA: 0,\n      PERFECT: 1,\n      CLOSE: 2,\n      GOOD: 10,\n      SIMILAR: 50\n    };\n    /**\n     * Converts hex string to RGB\n     * @param hex - The hex value you with to get the RGB value of\n     * @returns an array in the order of `red, green, blue` numerical values\n     */\n    function hexToRgb(hex) {\n      var m = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      if (!m) throw new RangeError(\"'\" + hex + \"' is not a valid hex color\");\n      return [m[1], m[2], m[3]].map(function (s) {\n        return parseInt(s, 16);\n      });\n    }\n    exports.hexToRgb = hexToRgb;\n    /**\n     * Given values for an RGB color convert to and return a valid HEX string\n     * @param r - Red value in RGB\n     * @param g - Green value in RGB\n     * @param b - Blue value in RGB\n     * @returns a valid hex string with pre-pending pound sign\n     */\n    function rgbToHex(r, g, b) {\n      return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);\n    }\n    exports.rgbToHex = rgbToHex;\n    /**\n     * Given values for an RGB color convert to and return a valid HSL value\n     * @param r - Red value in RGB\n     * @param g - Green value in RGB\n     * @param b - Blue value in RGB\n     * @returns an array in the order of `hue, saturation, light` numerical values\n     */\n    function rgbToHsl(r, g, b) {\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      var max = Math.max(r, g, b);\n      var min = Math.min(r, g, b);\n      var h = 0;\n      var s = 0;\n      var l = (max + min) / 2;\n      if (max !== min) {\n        var d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch (max) {\n          case r:\n            h = (g - b) / d + (g < b ? 6 : 0);\n            break;\n          case g:\n            h = (b - r) / d + 2;\n            break;\n          case b:\n            h = (r - g) / d + 4;\n            break;\n        }\n        h /= 6;\n      }\n      return [h, s, l];\n    }\n    exports.rgbToHsl = rgbToHsl;\n    function hslToRgb(h, s, l) {\n      var r;\n      var g;\n      var b;\n      function hue2rgb(p, q, t) {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n      }\n      if (s === 0) {\n        r = g = b = l;\n      } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n      }\n      return [r * 255, g * 255, b * 255];\n    }\n    exports.hslToRgb = hslToRgb;\n    function rgbToXyz(r, g, b) {\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      r = r > 0.04045 ? Math.pow((r + 0.005) / 1.055, 2.4) : r / 12.92;\n      g = g > 0.04045 ? Math.pow((g + 0.005) / 1.055, 2.4) : g / 12.92;\n      b = b > 0.04045 ? Math.pow((b + 0.005) / 1.055, 2.4) : b / 12.92;\n      r *= 100;\n      g *= 100;\n      b *= 100;\n      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n      return [x, y, z];\n    }\n    exports.rgbToXyz = rgbToXyz;\n    function xyzToCIELab(x, y, z) {\n      var REF_X = 95.047;\n      var REF_Y = 100;\n      var REF_Z = 108.883;\n      x /= REF_X;\n      y /= REF_Y;\n      z /= REF_Z;\n      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n      var L = 116 * y - 16;\n      var a = 500 * (x - y);\n      var b = 200 * (y - z);\n      return [L, a, b];\n    }\n    exports.xyzToCIELab = xyzToCIELab;\n    function rgbToCIELab(r, g, b) {\n      var _a = rgbToXyz(r, g, b),\n        x = _a[0],\n        y = _a[1],\n        z = _a[2];\n      return xyzToCIELab(x, y, z);\n    }\n    exports.rgbToCIELab = rgbToCIELab;\n    function deltaE94(lab1, lab2) {\n      var WEIGHT_L = 1;\n      var WEIGHT_C = 1;\n      var WEIGHT_H = 1;\n      var L1 = lab1[0],\n        a1 = lab1[1],\n        b1 = lab1[2];\n      var L2 = lab2[0],\n        a2 = lab2[1],\n        b2 = lab2[2];\n      var dL = L1 - L2;\n      var da = a1 - a2;\n      var db = b1 - b2;\n      var xC1 = Math.sqrt(a1 * a1 + b1 * b1);\n      var xC2 = Math.sqrt(a2 * a2 + b2 * b2);\n      var xDL = L2 - L1;\n      var xDC = xC2 - xC1;\n      var xDE = Math.sqrt(dL * dL + da * da + db * db);\n      var xDH = Math.sqrt(xDE) > Math.sqrt(Math.abs(xDL)) + Math.sqrt(Math.abs(xDC)) ? Math.sqrt(xDE * xDE - xDL * xDL - xDC * xDC) : 0;\n      var xSC = 1 + 0.045 * xC1;\n      var xSH = 1 + 0.015 * xC1;\n      xDL /= WEIGHT_L;\n      xDC /= WEIGHT_C * xSC;\n      xDH /= WEIGHT_H * xSH;\n      return Math.sqrt(xDL * xDL + xDC * xDC + xDH * xDH);\n    }\n    exports.deltaE94 = deltaE94;\n    function rgbDiff(rgb1, rgb2) {\n      var lab1 = rgbToCIELab.apply(undefined, rgb1);\n      var lab2 = rgbToCIELab.apply(undefined, rgb2);\n      return deltaE94(lab1, lab2);\n    }\n    exports.rgbDiff = rgbDiff;\n    function hexDiff(hex1, hex2) {\n      var rgb1 = hexToRgb(hex1);\n      var rgb2 = hexToRgb(hex2);\n      return rgbDiff(rgb1, rgb2);\n    }\n    exports.hexDiff = hexDiff;\n    function getColorDiffStatus(d) {\n      if (d < exports.DELTAE94_DIFF_STATUS.NA) {\n        return 'N/A';\n      }\n      // Not perceptible by human eyes\n      if (d <= exports.DELTAE94_DIFF_STATUS.PERFECT) {\n        return 'Perfect';\n      }\n      // Perceptible through close observation\n      if (d <= exports.DELTAE94_DIFF_STATUS.CLOSE) {\n        return 'Close';\n      }\n      // Perceptible at a glance\n      if (d <= exports.DELTAE94_DIFF_STATUS.GOOD) {\n        return 'Good';\n      }\n      // Colors are more similar than opposite\n      if (d < exports.DELTAE94_DIFF_STATUS.SIMILAR) {\n        return 'Similar';\n      }\n      return 'Wrong';\n    }\n    exports.getColorDiffStatus = getColorDiffStatus;\n\n    /***/\n  }), ( /* 5 */\n  /***/function (module, exports, __nested_webpack_require_22985__) {\n    \"use strict\";\n\n    var __importDefault = this && this.__importDefault || function (mod) {\n      return mod && mod.__esModule ? mod : {\n        \"default\": mod\n      };\n    };\n    var config_1 = __importDefault(__nested_webpack_require_22985__(6));\n    var image_browser_1 = __importDefault(__nested_webpack_require_22985__(9));\n    config_1.default.DefaultOpts.ImageClass = image_browser_1.default;\n    module.exports = config_1.default;\n\n    /***/\n  }), ( /* 6 */\n  /***/function (module, exports, __nested_webpack_require_23484__) {\n    \"use strict\";\n\n    var __importDefault = this && this.__importDefault || function (mod) {\n      return mod && mod.__esModule ? mod : {\n        \"default\": mod\n      };\n    };\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var core_1 = __importDefault(__nested_webpack_require_23484__(1));\n    core_1.default.DefaultOpts.quantizer = 'mmcq';\n    core_1.default.DefaultOpts.generators = ['default'];\n    core_1.default.DefaultOpts.filters = ['default'];\n    exports.default = core_1.default;\n\n    /***/\n  }), ( /* 7 */\n  /***/function (module, exports, __nested_webpack_require_24081__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.buildProcessOptions = void 0;\n    var utils_1 = __nested_webpack_require_24081__(0);\n    function buildProcessOptions(opts, override) {\n      var colorCount = opts.colorCount,\n        quantizer = opts.quantizer,\n        generators = opts.generators,\n        filters = opts.filters;\n      // Merge with common quantizer options\n      var commonQuantizerOpts = {\n        colorCount: colorCount\n      };\n      var q = typeof quantizer === 'string' ? {\n        name: quantizer,\n        options: {}\n      } : quantizer;\n      q.options = utils_1.assignDeep({}, commonQuantizerOpts, q.options);\n      return utils_1.assignDeep({}, {\n        quantizer: q,\n        generators: generators,\n        filters: filters\n      }, override);\n    }\n    exports.buildProcessOptions = buildProcessOptions;\n\n    /***/\n  }), ( /* 8 */\n  /***/function (module, exports, __nested_webpack_require_25047__) {\n    \"use strict\";\n\n    var __importDefault = this && this.__importDefault || function (mod) {\n      return mod && mod.__esModule ? mod : {\n        \"default\": mod\n      };\n    };\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var _1 = __importDefault(__nested_webpack_require_25047__(1));\n    var utils_1 = __nested_webpack_require_25047__(0);\n    var Builder = /** @class */function () {\n      function Builder(src, opts) {\n        if (opts === void 0) {\n          opts = {};\n        }\n        this._src = src;\n        this._opts = utils_1.assignDeep({}, _1.default.DefaultOpts, opts);\n      }\n      Builder.prototype.maxColorCount = function (n) {\n        this._opts.colorCount = n;\n        return this;\n      };\n      Builder.prototype.maxDimension = function (d) {\n        this._opts.maxDimension = d;\n        return this;\n      };\n      Builder.prototype.addFilter = function (name) {\n        if (!this._opts.filters) {\n          this._opts.filters = [name];\n        } else {\n          this._opts.filters.push(name);\n        }\n        return this;\n      };\n      Builder.prototype.removeFilter = function (name) {\n        if (this._opts.filters) {\n          var i = this._opts.filters.indexOf(name);\n          if (i > 0) this._opts.filters.splice(i);\n        }\n        return this;\n      };\n      Builder.prototype.clearFilters = function () {\n        this._opts.filters = [];\n        return this;\n      };\n      Builder.prototype.quality = function (q) {\n        this._opts.quality = q;\n        return this;\n      };\n      Builder.prototype.useImageClass = function (imageClass) {\n        this._opts.ImageClass = imageClass;\n        return this;\n      };\n      Builder.prototype.useGenerator = function (generator, options) {\n        if (!this._opts.generators) this._opts.generators = [];\n        this._opts.generators.push(options ? {\n          name: generator,\n          options: options\n        } : generator);\n        return this;\n      };\n      Builder.prototype.useQuantizer = function (quantizer, options) {\n        this._opts.quantizer = options ? {\n          name: quantizer,\n          options: options\n        } : quantizer;\n        return this;\n      };\n      Builder.prototype.build = function () {\n        return new _1.default(this._src, this._opts);\n      };\n      Builder.prototype.getPalette = function (cb) {\n        return this.build().getPalette(cb);\n      };\n      Builder.prototype.getSwatches = function (cb) {\n        return this.build().getPalette(cb);\n      };\n      return Builder;\n    }();\n    exports.default = Builder;\n\n    /***/\n  }), ( /* 9 */\n  /***/function (module, exports, __nested_webpack_require_27694__) {\n    \"use strict\";\n\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n      };\n      return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var image_1 = __nested_webpack_require_27694__(2);\n    function isRelativeUrl(url) {\n      var u = new URL(url, location.href);\n      return u.protocol === location.protocol && u.host === location.host && u.port === location.port;\n    }\n    function isSameOrigin(a, b) {\n      var ua = new URL(a);\n      var ub = new URL(b);\n      // https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\n      return ua.protocol === ub.protocol && ua.hostname === ub.hostname && ua.port === ub.port;\n    }\n    var BrowserImage = /** @class */function (_super) {\n      __extends(BrowserImage, _super);\n      function BrowserImage() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n      BrowserImage.prototype._initCanvas = function () {\n        var img = this.image;\n        var canvas = this._canvas = document.createElement('canvas');\n        var context = canvas.getContext('2d');\n        if (!context) throw new ReferenceError('Failed to create canvas context');\n        this._context = context;\n        canvas.className = '@vibrant/canvas';\n        canvas.style.display = 'none';\n        this._width = canvas.width = img.width;\n        this._height = canvas.height = img.height;\n        context.drawImage(img, 0, 0);\n        document.body.appendChild(canvas);\n      };\n      BrowserImage.prototype.load = function (image) {\n        var _this = this;\n        var img;\n        var src;\n        if (typeof image === 'string') {\n          img = document.createElement('img');\n          src = image;\n          if (!isRelativeUrl(src) && !isSameOrigin(window.location.href, src)) {\n            img.crossOrigin = 'anonymous';\n          }\n          img.src = src;\n        } else if (image instanceof HTMLImageElement) {\n          img = image;\n          src = image.src;\n        } else {\n          return Promise.reject(new Error(\"Cannot load buffer as an image in browser\"));\n        }\n        this.image = img;\n        return new Promise(function (resolve, reject) {\n          var onImageLoad = function () {\n            _this._initCanvas();\n            resolve(_this);\n          };\n          if (img.complete) {\n            // Already loaded\n            onImageLoad();\n          } else {\n            img.onload = onImageLoad;\n            img.onerror = function (e) {\n              return reject(new Error(\"Fail to load image: \" + src));\n            };\n          }\n        });\n      };\n      BrowserImage.prototype.clear = function () {\n        this._context.clearRect(0, 0, this._width, this._height);\n      };\n      BrowserImage.prototype.update = function (imageData) {\n        this._context.putImageData(imageData, 0, 0);\n      };\n      BrowserImage.prototype.getWidth = function () {\n        return this._width;\n      };\n      BrowserImage.prototype.getHeight = function () {\n        return this._height;\n      };\n      BrowserImage.prototype.resize = function (targetWidth, targetHeight, ratio) {\n        var _a = this,\n          canvas = _a._canvas,\n          context = _a._context,\n          img = _a.image;\n        this._width = canvas.width = targetWidth;\n        this._height = canvas.height = targetHeight;\n        context.scale(ratio, ratio);\n        context.drawImage(img, 0, 0);\n      };\n      BrowserImage.prototype.getPixelCount = function () {\n        return this._width * this._height;\n      };\n      BrowserImage.prototype.getImageData = function () {\n        return this._context.getImageData(0, 0, this._width, this._height);\n      };\n      BrowserImage.prototype.remove = function () {\n        if (this._canvas && this._canvas.parentNode) {\n          this._canvas.parentNode.removeChild(this._canvas);\n        }\n      };\n      return BrowserImage;\n    }(image_1.ImageBase);\n    exports.default = BrowserImage;\n\n    /***/\n  }), ( /* 10 */\n  /***/function (module, exports, __nested_webpack_require_32278__) {\n    \"use strict\";\n\n    var __importDefault = this && this.__importDefault || function (mod) {\n      return mod && mod.__esModule ? mod : {\n        \"default\": mod\n      };\n    };\n    var Vibrant = __nested_webpack_require_32278__(5);\n    var pipeline_1 = __importDefault(__nested_webpack_require_32278__(11));\n    Vibrant.use(pipeline_1.default);\n    module.exports = Vibrant;\n\n    /***/\n  }), ( /* 11 */\n  /***/function (module, exports, __nested_webpack_require_32713__) {\n    \"use strict\";\n\n    var __importDefault = this && this.__importDefault || function (mod) {\n      return mod && mod.__esModule ? mod : {\n        \"default\": mod\n      };\n    };\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var quantizer_mmcq_1 = __importDefault(__nested_webpack_require_32713__(12));\n    var generator_default_1 = __importDefault(__nested_webpack_require_32713__(16));\n    var pipeline_1 = __nested_webpack_require_32713__(17);\n    var pipeline = new pipeline_1.BasicPipeline().filter.register('default', function (r, g, b, a) {\n      return a >= 125 && !(r > 250 && g > 250 && b > 250);\n    }).quantizer.register('mmcq', quantizer_mmcq_1.default).generator.register('default', generator_default_1.default);\n    exports.default = pipeline;\n\n    /***/\n  }), ( /* 12 */\n  /***/function (module, exports, __nested_webpack_require_33552__) {\n    \"use strict\";\n\n    var __importDefault = this && this.__importDefault || function (mod) {\n      return mod && mod.__esModule ? mod : {\n        \"default\": mod\n      };\n    };\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var color_1 = __nested_webpack_require_33552__(3);\n    var vbox_1 = __importDefault(__nested_webpack_require_33552__(13));\n    var pqueue_1 = __importDefault(__nested_webpack_require_33552__(15));\n    var fractByPopulations = 0.75;\n    function _splitBoxes(pq, target) {\n      var lastSize = pq.size();\n      while (pq.size() < target) {\n        var vbox = pq.pop();\n        if (vbox && vbox.count() > 0) {\n          var _a = vbox.split(),\n            vbox1 = _a[0],\n            vbox2 = _a[1];\n          pq.push(vbox1);\n          if (vbox2 && vbox2.count() > 0) pq.push(vbox2);\n          // No more new boxes, converged\n          if (pq.size() === lastSize) {\n            break;\n          } else {\n            lastSize = pq.size();\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    var MMCQ = function (pixels, opts) {\n      if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n        throw new Error('Wrong MMCQ parameters');\n      }\n      var vbox = vbox_1.default.build(pixels);\n      var colorCount = vbox.histogram.colorCount;\n      var pq = new pqueue_1.default(function (a, b) {\n        return a.count() - b.count();\n      });\n      pq.push(vbox);\n      // first set of colors, sorted by population\n      _splitBoxes(pq, fractByPopulations * opts.colorCount);\n      // Re-order\n      var pq2 = new pqueue_1.default(function (a, b) {\n        return a.count() * a.volume() - b.count() * b.volume();\n      });\n      pq2.contents = pq.contents;\n      // next set - generate the median cuts using the (npix * vol) sorting.\n      _splitBoxes(pq2, opts.colorCount - pq2.size());\n      // calculate the actual colors\n      return generateSwatches(pq2);\n    };\n    function generateSwatches(pq) {\n      var swatches = [];\n      while (pq.size()) {\n        var v = pq.pop();\n        var color = v.avg();\n        var r = color[0],\n          g = color[1],\n          b = color[2];\n        swatches.push(new color_1.Swatch(color, v.count()));\n      }\n      return swatches;\n    }\n    exports.default = MMCQ;\n\n    /***/\n  }), ( /* 13 */\n  /***/function (module, exports, __nested_webpack_require_35905__) {\n    \"use strict\";\n\n    var __importDefault = this && this.__importDefault || function (mod) {\n      return mod && mod.__esModule ? mod : {\n        \"default\": mod\n      };\n    };\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var histogram_1 = __importDefault(__nested_webpack_require_35905__(14));\n    var SIGBITS = 5;\n    var RSHIFT = 8 - SIGBITS;\n    var VBox = /** @class */function () {\n      function VBox(r1, r2, g1, g2, b1, b2, histogram) {\n        this.histogram = histogram;\n        this._volume = -1;\n        this._count = -1;\n        // NOTE: dimension will be mutated by split operation.\n        //       It must be specified explicitly, not from histogram\n        this.dimension = {\n          r1: r1,\n          r2: r2,\n          g1: g1,\n          g2: g2,\n          b1: b1,\n          b2: b2\n        };\n      }\n      VBox.build = function (pixels) {\n        var h = new histogram_1.default(pixels, {\n          sigBits: SIGBITS\n        });\n        var rmin = h.rmin,\n          rmax = h.rmax,\n          gmin = h.gmin,\n          gmax = h.gmax,\n          bmin = h.bmin,\n          bmax = h.bmax;\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, h);\n      };\n      VBox.prototype.invalidate = function () {\n        this._volume = this._count = -1;\n        this._avg = null;\n      };\n      VBox.prototype.volume = function () {\n        if (this._volume < 0) {\n          var _a = this.dimension,\n            r1 = _a.r1,\n            r2 = _a.r2,\n            g1 = _a.g1,\n            g2 = _a.g2,\n            b1 = _a.b1,\n            b2 = _a.b2;\n          this._volume = (r2 - r1 + 1) * (g2 - g1 + 1) * (b2 - b1 + 1);\n        }\n        return this._volume;\n      };\n      VBox.prototype.count = function () {\n        if (this._count < 0) {\n          var _a = this.histogram,\n            hist = _a.hist,\n            getColorIndex = _a.getColorIndex;\n          var _b = this.dimension,\n            r1 = _b.r1,\n            r2 = _b.r2,\n            g1 = _b.g1,\n            g2 = _b.g2,\n            b1 = _b.b1,\n            b2 = _b.b2;\n          var c = 0;\n          for (var r = r1; r <= r2; r++) {\n            for (var g = g1; g <= g2; g++) {\n              for (var b = b1; b <= b2; b++) {\n                var index = getColorIndex(r, g, b);\n                c += hist[index];\n              }\n            }\n          }\n          this._count = c;\n        }\n        return this._count;\n      };\n      VBox.prototype.clone = function () {\n        var histogram = this.histogram;\n        var _a = this.dimension,\n          r1 = _a.r1,\n          r2 = _a.r2,\n          g1 = _a.g1,\n          g2 = _a.g2,\n          b1 = _a.b1,\n          b2 = _a.b2;\n        return new VBox(r1, r2, g1, g2, b1, b2, histogram);\n      };\n      VBox.prototype.avg = function () {\n        if (!this._avg) {\n          var _a = this.histogram,\n            hist = _a.hist,\n            getColorIndex = _a.getColorIndex;\n          var _b = this.dimension,\n            r1 = _b.r1,\n            r2 = _b.r2,\n            g1 = _b.g1,\n            g2 = _b.g2,\n            b1 = _b.b1,\n            b2 = _b.b2;\n          var ntot = 0;\n          var mult = 1 << 8 - SIGBITS;\n          var rsum = void 0;\n          var gsum = void 0;\n          var bsum = void 0;\n          rsum = gsum = bsum = 0;\n          for (var r = r1; r <= r2; r++) {\n            for (var g = g1; g <= g2; g++) {\n              for (var b = b1; b <= b2; b++) {\n                var index = getColorIndex(r, g, b);\n                var h = hist[index];\n                ntot += h;\n                rsum += h * (r + 0.5) * mult;\n                gsum += h * (g + 0.5) * mult;\n                bsum += h * (b + 0.5) * mult;\n              }\n            }\n          }\n          if (ntot) {\n            this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n          } else {\n            this._avg = [~~(mult * (r1 + r2 + 1) / 2), ~~(mult * (g1 + g2 + 1) / 2), ~~(mult * (b1 + b2 + 1) / 2)];\n          }\n        }\n        return this._avg;\n      };\n      VBox.prototype.contains = function (rgb) {\n        var r = rgb[0],\n          g = rgb[1],\n          b = rgb[2];\n        var _a = this.dimension,\n          r1 = _a.r1,\n          r2 = _a.r2,\n          g1 = _a.g1,\n          g2 = _a.g2,\n          b1 = _a.b1,\n          b2 = _a.b2;\n        r >>= RSHIFT;\n        g >>= RSHIFT;\n        b >>= RSHIFT;\n        return r >= r1 && r <= r2 && g >= g1 && g <= g2 && b >= b1 && b <= b2;\n      };\n      VBox.prototype.split = function () {\n        var _a = this.histogram,\n          hist = _a.hist,\n          getColorIndex = _a.getColorIndex;\n        var _b = this.dimension,\n          r1 = _b.r1,\n          r2 = _b.r2,\n          g1 = _b.g1,\n          g2 = _b.g2,\n          b1 = _b.b1,\n          b2 = _b.b2;\n        var count = this.count();\n        if (!count) return [];\n        if (count === 1) return [this.clone()];\n        var rw = r2 - r1 + 1;\n        var gw = g2 - g1 + 1;\n        var bw = b2 - b1 + 1;\n        var maxw = Math.max(rw, gw, bw);\n        var accSum = null;\n        var sum;\n        var total;\n        sum = total = 0;\n        var maxd = null;\n        if (maxw === rw) {\n          maxd = 'r';\n          accSum = new Uint32Array(r2 + 1);\n          for (var r = r1; r <= r2; r++) {\n            sum = 0;\n            for (var g = g1; g <= g2; g++) {\n              for (var b = b1; b <= b2; b++) {\n                var index = getColorIndex(r, g, b);\n                sum += hist[index];\n              }\n            }\n            total += sum;\n            accSum[r] = total;\n          }\n        } else if (maxw === gw) {\n          maxd = 'g';\n          accSum = new Uint32Array(g2 + 1);\n          for (var g = g1; g <= g2; g++) {\n            sum = 0;\n            for (var r = r1; r <= r2; r++) {\n              for (var b = b1; b <= b2; b++) {\n                var index = getColorIndex(r, g, b);\n                sum += hist[index];\n              }\n            }\n            total += sum;\n            accSum[g] = total;\n          }\n        } else {\n          maxd = 'b';\n          accSum = new Uint32Array(b2 + 1);\n          for (var b = b1; b <= b2; b++) {\n            sum = 0;\n            for (var r = r1; r <= r2; r++) {\n              for (var g = g1; g <= g2; g++) {\n                var index = getColorIndex(r, g, b);\n                sum += hist[index];\n              }\n            }\n            total += sum;\n            accSum[b] = total;\n          }\n        }\n        var splitPoint = -1;\n        var reverseSum = new Uint32Array(accSum.length);\n        for (var i = 0; i < accSum.length; i++) {\n          var d = accSum[i];\n          if (splitPoint < 0 && d > total / 2) splitPoint = i;\n          reverseSum[i] = total - d;\n        }\n        var vbox = this;\n        function doCut(d) {\n          var dim1 = d + '1';\n          var dim2 = d + '2';\n          var d1 = vbox.dimension[dim1];\n          var d2 = vbox.dimension[dim2];\n          var vbox1 = vbox.clone();\n          var vbox2 = vbox.clone();\n          var left = splitPoint - d1;\n          var right = d2 - splitPoint;\n          if (left <= right) {\n            d2 = Math.min(d2 - 1, ~~(splitPoint + right / 2));\n            d2 = Math.max(0, d2);\n          } else {\n            d2 = Math.max(d1, ~~(splitPoint - 1 - left / 2));\n            d2 = Math.min(vbox.dimension[dim2], d2);\n          }\n          while (!accSum[d2]) d2++;\n          var c2 = reverseSum[d2];\n          while (!c2 && accSum[d2 - 1]) c2 = reverseSum[--d2];\n          vbox1.dimension[dim2] = d2;\n          vbox2.dimension[dim1] = d2 + 1;\n          return [vbox1, vbox2];\n        }\n        return doCut(maxd);\n      };\n      return VBox;\n    }();\n    exports.default = VBox;\n\n    /***/\n  }), ( /* 14 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var Histogram = /** @class */function () {\n      function Histogram(pixels, opts) {\n        this.pixels = pixels;\n        this.opts = opts;\n        var sigBits = opts.sigBits;\n        var getColorIndex = function (r, g, b) {\n          return (r << 2 * sigBits) + (g << sigBits) + b;\n        };\n        this.getColorIndex = getColorIndex;\n        var rshift = 8 - sigBits;\n        var hn = 1 << 3 * sigBits;\n        var hist = new Uint32Array(hn);\n        var rmax;\n        var rmin;\n        var gmax;\n        var gmin;\n        var bmax;\n        var bmin;\n        var r;\n        var g;\n        var b;\n        var a;\n        rmax = gmax = bmax = 0;\n        rmin = gmin = bmin = Number.MAX_VALUE;\n        var n = pixels.length / 4;\n        var i = 0;\n        while (i < n) {\n          var offset = i * 4;\n          i++;\n          r = pixels[offset + 0];\n          g = pixels[offset + 1];\n          b = pixels[offset + 2];\n          a = pixels[offset + 3];\n          // Ignored pixels' alpha is marked as 0 in filtering stage\n          if (a === 0) continue;\n          r = r >> rshift;\n          g = g >> rshift;\n          b = b >> rshift;\n          var index = getColorIndex(r, g, b);\n          hist[index] += 1;\n          if (r > rmax) rmax = r;\n          if (r < rmin) rmin = r;\n          if (g > gmax) gmax = g;\n          if (g < gmin) gmin = g;\n          if (b > bmax) bmax = b;\n          if (b < bmin) bmin = b;\n        }\n        this._colorCount = hist.reduce(function (total, c) {\n          return c > 0 ? total + 1 : total;\n        }, 0);\n        this.hist = hist;\n        this.rmax = rmax;\n        this.rmin = rmin;\n        this.gmax = gmax;\n        this.gmin = gmin;\n        this.bmax = bmax;\n        this.bmin = bmin;\n      }\n      Object.defineProperty(Histogram.prototype, \"colorCount\", {\n        get: function () {\n          return this._colorCount;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      return Histogram;\n    }();\n    exports.default = Histogram;\n\n    /***/\n  }), ( /* 15 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var PQueue = /** @class */function () {\n      function PQueue(comparator) {\n        this._comparator = comparator;\n        this.contents = [];\n        this._sorted = false;\n      }\n      PQueue.prototype._sort = function () {\n        if (!this._sorted) {\n          this.contents.sort(this._comparator);\n          this._sorted = true;\n        }\n      };\n      PQueue.prototype.push = function (item) {\n        this.contents.push(item);\n        this._sorted = false;\n      };\n      PQueue.prototype.peek = function (index) {\n        this._sort();\n        index = typeof index === 'number' ? index : this.contents.length - 1;\n        return this.contents[index];\n      };\n      PQueue.prototype.pop = function () {\n        this._sort();\n        return this.contents.pop();\n      };\n      PQueue.prototype.size = function () {\n        return this.contents.length;\n      };\n      PQueue.prototype.map = function (mapper) {\n        this._sort();\n        return this.contents.map(mapper);\n      };\n      return PQueue;\n    }();\n    exports.default = PQueue;\n\n    /***/\n  }), ( /* 16 */\n  /***/function (module, exports, __nested_webpack_require_47068__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var color_1 = __nested_webpack_require_47068__(3);\n    var converter_1 = __nested_webpack_require_47068__(4);\n    var DefaultOpts = {\n      targetDarkLuma: 0.26,\n      maxDarkLuma: 0.45,\n      minLightLuma: 0.55,\n      targetLightLuma: 0.74,\n      minNormalLuma: 0.3,\n      targetNormalLuma: 0.5,\n      maxNormalLuma: 0.7,\n      targetMutesSaturation: 0.3,\n      maxMutesSaturation: 0.4,\n      targetVibrantSaturation: 1.0,\n      minVibrantSaturation: 0.35,\n      weightSaturation: 3,\n      weightLuma: 6.5,\n      weightPopulation: 0.5\n    };\n    function _findMaxPopulation(swatches) {\n      var p = 0;\n      swatches.forEach(function (s) {\n        p = Math.max(p, s.population);\n      });\n      return p;\n    }\n    function _isAlreadySelected(palette, s) {\n      return palette.Vibrant === s || palette.DarkVibrant === s || palette.LightVibrant === s || palette.Muted === s || palette.DarkMuted === s || palette.LightMuted === s;\n    }\n    function _createComparisonValue(saturation, targetSaturation, luma, targetLuma, population, maxPopulation, opts) {\n      function weightedMean() {\n        var values = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          values[_i] = arguments[_i];\n        }\n        var sum = 0;\n        var weightSum = 0;\n        for (var i = 0; i < values.length; i += 2) {\n          var value = values[i];\n          var weight = values[i + 1];\n          sum += value * weight;\n          weightSum += weight;\n        }\n        return sum / weightSum;\n      }\n      function invertDiff(value, targetValue) {\n        return 1 - Math.abs(value - targetValue);\n      }\n      return weightedMean(invertDiff(saturation, targetSaturation), opts.weightSaturation, invertDiff(luma, targetLuma), opts.weightLuma, population / maxPopulation, opts.weightPopulation);\n    }\n    function _findColorVariation(palette, swatches, maxPopulation, targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation, opts) {\n      var max = null;\n      var maxValue = 0;\n      swatches.forEach(function (swatch) {\n        var _a = swatch.hsl,\n          s = _a[1],\n          l = _a[2];\n        if (s >= minSaturation && s <= maxSaturation && l >= minLuma && l <= maxLuma && !_isAlreadySelected(palette, swatch)) {\n          var value = _createComparisonValue(s, targetSaturation, l, targetLuma, swatch.population, maxPopulation, opts);\n          if (max === null || value > maxValue) {\n            max = swatch;\n            maxValue = value;\n          }\n        }\n      });\n      return max;\n    }\n    function _generateVariationColors(swatches, maxPopulation, opts) {\n      var palette = {\n        Vibrant: null,\n        DarkVibrant: null,\n        LightVibrant: null,\n        Muted: null,\n        DarkMuted: null,\n        LightMuted: null\n      };\n      // mVibrantSwatch = findColor(TARGET_NORMAL_LUMA, MIN_NORMAL_LUMA, MAX_NORMAL_LUMA,\n      //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n      palette.Vibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetNormalLuma, opts.minNormalLuma, opts.maxNormalLuma, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts);\n      // mLightVibrantSwatch = findColor(TARGET_LIGHT_LUMA, MIN_LIGHT_LUMA, 1f,\n      //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n      palette.LightVibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetLightLuma, opts.minLightLuma, 1, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts);\n      // mDarkVibrantSwatch = findColor(TARGET_DARK_LUMA, 0f, MAX_DARK_LUMA,\n      //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n      palette.DarkVibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetDarkLuma, 0, opts.maxDarkLuma, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts);\n      // mMutedSwatch = findColor(TARGET_NORMAL_LUMA, MIN_NORMAL_LUMA, MAX_NORMAL_LUMA,\n      //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n      palette.Muted = _findColorVariation(palette, swatches, maxPopulation, opts.targetNormalLuma, opts.minNormalLuma, opts.maxNormalLuma, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts);\n      // mLightMutedColor = findColor(TARGET_LIGHT_LUMA, MIN_LIGHT_LUMA, 1f,\n      //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n      palette.LightMuted = _findColorVariation(palette, swatches, maxPopulation, opts.targetLightLuma, opts.minLightLuma, 1, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts);\n      // mDarkMutedSwatch = findColor(TARGET_DARK_LUMA, 0f, MAX_DARK_LUMA,\n      //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n      palette.DarkMuted = _findColorVariation(palette, swatches, maxPopulation, opts.targetDarkLuma, 0, opts.maxDarkLuma, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts);\n      return palette;\n    }\n    function _generateEmptySwatches(palette, maxPopulation, opts) {\n      if (!palette.Vibrant && !palette.DarkVibrant && !palette.LightVibrant) {\n        if (!palette.DarkVibrant && palette.DarkMuted) {\n          var _a = palette.DarkMuted.hsl,\n            h = _a[0],\n            s = _a[1],\n            l = _a[2];\n          l = opts.targetDarkLuma;\n          palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n        if (!palette.LightVibrant && palette.LightMuted) {\n          var _b = palette.LightMuted.hsl,\n            h = _b[0],\n            s = _b[1],\n            l = _b[2];\n          l = opts.targetDarkLuma;\n          palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n      }\n      if (!palette.Vibrant && palette.DarkVibrant) {\n        var _c = palette.DarkVibrant.hsl,\n          h = _c[0],\n          s = _c[1],\n          l = _c[2];\n        l = opts.targetNormalLuma;\n        palette.Vibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n      } else if (!palette.Vibrant && palette.LightVibrant) {\n        var _d = palette.LightVibrant.hsl,\n          h = _d[0],\n          s = _d[1],\n          l = _d[2];\n        l = opts.targetNormalLuma;\n        palette.Vibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n      }\n      if (!palette.DarkVibrant && palette.Vibrant) {\n        var _e = palette.Vibrant.hsl,\n          h = _e[0],\n          s = _e[1],\n          l = _e[2];\n        l = opts.targetDarkLuma;\n        palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n      }\n      if (!palette.LightVibrant && palette.Vibrant) {\n        var _f = palette.Vibrant.hsl,\n          h = _f[0],\n          s = _f[1],\n          l = _f[2];\n        l = opts.targetLightLuma;\n        palette.LightVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n      }\n      if (!palette.Muted && palette.Vibrant) {\n        var _g = palette.Vibrant.hsl,\n          h = _g[0],\n          s = _g[1],\n          l = _g[2];\n        l = opts.targetMutesSaturation;\n        palette.Muted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n      }\n      if (!palette.DarkMuted && palette.DarkVibrant) {\n        var _h = palette.DarkVibrant.hsl,\n          h = _h[0],\n          s = _h[1],\n          l = _h[2];\n        l = opts.targetMutesSaturation;\n        palette.DarkMuted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n      }\n      if (!palette.LightMuted && palette.LightVibrant) {\n        var _j = palette.LightVibrant.hsl,\n          h = _j[0],\n          s = _j[1],\n          l = _j[2];\n        l = opts.targetMutesSaturation;\n        palette.LightMuted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n      }\n    }\n    var DefaultGenerator = function (swatches, opts) {\n      opts = Object.assign({}, DefaultOpts, opts);\n      var maxPopulation = _findMaxPopulation(swatches);\n      var palette = _generateVariationColors(swatches, maxPopulation, opts);\n      _generateEmptySwatches(palette, maxPopulation, opts);\n      return palette;\n    };\n    exports.default = DefaultGenerator;\n\n    /***/\n  }), ( /* 17 */\n  /***/function (module, exports, __nested_webpack_require_55200__) {\n    \"use strict\";\n\n    var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n      function adopt(value) {\n        return value instanceof P ? value : new P(function (resolve) {\n          resolve(value);\n        });\n      }\n      return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    var __generator = this && this.__generator || function (thisArg, body) {\n      var _ = {\n          label: 0,\n          sent: function () {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n          },\n          trys: [],\n          ops: []\n        },\n        f,\n        y,\n        t,\n        g;\n      return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n      }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n      }), g;\n      function verb(n) {\n        return function (v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n            case 7:\n              op = _.ops.pop();\n              _.trys.pop();\n              continue;\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n                _.ops.push(op);\n                break;\n              }\n              if (t[2]) _.ops.pop();\n              _.trys.pop();\n              continue;\n          }\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.BasicPipeline = exports.Stage = void 0;\n    var image_1 = __nested_webpack_require_55200__(2);\n    var Stage = /** @class */function () {\n      function Stage(pipeline) {\n        this.pipeline = pipeline;\n        this._map = {};\n      }\n      Stage.prototype.names = function () {\n        return Object.keys(this._map);\n      };\n      Stage.prototype.has = function (name) {\n        return !!this._map[name];\n      };\n      Stage.prototype.get = function (name) {\n        return this._map[name];\n      };\n      Stage.prototype.register = function (name, stageFn) {\n        this._map[name] = stageFn;\n        return this.pipeline;\n      };\n      return Stage;\n    }();\n    exports.Stage = Stage;\n    var BasicPipeline = /** @class */function () {\n      function BasicPipeline() {\n        this.filter = new Stage(this);\n        this.quantizer = new Stage(this);\n        this.generator = new Stage(this);\n      }\n      BasicPipeline.prototype._buildProcessTasks = function (_a) {\n        var _this = this;\n        var filters = _a.filters,\n          quantizer = _a.quantizer,\n          generators = _a.generators;\n        // Support wildcard for generators\n        if (generators.length === 1 && generators[0] === '*') {\n          generators = this.generator.names();\n        }\n        return {\n          filters: filters.map(function (f) {\n            return createTask(_this.filter, f);\n          }),\n          quantizer: createTask(this.quantizer, quantizer),\n          generators: generators.map(function (g) {\n            return createTask(_this.generator, g);\n          })\n        };\n        function createTask(stage, o) {\n          var name;\n          var options;\n          if (typeof o === 'string') {\n            name = o;\n          } else {\n            name = o.name;\n            options = o.options;\n          }\n          return {\n            name: name,\n            fn: stage.get(name),\n            options: options\n          };\n        }\n      };\n      BasicPipeline.prototype.process = function (imageData, opts) {\n        return __awaiter(this, void 0, void 0, function () {\n          var _a, filters, quantizer, generators, imageFilterData, colors, palettes;\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                _a = this._buildProcessTasks(opts), filters = _a.filters, quantizer = _a.quantizer, generators = _a.generators;\n                return [4 /*yield*/, this._filterColors(filters, imageData)];\n              case 1:\n                imageFilterData = _b.sent();\n                return [4 /*yield*/, this._generateColors(quantizer, imageFilterData)];\n              case 2:\n                colors = _b.sent();\n                return [4 /*yield*/, this._generatePalettes(generators, colors)];\n              case 3:\n                palettes = _b.sent();\n                return [2 /*return*/, {\n                  colors: colors,\n                  palettes: palettes\n                }];\n            }\n          });\n        });\n      };\n      BasicPipeline.prototype._filterColors = function (filters, imageData) {\n        return Promise.resolve(image_1.applyFilters(imageData, filters.map(function (_a) {\n          var fn = _a.fn;\n          return fn;\n        })));\n      };\n      BasicPipeline.prototype._generateColors = function (quantizer, imageData) {\n        return Promise.resolve(quantizer.fn(imageData.data, quantizer.options));\n      };\n      BasicPipeline.prototype._generatePalettes = function (generators, colors) {\n        return __awaiter(this, void 0, void 0, function () {\n          var promiseArr;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4 /*yield*/, Promise.all(generators.map(function (_a) {\n                  var fn = _a.fn,\n                    options = _a.options;\n                  return Promise.resolve(fn(colors, options));\n                }))\n                // Map the values to the expected name\n                ];\n              case 1:\n                promiseArr = _a.sent();\n                // Map the values to the expected name\n                return [2 /*return*/, Promise.resolve(promiseArr.reduce(function (promises, promiseVal, i) {\n                  promises[generators[i].name] = promiseVal;\n                  return promises;\n                }, {}))];\n            }\n          });\n        });\n      };\n      return BasicPipeline;\n    }();\n    exports.BasicPipeline = BasicPipeline;\n\n    /***/\n  }\n  /******/)]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm9kZS12aWJyYW50L2Rpc3QvdmlicmFudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBUUE7QUFDQTs7QUNWQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7O0FBR0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBOztBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTs7QUFDQTs7O0FBR0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFYQTtBQWFBOzs7O0FBSUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFuQkE7Ozs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQU1BO0FBRUE7QUFNQTtBQXFCQTtBQUFBO0FBQ0E7QUFDQTtBQXBCQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7OztBQU1BO0FBSUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQXpHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0dBO0FBQUE7QUFoSEE7Ozs7Ozs7Ozs7O0FDc0JBO0FBQUE7QUFXQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUExQkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFNQTtBQUNBO0FBMUJBOzs7Ozs7Ozs7OztBQ2hFQTtBQXlCQTtBQW1KQTtBQUNBO0FBQ0E7QUFDQTtBQXJKQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQVVBO0FBSEE7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBSEE7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBSEE7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBSEE7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBSEE7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFLQTtBQUhBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUtBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFBQTtBQXZKQTs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQU5BO0FBUUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7O0FBRUE7QUFDQTtBQTNCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBS0E7QUE1QkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQWxCQTtBQW9CQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQTlCQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUF0QkE7Ozs7Ozs7Ozs7OztBQzdMQTtBQUNBO0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDTEE7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUNEQTtBQVVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUVBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pGQTtBQVFBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBRUE7QUFBQTtBQUFBOztBQThGQTtBQXhGQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FDekhBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQUE7QUFNQTs7Ozs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDbkVBO0FBV0E7QUFDQTtBQUVBO0FBYUE7QUFJQTtBQVJBO0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBckJBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFLQTtBQUNBOzs7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBOzs7Ozs7Ozs7OztBQ3BPQTtBQVdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0RBO0FBQUE7QUFBQTtBQUFBOzs7O0FBOERBO0FBQUE7Ozs7Ozs7Ozs7O0FDekVBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7O0FDN0NBO0FBRUE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUVBO0FBS0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFFQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7OztBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoUUE7QUFLQTtBQUVBO0FBQUE7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBaEJBO0FBb0RBO0FBQUE7QUFtQ0E7QUFDQTtBQUNBO0FBNENBO0FBaEZBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7Ozs7QUFJQTtBQUNBOztBQUFBO0FBQ0E7O0FBQUE7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7O0FBSEE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUFBO0FBakZBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24/OTEwMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3dlYnBhY2svYm9vdHN0cmFwPzdmOTgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWNvcmUvc3JjL3V0aWxzLnRzP2YwOGIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWNvcmUvc3JjL2luZGV4LnRzPzZmMDkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWltYWdlL3NyYy9pbmRleC50cz9hOTNhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1jb2xvci9zcmMvaW5kZXgudHM/ZGMyZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtY29sb3Ivc3JjL2NvbnZlcnRlci50cz82NmRlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvc3JjL2Jyb3dzZXIudHM/ZjI1MSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3NyYy9jb25maWcudHM/YzY1YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtY29yZS9zcmMvb3B0aW9ucy50cz9lNGZlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1jb3JlL3NyYy9idWlsZGVyLnRzP2Y2MjAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWltYWdlLWJyb3dzZXIvc3JjL2luZGV4LnRzPzdiNDUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC9zcmMvYnVuZGxlLnRzP2QxOGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC9zcmMvcGlwZWxpbmUvaW5kZXgudHM/OTI2MCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtcXVhbnRpemVyLW1tY3Evc3JjL2luZGV4LnRzP2UzMmEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LXF1YW50aXplci1tbWNxL3NyYy92Ym94LnRzP2NmZGEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWltYWdlL3NyYy9oaXN0b2dyYW0udHM/MDhhNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtcXVhbnRpemVyLW1tY3Evc3JjL3BxdWV1ZS50cz9kNTk5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1nZW5lcmF0b3ItZGVmYXVsdC9zcmMvaW5kZXgudHM/NDM0MCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtY29yZS9zcmMvcGlwZWxpbmUvaW5kZXgudHM/ZmEyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJWaWJyYW50XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlZpYnJhbnRcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMCk7XG4iLCJleHBvcnQgZnVuY3Rpb24gbWFwVmFsdWVzPFQsIFI+IChvOiB7IFtrZXk6IHN0cmluZ106IFQgfSwgbWFwcGVyOiAodjogVCkgPT4gUik6IHsgW2tleTogc3RyaW5nXTogUiB9IHtcbiAgbGV0IHJlc3VsdDogeyBba2V5OiBzdHJpbmddOiBSIH0gPSB7fVxuXG4gIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb25zdCB2ID0gb1trZXldXG4gICAgICByZXN1bHRba2V5XSA9IG1hcHBlcih2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBPdmVyd3JpdGUgdmFsdWVzIG9yIHByb3BlcnRpZXMgb24gb2JqZWN0cyBhbmQgbGlzdHMgcmVjdXJzaXZlbHkuXG4gKiBBIHNoYWxsb3cgY29weSB3aWxsIGJlIGNyZWF0ZWQgZm9yIGVhY2ggYXJyYXkgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25EZWVwPFQ+ICh0YXJnZXQ6IFBhcnRpYWw8VD4sIC4uLnNvdXJjZXM6IChQYXJ0aWFsPFQ+IHwgdW5kZWZpbmVkKVtdKTogVCB7XG4gIHNvdXJjZXMuZm9yRWFjaChzID0+IHtcbiAgICBpZiAoIXMpIHJldHVyblxuICAgIGZvciAoY29uc3Qga2V5IGluIHMpIHtcbiAgICAgIGlmIChzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29uc3QgdiA9IHNba2V5XSBhcyBhbnlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAvLyBTaGFsbG93IGNvcHlcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHYuc2xpY2UoMCkgYXMgYW55XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSB7fSBhcyBhbnlcbiAgICAgICAgICBhc3NpZ25EZWVwPGFueT4odGFyZ2V0W2tleV0gYXMgYW55LCB2KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gdGFyZ2V0IGFzIFRcbn1cbiIsImltcG9ydCB7IE9wdGlvbnMsIGJ1aWxkUHJvY2Vzc09wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMnXG5pbXBvcnQgeyBDYWxsYmFjayB9IGZyb20gJ0B2aWJyYW50L3R5cGVzJ1xuaW1wb3J0IHsgSW1hZ2UsIEltYWdlU291cmNlIH0gZnJvbSAnQHZpYnJhbnQvaW1hZ2UnXG5cbmltcG9ydCB7IEZpbHRlciwgUGFsZXR0ZSwgU3dhdGNoIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5cbmltcG9ydCBCdWlsZGVyIGZyb20gJy4vYnVpbGRlcidcbmltcG9ydCB7IFBpcGVsaW5lLCBQcm9jZXNzT3B0aW9ucywgUHJvY2Vzc1Jlc3VsdCB9IGZyb20gJy4vcGlwZWxpbmUnXG5pbXBvcnQgeyBhc3NpZ25EZWVwIH0gZnJvbSAnLi91dGlscydcblxuZXhwb3J0IGludGVyZmFjZSBWaWJyYW50U3RhdGljIHtcbiAgZnJvbSAoc3JjOiBJbWFnZVNvdXJjZSk6IEJ1aWxkZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlicmFudCB7XG4gIHByaXZhdGUgX3Jlc3VsdDogUHJvY2Vzc1Jlc3VsdFxuICBwcml2YXRlIHN0YXRpYyBfcGlwZWxpbmU6IFBpcGVsaW5lXG4gIHN0YXRpYyB1c2UgKHBpcGVsaW5lOiBQaXBlbGluZSkge1xuICAgIHRoaXMuX3BpcGVsaW5lID0gcGlwZWxpbmVcbiAgfVxuICBzdGF0aWMgRGVmYXVsdE9wdHM6IFBhcnRpYWw8T3B0aW9ucz4gPSB7XG4gICAgY29sb3JDb3VudDogNjQsXG4gICAgcXVhbGl0eTogNSxcbiAgICBmaWx0ZXJzOiBbXVxuICB9XG5cbiAgc3RhdGljIGZyb20gKHNyYzogSW1hZ2VTb3VyY2UpOiBCdWlsZGVyIHtcbiAgICByZXR1cm4gbmV3IEJ1aWxkZXIoc3JjKVxuICB9XG5cbiAgZ2V0IHJlc3VsdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3VsdFxuICB9XG5cbiAgb3B0czogT3B0aW9uc1xuICBjb25zdHJ1Y3RvciAocHJpdmF0ZSBfc3JjOiBJbWFnZVNvdXJjZSwgb3B0cz86IFBhcnRpYWw8T3B0aW9ucz4pIHtcbiAgICB0aGlzLm9wdHMgPSBhc3NpZ25EZWVwKHt9LCBWaWJyYW50LkRlZmF1bHRPcHRzLCBvcHRzKVxuICB9XG4gIHByaXZhdGUgX3Byb2Nlc3MgKFxuICAgIGltYWdlOiBJbWFnZSxcbiAgICBvcHRzPzogUGFydGlhbDxQcm9jZXNzT3B0aW9ucz5cbiAgKTogUHJvbWlzZTxQcm9jZXNzUmVzdWx0PiB7XG4gICAgbGV0IHsgcXVhbnRpemVyIH0gPSB0aGlzLm9wdHNcblxuICAgIGltYWdlLnNjYWxlRG93bih0aGlzLm9wdHMpXG5cbiAgICBsZXQgcHJvY2Vzc09wdHMgPSBidWlsZFByb2Nlc3NPcHRpb25zKHRoaXMub3B0cywgb3B0cylcblxuICAgIHJldHVybiBWaWJyYW50Ll9waXBlbGluZS5wcm9jZXNzKGltYWdlLmdldEltYWdlRGF0YSgpLCBwcm9jZXNzT3B0cylcbiAgfVxuICBwYWxldHRlICgpOiBQYWxldHRlIHtcbiAgICByZXR1cm4gdGhpcy5zd2F0Y2hlcygpXG4gIH1cbiAgc3dhdGNoZXMgKCk6IFBhbGV0dGUge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdNZXRob2QgZGVwcmVjYXRlZC4gVXNlIGBWaWJyYW50LnJlc3VsdC5wYWxldHRlc1tuYW1lXWAgaW5zdGVhZCdcbiAgICApXG4gIH1cblxuICBnZXRQYWxldHRlIChuYW1lOiBzdHJpbmcsIGNiPzogQ2FsbGJhY2s8UGFsZXR0ZT4pOiBQcm9taXNlPFBhbGV0dGU+XG4gIGdldFBhbGV0dGUgKGNiPzogQ2FsbGJhY2s8UGFsZXR0ZT4pOiBQcm9taXNlPFBhbGV0dGU+XG4gIGdldFBhbGV0dGUgKCk6IFByb21pc2U8UGFsZXR0ZT4ge1xuICAgIGNvbnN0IGFyZzAgPSBhcmd1bWVudHNbMF1cbiAgICBjb25zdCBhcmcxID0gYXJndW1lbnRzWzFdXG4gICAgY29uc3QgbmFtZSA9IHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJyA/IGFyZzAgOiAnZGVmYXVsdCdcbiAgICBjb25zdCBjYiA9IHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJyA/IGFyZzEgOiBhcmcwXG4gICAgbGV0IGltYWdlID0gbmV3IHRoaXMub3B0cy5JbWFnZUNsYXNzKClcbiAgICByZXR1cm4gaW1hZ2VcbiAgICAgIC5sb2FkKHRoaXMuX3NyYylcbiAgICAgIC50aGVuKGltYWdlID0+IHRoaXMuX3Byb2Nlc3MoaW1hZ2UsIHsgZ2VuZXJhdG9yczogW25hbWVdIH0pKVxuICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgIHJldHVybiByZXN1bHQucGFsZXR0ZXNbbmFtZV1cbiAgICAgIH0pXG4gICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICBpbWFnZS5yZW1vdmUoKVxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYih1bmRlZmluZWQsIHJlcylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGltYWdlLnJlbW92ZSgpXG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKGVycilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgICAgfSlcbiAgfVxuICBnZXRQYWxldHRlcyAoXG4gICAgbmFtZXM6IHN0cmluZ1tdLFxuICAgIGNiPzogQ2FsbGJhY2s8UGFsZXR0ZT5cbiAgKTogUHJvbWlzZTx7IFtuYW1lOiBzdHJpbmddOiBQYWxldHRlIH0+XG4gIGdldFBhbGV0dGVzIChjYj86IENhbGxiYWNrPFBhbGV0dGU+KTogUHJvbWlzZTx7IFtuYW1lOiBzdHJpbmddOiBQYWxldHRlIH0+XG4gIGdldFBhbGV0dGVzICgpOiBQcm9taXNlPHsgW25hbWU6IHN0cmluZ106IFBhbGV0dGUgfT4ge1xuICAgIGNvbnN0IGFyZzAgPSBhcmd1bWVudHNbMF1cbiAgICBjb25zdCBhcmcxID0gYXJndW1lbnRzWzFdXG4gICAgY29uc3QgbmFtZXMgPSBBcnJheS5pc0FycmF5KGFyZzApID8gYXJnMCA6IFsnKiddXG4gICAgY29uc3QgY2IgPSBBcnJheS5pc0FycmF5KGFyZzApID8gYXJnMSA6IGFyZzBcbiAgICBsZXQgaW1hZ2UgPSBuZXcgdGhpcy5vcHRzLkltYWdlQ2xhc3MoKVxuICAgIHJldHVybiBpbWFnZVxuICAgICAgLmxvYWQodGhpcy5fc3JjKVxuICAgICAgLnRoZW4oaW1hZ2UgPT5cbiAgICAgICAgdGhpcy5fcHJvY2VzcyhpbWFnZSwge1xuICAgICAgICAgIGdlbmVyYXRvcnM6IG5hbWVzXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5wYWxldHRlc1xuICAgICAgfSlcbiAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIGltYWdlLnJlbW92ZSgpXG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKHVuZGVmaW5lZCwgcmVzKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaW1hZ2UucmVtb3ZlKClcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gICAgICB9KVxuICB9XG59XG4iLCJpbXBvcnQgeyBDYWxsYmFjayB9IGZyb20gJ0B2aWJyYW50L3R5cGVzJ1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5cbmV4cG9ydCB0eXBlIEltYWdlQ2FsbGJhY2sgPSBDYWxsYmFjazxJbWFnZT5cblxuZXhwb3J0IHR5cGUgSW1hZ2VTb3VyY2UgPSBzdHJpbmcgfCBIVE1MSW1hZ2VFbGVtZW50IHwgQnVmZmVyXG5cbmV4cG9ydCB0eXBlIFBpeGVscyA9IFVpbnQ4Q2xhbXBlZEFycmF5IHwgQnVmZmVyXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlRGF0YSB7XG4gIGRhdGE6IFBpeGVscyxcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZU9wdGlvbnMge1xuICBxdWFsaXR5OiBudW1iZXJcbiAgbWF4RGltZW5zaW9uOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZSB7XG4gIGxvYWQgKGltYWdlOiBJbWFnZVNvdXJjZSk6IFByb21pc2U8SW1hZ2U+XG4gIGNsZWFyICgpOiB2b2lkXG4gIHVwZGF0ZSAoaW1hZ2VEYXRhOiBJbWFnZURhdGEpOiB2b2lkXG4gIGdldFdpZHRoICgpOiBudW1iZXJcbiAgZ2V0SGVpZ2h0ICgpOiBudW1iZXJcbiAgcmVzaXplICh0YXJnZXRXaWR0aDogbnVtYmVyLCB0YXJnZXRIZWlnaHQ6IG51bWJlciwgcmF0aW86IG51bWJlcik6IHZvaWRcbiAgZ2V0UGl4ZWxDb3VudCAoKTogbnVtYmVyXG4gIGdldEltYWdlRGF0YSAoKTogSW1hZ2VEYXRhXG4gIHJlbW92ZSAoKTogdm9pZFxuICBzY2FsZURvd24gKG9wdHM6IEltYWdlT3B0aW9ucyk6IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUNsYXNzIHtcbiAgbmV3KCk6IEltYWdlXG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbWFnZUJhc2UgaW1wbGVtZW50cyBJbWFnZSB7XG4gIGFic3RyYWN0IGxvYWQgKGltYWdlOiBJbWFnZVNvdXJjZSk6IFByb21pc2U8SW1hZ2VCYXNlPlxuICBhYnN0cmFjdCBjbGVhciAoKTogdm9pZFxuICBhYnN0cmFjdCB1cGRhdGUgKGltYWdlRGF0YTogSW1hZ2VEYXRhKTogdm9pZFxuICBhYnN0cmFjdCBnZXRXaWR0aCAoKTogbnVtYmVyXG4gIGFic3RyYWN0IGdldEhlaWdodCAoKTogbnVtYmVyXG4gIGFic3RyYWN0IHJlc2l6ZSAodGFyZ2V0V2lkdGg6IG51bWJlciwgdGFyZ2V0SGVpZ2h0OiBudW1iZXIsIHJhdGlvOiBudW1iZXIpOiB2b2lkXG4gIGFic3RyYWN0IGdldFBpeGVsQ291bnQgKCk6IG51bWJlclxuICBhYnN0cmFjdCBnZXRJbWFnZURhdGEgKCk6IEltYWdlRGF0YVxuICBhYnN0cmFjdCByZW1vdmUgKCk6IHZvaWRcblxuICBzY2FsZURvd24gKG9wdHM6IEltYWdlT3B0aW9ucyk6IHZvaWQge1xuICAgIGxldCB3aWR0aDogbnVtYmVyID0gdGhpcy5nZXRXaWR0aCgpXG4gICAgbGV0IGhlaWdodDogbnVtYmVyID0gdGhpcy5nZXRIZWlnaHQoKVxuXG4gICAgbGV0IHJhdGlvOiBudW1iZXIgPSAxXG5cbiAgICBpZiAob3B0cy5tYXhEaW1lbnNpb24gPiAwKSB7XG4gICAgICBsZXQgbWF4U2lkZTogbnVtYmVyID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodClcbiAgICAgIGlmIChtYXhTaWRlID4gb3B0cy5tYXhEaW1lbnNpb24pIHJhdGlvID0gb3B0cy5tYXhEaW1lbnNpb24gLyBtYXhTaWRlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhdGlvID0gMSAvIG9wdHMucXVhbGl0eVxuICAgIH1cblxuICAgIGlmIChyYXRpbyA8IDEpIHRoaXMucmVzaXplKHdpZHRoICogcmF0aW8sIGhlaWdodCAqIHJhdGlvLCByYXRpbylcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlGaWx0ZXJzIChpbWFnZURhdGE6IEltYWdlRGF0YSwgZmlsdGVyczogRmlsdGVyW10pIHtcbiAgaWYgKGZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgIGxldCBwaXhlbHMgPSBpbWFnZURhdGEuZGF0YVxuICAgIGxldCBuID0gcGl4ZWxzLmxlbmd0aCAvIDRcbiAgICBsZXQgb2Zmc2V0XG4gICAgbGV0IHJcbiAgICBsZXQgZ1xuICAgIGxldCBiXG4gICAgbGV0IGFcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgb2Zmc2V0ID0gaSAqIDRcbiAgICAgIHIgPSBwaXhlbHNbb2Zmc2V0ICsgMF1cbiAgICAgIGcgPSBwaXhlbHNbb2Zmc2V0ICsgMV1cbiAgICAgIGIgPSBwaXhlbHNbb2Zmc2V0ICsgMl1cbiAgICAgIGEgPSBwaXhlbHNbb2Zmc2V0ICsgM11cbiAgICAgIC8vIE1hcmsgaWdub3JlZCBjb2xvclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWx0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghZmlsdGVyc1tqXShyLCBnLCBiLCBhKSkge1xuICAgICAgICAgIHBpeGVsc1tvZmZzZXQgKyAzXSA9IDBcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGltYWdlRGF0YVxufVxuIiwiaW1wb3J0IHsgcmdiVG9Ic2wsIHJnYlRvSGV4IH0gZnJvbSAnLi9jb252ZXJ0ZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsdGVyIHtcbiAgKHJlZDogbnVtYmVyLCBncmVlbjogbnVtYmVyLCBibHVlOiBudW1iZXIsIGFscGhhOiBudW1iZXIpOiBib29sZWFuXG59XG5cbi8qKlxuICogM2QgZmxvYXRpbmcgcG9pbnRlciB2ZWN0b3JcbiAqL1xuZXhwb3J0IHR5cGUgVmVjMyA9IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuXG4vKipcbiAqIFRoZSBsYXlvdXQgZm9yIGEgbm9kZS12aWJyYW50IFBhbGV0dGUuIEFsbG93cyB5b3UgdG8ga2VlcCB0cmFjayBvZlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhbGV0dGUge1xuICBWaWJyYW50OiBTd2F0Y2ggfCBudWxsXG4gIE11dGVkOiBTd2F0Y2ggfCBudWxsXG4gIERhcmtWaWJyYW50OiBTd2F0Y2ggfCBudWxsXG4gIERhcmtNdXRlZDogU3dhdGNoIHwgbnVsbFxuICBMaWdodFZpYnJhbnQ6IFN3YXRjaCB8IG51bGxcbiAgTGlnaHRNdXRlZDogU3dhdGNoIHwgbnVsbFxuICAvLyA/XG4gIFtuYW1lOiBzdHJpbmddOiBTd2F0Y2ggfCBudWxsXG59XG5cbmV4cG9ydCBjbGFzcyBTd2F0Y2gge1xuICBzdGF0aWMgYXBwbHlGaWx0ZXJzIChjb2xvcnM6IFN3YXRjaFtdLCBmaWx0ZXJzOiBGaWx0ZXJbXSk6IFN3YXRjaFtdIHtcbiAgICByZXR1cm4gZmlsdGVycy5sZW5ndGggPiAwXG4gICAgICA/IGNvbG9ycy5maWx0ZXIoKHsgciwgZywgYiB9KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmlsdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICghZmlsdGVyc1tqXShyLCBnLCBiLCAyNTUpKSByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICAgIDogY29sb3JzXG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHZhbHVlIGNvcHkgb2YgYSBzd2F0Y2ggYmFzZWQgb24gYSBwcmV2aW91cyBvbmUuIFJldHVybnMgYSBuZXcgU3dhdGNoIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dhdGNofSBzd2F0Y2hcbiAgICovXG4gIHN0YXRpYyBjbG9uZSAoc3dhdGNoOiBTd2F0Y2gpIHtcbiAgICByZXR1cm4gbmV3IFN3YXRjaChzd2F0Y2guX3JnYiwgc3dhdGNoLl9wb3B1bGF0aW9uKVxuICB9XG4gIHByaXZhdGUgX2hzbDogVmVjM1xuICBwcml2YXRlIF9yZ2I6IFZlYzNcbiAgcHJpdmF0ZSBfeWlxOiBudW1iZXJcbiAgcHJpdmF0ZSBfcG9wdWxhdGlvbjogbnVtYmVyXG4gIHByaXZhdGUgX2hleDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSByZWQgdmFsdWUgaW4gdGhlIFJHQiB2YWx1ZVxuICAgKi9cbiAgZ2V0IHIgKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3JnYlswXVxuICB9XG4gIC8qKlxuICAgKiBUaGUgZ3JlZW4gdmFsdWUgaW4gdGhlIFJHQiB2YWx1ZVxuICAgKi9cbiAgZ2V0IGcgKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3JnYlsxXVxuICB9XG4gIC8qKlxuICAgKiBUaGUgYmx1ZSB2YWx1ZSBpbiB0aGUgUkdCIHZhbHVlXG4gICAqL1xuICBnZXQgYiAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiWzJdXG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjb2xvciB2YWx1ZSBhcyBhIHJnYiB2YWx1ZVxuICAgKi9cbiAgZ2V0IHJnYiAoKTogVmVjMyB7XG4gICAgcmV0dXJuIHRoaXMuX3JnYlxuICB9XG4gIC8qKlxuICAgKiBUaGUgY29sb3IgdmFsdWUgYXMgYSBoc2wgdmFsdWVcbiAgICovXG4gIGdldCBoc2wgKCk6IFZlYzMge1xuICAgIGlmICghdGhpcy5faHNsKSB7XG4gICAgICBsZXQgW3IsIGcsIGJdID0gdGhpcy5fcmdiXG4gICAgICB0aGlzLl9oc2wgPSByZ2JUb0hzbChyLCBnLCBiKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faHNsXG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbG9yIHZhbHVlIGFzIGEgaGV4IHN0cmluZ1xuICAgKi9cbiAgZ2V0IGhleCAoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuX2hleCkge1xuICAgICAgbGV0IFtyLCBnLCBiXSA9IHRoaXMuX3JnYlxuICAgICAgdGhpcy5faGV4ID0gcmdiVG9IZXgociwgZywgYilcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2hleFxuICB9XG4gIGdldCBwb3B1bGF0aW9uICgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9wb3B1bGF0aW9uXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBKU09OIG9iamVjdCBmb3IgdGhlIHN3YXRjaFxuICAgKi9cbiAgdG9KU09OICgpOiB7cmdiOiBWZWMzLCBwb3B1bGF0aW9uOiBudW1iZXJ9IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmdiOiB0aGlzLnJnYixcbiAgICAgIHBvcHVsYXRpb246IHRoaXMucG9wdWxhdGlvblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbG9yIHZhbHVlIGFzIGEgcmdiIHZhbHVlXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcm9wZXJ0eSBpbnN0ZWFkXG4gICAqL1xuICAvLyBUT0RPOiBkZXByZWNhdGUgaW50ZXJuYWxseSwgdXNlIHByb3BlcnR5IGluc3RlYWRcbiAgZ2V0UmdiICgpOiBWZWMzIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiXG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY29sb3IgdmFsdWUgYXMgYSBoc2wgdmFsdWVcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByb3BlcnR5IGluc3RlYWRcbiAgICovXG4gIC8vIFRPRE86IGRlcHJlY2F0ZSBpbnRlcm5hbGx5LCB1c2UgcHJvcGVydHkgaW5zdGVhZFxuICBnZXRIc2wgKCk6IFZlYzMge1xuICAgIHJldHVybiB0aGlzLmhzbFxuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJvcGVydHkgaW5zdGVhZFxuICAgKi9cbiAgLy8gVE9ETzogZGVwcmVjYXRlIGludGVybmFsbHksIHVzZSBwcm9wZXJ0eSBpbnN0ZWFkXG4gIGdldFBvcHVsYXRpb24gKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcHVsYXRpb25cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjb2xvciB2YWx1ZSBhcyBhIGhleCBzdHJpbmdcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByb3BlcnR5IGluc3RlYWRcbiAgICovXG4gIC8vIFRPRE86IGRlcHJlY2F0ZSBpbnRlcm5hbGx5LCB1c2UgcHJvcGVydHkgaW5zdGVhZFxuICBnZXRIZXggKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaGV4XG4gIH1cblxuICBwcml2YXRlIGdldFlpcSAoKTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMuX3lpcSkge1xuICAgICAgbGV0IHJnYiA9IHRoaXMuX3JnYlxuICAgICAgdGhpcy5feWlxID0gKHJnYlswXSAqIDI5OSArIHJnYlsxXSAqIDU4NyArIHJnYlsyXSAqIDExNCkgLyAxMDAwXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl95aXFcbiAgfVxuXG4gIHByaXZhdGUgX3RpdGxlVGV4dENvbG9yOiBzdHJpbmdcbiAgcHJpdmF0ZSBfYm9keVRleHRDb2xvcjogc3RyaW5nXG5cbiAgZ2V0IHRpdGxlVGV4dENvbG9yICgpIHtcbiAgICBpZiAodGhpcy5fdGl0bGVUZXh0Q29sb3IpIHtcbiAgICAgIHRoaXMuX3RpdGxlVGV4dENvbG9yID0gdGhpcy5nZXRZaXEoKSA8IDIwMCA/ICcjZmZmJyA6ICcjMDAwJ1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGl0bGVUZXh0Q29sb3JcbiAgfVxuICBnZXQgYm9keVRleHRDb2xvciAoKSB7XG4gICAgaWYgKHRoaXMuX2JvZHlUZXh0Q29sb3IpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0Q29sb3IgPSB0aGlzLmdldFlpcSgpIDwgMTUwID8gJyNmZmYnIDogJyMwMDAnXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ib2R5VGV4dENvbG9yXG4gIH1cbiAgZ2V0VGl0bGVUZXh0Q29sb3IgKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGVUZXh0Q29sb3JcbiAgfVxuXG4gIGdldEJvZHlUZXh0Q29sb3IgKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYm9keVRleHRDb2xvclxuICB9XG5cbiAgY29uc3RydWN0b3IgKHJnYjogVmVjMywgcG9wdWxhdGlvbjogbnVtYmVyKSB7XG4gICAgdGhpcy5fcmdiID0gcmdiXG4gICAgdGhpcy5fcG9wdWxhdGlvbiA9IHBvcHVsYXRpb25cbiAgfVxufVxuIiwiaW1wb3J0IHsgVmVjMyB9IGZyb20gJy4vJ1xuXG5leHBvcnQgY29uc3QgREVMVEFFOTRfRElGRl9TVEFUVVMgPSB7XG4gIE5BOiAwLFxuICBQRVJGRUNUOiAxLFxuICBDTE9TRTogMixcbiAgR09PRDogMTAsXG4gIFNJTUlMQVI6IDUwXG59XG5cbi8qKlxuICogQ29udmVydHMgaGV4IHN0cmluZyB0byBSR0JcbiAqIEBwYXJhbSBoZXggLSBUaGUgaGV4IHZhbHVlIHlvdSB3aXRoIHRvIGdldCB0aGUgUkdCIHZhbHVlIG9mXG4gKiBAcmV0dXJucyBhbiBhcnJheSBpbiB0aGUgb3JkZXIgb2YgYHJlZCwgZ3JlZW4sIGJsdWVgIG51bWVyaWNhbCB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvUmdiIChoZXg6IHN0cmluZyk6IFZlYzMge1xuICBsZXQgbSA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpXG5cbiAgaWYgKCFtKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJyR7aGV4fScgaXMgbm90IGEgdmFsaWQgaGV4IGNvbG9yYClcblxuICByZXR1cm4gW21bMV0sIG1bMl0sIG1bM11dLm1hcCgocykgPT4gcGFyc2VJbnQocywgMTYpKSBhcyBWZWMzXG59XG5cbi8qKlxuICogR2l2ZW4gdmFsdWVzIGZvciBhbiBSR0IgY29sb3IgY29udmVydCB0byBhbmQgcmV0dXJuIGEgdmFsaWQgSEVYIHN0cmluZ1xuICogQHBhcmFtIHIgLSBSZWQgdmFsdWUgaW4gUkdCXG4gKiBAcGFyYW0gZyAtIEdyZWVuIHZhbHVlIGluIFJHQlxuICogQHBhcmFtIGIgLSBCbHVlIHZhbHVlIGluIFJHQlxuICogQHJldHVybnMgYSB2YWxpZCBoZXggc3RyaW5nIHdpdGggcHJlLXBlbmRpbmcgcG91bmQgc2lnblxuICovXG5leHBvcnQgZnVuY3Rpb24gcmdiVG9IZXggKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gJyMnICsgKCgxIDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYikudG9TdHJpbmcoMTYpLnNsaWNlKDEsIDcpXG59XG5cbi8qKlxuICogR2l2ZW4gdmFsdWVzIGZvciBhbiBSR0IgY29sb3IgY29udmVydCB0byBhbmQgcmV0dXJuIGEgdmFsaWQgSFNMIHZhbHVlXG4gKiBAcGFyYW0gciAtIFJlZCB2YWx1ZSBpbiBSR0JcbiAqIEBwYXJhbSBnIC0gR3JlZW4gdmFsdWUgaW4gUkdCXG4gKiBAcGFyYW0gYiAtIEJsdWUgdmFsdWUgaW4gUkdCXG4gKiBAcmV0dXJucyBhbiBhcnJheSBpbiB0aGUgb3JkZXIgb2YgYGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRgIG51bWVyaWNhbCB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJnYlRvSHNsIChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKTogVmVjMyB7XG4gIHIgLz0gMjU1XG4gIGcgLz0gMjU1XG4gIGIgLz0gMjU1XG4gIGxldCBtYXggPSBNYXRoLm1heChyLCBnLCBiKVxuICBsZXQgbWluID0gTWF0aC5taW4ociwgZywgYilcbiAgbGV0IGg6IG51bWJlciA9IDBcbiAgbGV0IHM6IG51bWJlciA9IDBcbiAgbGV0IGwgPSAobWF4ICsgbWluKSAvIDJcbiAgaWYgKG1heCAhPT0gbWluKSB7XG4gICAgbGV0IGQgPSBtYXggLSBtaW5cbiAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbilcbiAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgY2FzZSByOlxuICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgZzpcbiAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMlxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBiOlxuICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgaCAvPSA2XG4gIH1cbiAgcmV0dXJuIFtoLCBzLCBsXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsVG9SZ2IgKGg6IG51bWJlciwgczogbnVtYmVyLCBsOiBudW1iZXIpOiBWZWMzIHtcbiAgbGV0IHI6IG51bWJlclxuICBsZXQgZzogbnVtYmVyXG4gIGxldCBiOiBudW1iZXJcblxuICBmdW5jdGlvbiBodWUycmdiIChwOiBudW1iZXIsIHE6IG51bWJlciwgdDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAodCA8IDApIHQgKz0gMVxuICAgIGlmICh0ID4gMSkgdCAtPSAxXG4gICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHRcbiAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcVxuICAgIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNlxuICAgIHJldHVybiBwXG4gIH1cblxuICBpZiAocyA9PT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGxcbiAgfSBlbHNlIHtcbiAgICBsZXQgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gKGwgKiBzKVxuICAgIGxldCBwID0gMiAqIGwgLSBxXG4gICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKVxuICAgIGcgPSBodWUycmdiKHAsIHEsIGgpXG4gICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtICgxIC8gMykpXG4gIH1cbiAgcmV0dXJuIFtcbiAgICByICogMjU1LFxuICAgIGcgKiAyNTUsXG4gICAgYiAqIDI1NVxuICBdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JUb1h5eiAocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcik6IFZlYzMge1xuICByIC89IDI1NVxuICBnIC89IDI1NVxuICBiIC89IDI1NVxuICByID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygociArIDAuMDA1KSAvIDEuMDU1LCAyLjQpIDogciAvIDEyLjkyXG4gIGcgPSBnID4gMC4wNDA0NSA/IE1hdGgucG93KChnICsgMC4wMDUpIC8gMS4wNTUsIDIuNCkgOiBnIC8gMTIuOTJcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGIgKyAwLjAwNSkgLyAxLjA1NSwgMi40KSA6IGIgLyAxMi45MlxuXG4gIHIgKj0gMTAwXG4gIGcgKj0gMTAwXG4gIGIgKj0gMTAwXG5cbiAgbGV0IHggPSByICogMC40MTI0ICsgZyAqIDAuMzU3NiArIGIgKiAwLjE4MDVcbiAgbGV0IHkgPSByICogMC4yMTI2ICsgZyAqIDAuNzE1MiArIGIgKiAwLjA3MjJcbiAgbGV0IHogPSByICogMC4wMTkzICsgZyAqIDAuMTE5MiArIGIgKiAwLjk1MDVcblxuICByZXR1cm4gW3gsIHksIHpdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB4eXpUb0NJRUxhYiAoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IFZlYzMge1xuICBsZXQgUkVGX1ggPSA5NS4wNDdcbiAgbGV0IFJFRl9ZID0gMTAwXG4gIGxldCBSRUZfWiA9IDEwOC44ODNcblxuICB4IC89IFJFRl9YXG4gIHkgLz0gUkVGX1lcbiAgeiAvPSBSRUZfWlxuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiA3Ljc4NyAqIHggKyAxNiAvIDExNlxuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMSAvIDMpIDogNy43ODcgKiB5ICsgMTYgLyAxMTZcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEgLyAzKSA6IDcuNzg3ICogeiArIDE2IC8gMTE2XG5cbiAgbGV0IEwgPSAxMTYgKiB5IC0gMTZcbiAgbGV0IGEgPSA1MDAgKiAoeCAtIHkpXG4gIGxldCBiID0gMjAwICogKHkgLSB6KVxuXG4gIHJldHVybiBbTCwgYSwgYl1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYlRvQ0lFTGFiIChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKTogVmVjMyB7XG4gIGxldCBbeCwgeSwgel0gPSByZ2JUb1h5eihyLCBnLCBiKVxuICByZXR1cm4geHl6VG9DSUVMYWIoeCwgeSwgeilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbHRhRTk0IChsYWIxOiBWZWMzLCBsYWIyOiBWZWMzKTogbnVtYmVyIHtcbiAgbGV0IFdFSUdIVF9MID0gMVxuICBsZXQgV0VJR0hUX0MgPSAxXG4gIGxldCBXRUlHSFRfSCA9IDFcblxuICBsZXQgW0wxLCBhMSwgYjFdID0gbGFiMVxuICBsZXQgW0wyLCBhMiwgYjJdID0gbGFiMlxuICBsZXQgZEwgPSBMMSAtIEwyXG4gIGxldCBkYSA9IGExIC0gYTJcbiAgbGV0IGRiID0gYjEgLSBiMlxuXG4gIGxldCB4QzEgPSBNYXRoLnNxcnQoYTEgKiBhMSArIGIxICogYjEpXG4gIGxldCB4QzIgPSBNYXRoLnNxcnQoYTIgKiBhMiArIGIyICogYjIpXG5cbiAgbGV0IHhETCA9IEwyIC0gTDFcbiAgbGV0IHhEQyA9IHhDMiAtIHhDMVxuICBsZXQgeERFID0gTWF0aC5zcXJ0KGRMICogZEwgKyBkYSAqIGRhICsgZGIgKiBkYilcblxuICBsZXQgeERIID0gKE1hdGguc3FydCh4REUpID4gTWF0aC5zcXJ0KE1hdGguYWJzKHhETCkpICsgTWF0aC5zcXJ0KE1hdGguYWJzKHhEQykpKVxuICAgID8gTWF0aC5zcXJ0KHhERSAqIHhERSAtIHhETCAqIHhETCAtIHhEQyAqIHhEQylcbiAgICA6IDBcblxuICBsZXQgeFNDID0gMSArIDAuMDQ1ICogeEMxXG4gIGxldCB4U0ggPSAxICsgMC4wMTUgKiB4QzFcblxuICB4REwgLz0gV0VJR0hUX0xcbiAgeERDIC89IFdFSUdIVF9DICogeFNDXG4gIHhESCAvPSBXRUlHSFRfSCAqIHhTSFxuXG4gIHJldHVybiBNYXRoLnNxcnQoeERMICogeERMICsgeERDICogeERDICsgeERIICogeERIKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiRGlmZiAocmdiMTogVmVjMywgcmdiMjogVmVjMyk6IG51bWJlciB7XG4gIGxldCBsYWIxID0gcmdiVG9DSUVMYWIuYXBwbHkodW5kZWZpbmVkLCByZ2IxKVxuICBsZXQgbGFiMiA9IHJnYlRvQ0lFTGFiLmFwcGx5KHVuZGVmaW5lZCwgcmdiMilcbiAgcmV0dXJuIGRlbHRhRTk0KGxhYjEsIGxhYjIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhEaWZmIChoZXgxOiBzdHJpbmcsIGhleDI6IHN0cmluZyk6IG51bWJlciB7XG4gIGxldCByZ2IxID0gaGV4VG9SZ2IoaGV4MSlcbiAgbGV0IHJnYjIgPSBoZXhUb1JnYihoZXgyKVxuXG4gIHJldHVybiByZ2JEaWZmKHJnYjEsIHJnYjIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xvckRpZmZTdGF0dXMgKGQ6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChkIDwgREVMVEFFOTRfRElGRl9TVEFUVVMuTkEpIHtcbiAgICByZXR1cm4gJ04vQSdcbiAgfVxuICAvLyBOb3QgcGVyY2VwdGlibGUgYnkgaHVtYW4gZXllc1xuICBpZiAoZCA8PSBERUxUQUU5NF9ESUZGX1NUQVRVUy5QRVJGRUNUKSB7XG4gICAgcmV0dXJuICdQZXJmZWN0J1xuICB9XG4gIC8vIFBlcmNlcHRpYmxlIHRocm91Z2ggY2xvc2Ugb2JzZXJ2YXRpb25cbiAgaWYgKGQgPD0gREVMVEFFOTRfRElGRl9TVEFUVVMuQ0xPU0UpIHtcbiAgICByZXR1cm4gJ0Nsb3NlJ1xuICB9XG4gIC8vIFBlcmNlcHRpYmxlIGF0IGEgZ2xhbmNlXG4gIGlmIChkIDw9IERFTFRBRTk0X0RJRkZfU1RBVFVTLkdPT0QpIHtcbiAgICByZXR1cm4gJ0dvb2QnXG4gIH1cbiAgLy8gQ29sb3JzIGFyZSBtb3JlIHNpbWlsYXIgdGhhbiBvcHBvc2l0ZVxuICBpZiAoZCA8IERFTFRBRTk0X0RJRkZfU1RBVFVTLlNJTUlMQVIpIHtcbiAgICByZXR1cm4gJ1NpbWlsYXInXG4gIH1cbiAgcmV0dXJuICdXcm9uZydcblxufVxuIiwiaW1wb3J0IFZpYnJhbnQgZnJvbSAnLi9jb25maWcnXG5pbXBvcnQgQnJvd3NlckltYWdlIGZyb20gJ0B2aWJyYW50L2ltYWdlLWJyb3dzZXInXG5cblZpYnJhbnQuRGVmYXVsdE9wdHMuSW1hZ2VDbGFzcyA9IEJyb3dzZXJJbWFnZVxuXG5leHBvcnQgPSBWaWJyYW50XG4iLCJpbXBvcnQgVmlicmFudCBmcm9tICdAdmlicmFudC9jb3JlJ1xuXG5WaWJyYW50LkRlZmF1bHRPcHRzLnF1YW50aXplciA9ICdtbWNxJ1xuVmlicmFudC5EZWZhdWx0T3B0cy5nZW5lcmF0b3JzID0gWydkZWZhdWx0J11cblZpYnJhbnQuRGVmYXVsdE9wdHMuZmlsdGVycyA9IFsnZGVmYXVsdCddXG5cbmV4cG9ydCBkZWZhdWx0IFZpYnJhbnRcbiIsImltcG9ydCB7IFBhbGV0dGUsIFN3YXRjaCwgRmlsdGVyIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5pbXBvcnQgeyBJbWFnZSwgSW1hZ2VDbGFzcywgSW1hZ2VTb3VyY2UsIEltYWdlT3B0aW9ucyB9IGZyb20gJ0B2aWJyYW50L2ltYWdlJ1xuaW1wb3J0IHsgUXVhbnRpemVyLCBRdWFudGl6ZXJPcHRpb25zIH0gZnJvbSAnQHZpYnJhbnQvcXVhbnRpemVyJ1xuaW1wb3J0IHsgR2VuZXJhdG9yIH0gZnJvbSAnQHZpYnJhbnQvZ2VuZXJhdG9yJ1xuaW1wb3J0IHsgU3RhZ2VPcHRpb25zLCBQcm9jZXNzT3B0aW9ucyB9IGZyb20gJy4vcGlwZWxpbmUnXG5pbXBvcnQgeyBhc3NpZ25EZWVwIH0gZnJvbSAnLi91dGlscydcblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zIGV4dGVuZHMgSW1hZ2VPcHRpb25zLCBRdWFudGl6ZXJPcHRpb25zIHtcbiAgdXNlV29ya2VyOiBib29sZWFuXG4gIEltYWdlQ2xhc3M6IEltYWdlQ2xhc3NcbiAgcXVhbnRpemVyOiBzdHJpbmcgfCBTdGFnZU9wdGlvbnNcbiAgZ2VuZXJhdG9yczogKHN0cmluZyB8IFN0YWdlT3B0aW9ucylbXVxuICBmaWx0ZXJzOiBzdHJpbmdbXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRQcm9jZXNzT3B0aW9ucyAob3B0czogT3B0aW9ucywgb3ZlcnJpZGU/OiBQYXJ0aWFsPFByb2Nlc3NPcHRpb25zPik6IFByb2Nlc3NPcHRpb25zIHtcbiAgbGV0IHsgY29sb3JDb3VudCwgcXVhbnRpemVyLCBnZW5lcmF0b3JzLCBmaWx0ZXJzIH0gPSBvcHRzXG4gIC8vIE1lcmdlIHdpdGggY29tbW9uIHF1YW50aXplciBvcHRpb25zXG4gIGxldCBjb21tb25RdWFudGl6ZXJPcHRzID0geyBjb2xvckNvdW50IH1cbiAgbGV0IHEgPSB0eXBlb2YgcXVhbnRpemVyID09PSAnc3RyaW5nJ1xuICAgID8geyBuYW1lOiBxdWFudGl6ZXIsIG9wdGlvbnM6IHt9IH1cbiAgICA6IHF1YW50aXplclxuICBxLm9wdGlvbnMgPSBhc3NpZ25EZWVwKHt9LCBjb21tb25RdWFudGl6ZXJPcHRzLCBxLm9wdGlvbnMpXG5cbiAgcmV0dXJuIGFzc2lnbkRlZXAoe30sIHtcbiAgICBxdWFudGl6ZXI6IHEsXG4gICAgZ2VuZXJhdG9ycyxcbiAgICBmaWx0ZXJzXG4gIH0sIG92ZXJyaWRlKVxufVxuIiwiaW1wb3J0IHtcbiAgT3B0aW9uc1xufSBmcm9tICcuL29wdGlvbnMnXG5pbXBvcnQge1xuICBDYWxsYmFja1xufSBmcm9tICdAdmlicmFudC90eXBlcydcbmltcG9ydCB7XG4gIEltYWdlQ2xhc3MsXG4gIEltYWdlU291cmNlXG59IGZyb20gJ0B2aWJyYW50L2ltYWdlJ1xuXG5pbXBvcnQge1xuICBGaWx0ZXIsXG4gIFBhbGV0dGVcbn0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5pbXBvcnQgVmlicmFudCBmcm9tICcuLydcbmltcG9ydCB7IGFzc2lnbkRlZXAgfSBmcm9tICcuL3V0aWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWlsZGVyIHtcbiAgcHJpdmF0ZSBfc3JjOiBJbWFnZVNvdXJjZVxuICBwcml2YXRlIF9vcHRzOiBQYXJ0aWFsPE9wdGlvbnM+XG4gIGNvbnN0cnVjdG9yIChzcmM6IEltYWdlU291cmNlLCBvcHRzOiBQYXJ0aWFsPE9wdGlvbnM+ID0ge30pIHtcbiAgICB0aGlzLl9zcmMgPSBzcmNcbiAgICB0aGlzLl9vcHRzID0gYXNzaWduRGVlcCh7fSwgVmlicmFudC5EZWZhdWx0T3B0cywgb3B0cylcbiAgfVxuXG4gIG1heENvbG9yQ291bnQgKG46IG51bWJlcik6IEJ1aWxkZXIge1xuICAgIHRoaXMuX29wdHMuY29sb3JDb3VudCA9IG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbWF4RGltZW5zaW9uIChkOiBudW1iZXIpOiBCdWlsZGVyIHtcbiAgICB0aGlzLl9vcHRzLm1heERpbWVuc2lvbiA9IGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYWRkRmlsdGVyIChuYW1lOiBzdHJpbmcpOiBCdWlsZGVyIHtcbiAgICBpZiAoIXRoaXMuX29wdHMuZmlsdGVycykge1xuICAgICAgdGhpcy5fb3B0cy5maWx0ZXJzID0gW25hbWVdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wdHMuZmlsdGVycy5wdXNoKG5hbWUpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZW1vdmVGaWx0ZXIgKG5hbWU6IHN0cmluZyk6IEJ1aWxkZXIge1xuICAgIGlmICh0aGlzLl9vcHRzLmZpbHRlcnMpIHtcbiAgICAgIGxldCBpID0gdGhpcy5fb3B0cy5maWx0ZXJzLmluZGV4T2YobmFtZSlcbiAgICAgIGlmIChpID4gMCkgdGhpcy5fb3B0cy5maWx0ZXJzLnNwbGljZShpKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY2xlYXJGaWx0ZXJzICgpOiBCdWlsZGVyIHtcbiAgICB0aGlzLl9vcHRzLmZpbHRlcnMgPSBbXVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBxdWFsaXR5IChxOiBudW1iZXIpOiBCdWlsZGVyIHtcbiAgICB0aGlzLl9vcHRzLnF1YWxpdHkgPSBxXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHVzZUltYWdlQ2xhc3MgKGltYWdlQ2xhc3M6IEltYWdlQ2xhc3MpOiBCdWlsZGVyIHtcbiAgICB0aGlzLl9vcHRzLkltYWdlQ2xhc3MgPSBpbWFnZUNsYXNzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHVzZUdlbmVyYXRvciAoZ2VuZXJhdG9yOiBzdHJpbmcsIG9wdGlvbnM/OiBhbnkpOiBCdWlsZGVyIHtcbiAgICBpZiAoIXRoaXMuX29wdHMuZ2VuZXJhdG9ycykgdGhpcy5fb3B0cy5nZW5lcmF0b3JzID0gW11cbiAgICB0aGlzLl9vcHRzLmdlbmVyYXRvcnMucHVzaChvcHRpb25zID8geyBuYW1lOiBnZW5lcmF0b3IsIG9wdGlvbnMgfSA6IGdlbmVyYXRvcilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdXNlUXVhbnRpemVyIChxdWFudGl6ZXI6IHN0cmluZywgb3B0aW9ucz86IGFueSk6IEJ1aWxkZXIge1xuICAgIHRoaXMuX29wdHMucXVhbnRpemVyID0gb3B0aW9ucyA/IHsgbmFtZTogcXVhbnRpemVyLCBvcHRpb25zIH0gOiBxdWFudGl6ZXJcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYnVpbGQgKCk6IFZpYnJhbnQge1xuICAgIHJldHVybiBuZXcgVmlicmFudCh0aGlzLl9zcmMsIHRoaXMuX29wdHMpXG4gIH1cblxuICBnZXRQYWxldHRlIChjYj86IENhbGxiYWNrPFBhbGV0dGU+KTogUHJvbWlzZTxQYWxldHRlPiB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGQoKS5nZXRQYWxldHRlKGNiKVxuICB9XG4gIGdldFN3YXRjaGVzIChjYj86IENhbGxiYWNrPFBhbGV0dGU+KTogUHJvbWlzZTxQYWxldHRlPiB7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGQoKS5nZXRQYWxldHRlKGNiKVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBJbWFnZU9wdGlvbnMsXG4gIEltYWdlRGF0YSBhcyBWaWJyYW50SW1hZ2VEYXRhLFxuICBJbWFnZVNvdXJjZSxcbiAgSW1hZ2VDYWxsYmFjayxcbiAgSW1hZ2VCYXNlXG59IGZyb20gJ0B2aWJyYW50L2ltYWdlJ1xuXG5mdW5jdGlvbiBpc1JlbGF0aXZlVXJsICh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBsZXQgdSA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKVxuICByZXR1cm4gdS5wcm90b2NvbCA9PT0gbG9jYXRpb24ucHJvdG9jb2wgJiZcbiAgICB1Lmhvc3QgPT09IGxvY2F0aW9uLmhvc3QgJiZcbiAgICB1LnBvcnQgPT09IGxvY2F0aW9uLnBvcnRcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JpZ2luIChhOiBzdHJpbmcsIGI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBsZXQgdWEgPSBuZXcgVVJMKGEpXG4gIGxldCB1YiA9IG5ldyBVUkwoYilcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TZWN1cml0eS9TYW1lLW9yaWdpbl9wb2xpY3lcbiAgcmV0dXJuIChcbiAgICB1YS5wcm90b2NvbCA9PT0gdWIucHJvdG9jb2wgJiZcbiAgICB1YS5ob3N0bmFtZSA9PT0gdWIuaG9zdG5hbWUgJiZcbiAgICB1YS5wb3J0ID09PSB1Yi5wb3J0XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJvd3NlckltYWdlIGV4dGVuZHMgSW1hZ2VCYXNlIHtcbiAgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnRcbiAgcHJpdmF0ZSBfY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxuICBwcml2YXRlIF9jb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgcHJpdmF0ZSBfd2lkdGg6IG51bWJlclxuICBwcml2YXRlIF9oZWlnaHQ6IG51bWJlclxuICBwcml2YXRlIF9pbml0Q2FudmFzICgpOiB2b2lkIHtcbiAgICBjb25zdCBpbWcgPSB0aGlzLmltYWdlXG4gICAgY29uc3QgY2FudmFzID0gKHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKVxuICAgIGNvbnN0IGNvbnRleHQgPSAoY2FudmFzLmdldENvbnRleHQoJzJkJykpXG5cbiAgICBpZiAoIWNvbnRleHQpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBjYW52YXMgY29udGV4dCcpXG5cbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dFxuXG4gICAgY2FudmFzLmNsYXNzTmFtZSA9ICdAdmlicmFudC9jYW52YXMnXG4gICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcblxuICAgIHRoaXMuX3dpZHRoID0gY2FudmFzLndpZHRoID0gaW1nLndpZHRoXG4gICAgdGhpcy5faGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHRcblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMClcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKVxuICB9XG4gIGxvYWQgKGltYWdlOiBJbWFnZVNvdXJjZSk6IFByb21pc2U8SW1hZ2VCYXNlPiB7XG4gICAgbGV0IGltZzogSFRNTEltYWdlRWxlbWVudFxuICAgIGxldCBzcmM6IHN0cmluZ1xuICAgIGlmICh0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgICAgc3JjID0gaW1hZ2VcblxuICAgICAgaWYgKCFpc1JlbGF0aXZlVXJsKHNyYykgJiYgIWlzU2FtZU9yaWdpbih3aW5kb3cubG9jYXRpb24uaHJlZiwgc3JjKSkge1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJ1xuICAgICAgfVxuXG4gICAgICBpbWcuc3JjID0gc3JjXG4gICAgfSBlbHNlIGlmIChpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgIGltZyA9IGltYWdlXG4gICAgICBzcmMgPSBpbWFnZS5zcmNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgRXJyb3IoYENhbm5vdCBsb2FkIGJ1ZmZlciBhcyBhbiBpbWFnZSBpbiBicm93c2VyYClcbiAgICAgIClcbiAgICB9XG4gICAgdGhpcy5pbWFnZSA9IGltZ1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPEltYWdlQmFzZT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IG9uSW1hZ2VMb2FkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9pbml0Q2FudmFzKClcbiAgICAgICAgcmVzb2x2ZSh0aGlzKVxuICAgICAgfVxuXG4gICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgIC8vIEFscmVhZHkgbG9hZGVkXG4gICAgICAgIG9uSW1hZ2VMb2FkKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltZy5vbmxvYWQgPSBvbkltYWdlTG9hZFxuICAgICAgICBpbWcub25lcnJvciA9IGUgPT4gcmVqZWN0KG5ldyBFcnJvcihgRmFpbCB0byBsb2FkIGltYWdlOiAke3NyY31gKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGNsZWFyICgpOiB2b2lkIHtcbiAgICB0aGlzLl9jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KVxuICB9XG4gIHVwZGF0ZSAoaW1hZ2VEYXRhOiBWaWJyYW50SW1hZ2VEYXRhKTogdm9pZCB7XG4gICAgdGhpcy5fY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhIGFzIEltYWdlRGF0YSwgMCwgMClcbiAgfVxuICBnZXRXaWR0aCAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGhcbiAgfVxuICBnZXRIZWlnaHQgKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodFxuICB9XG4gIHJlc2l6ZSAodGFyZ2V0V2lkdGg6IG51bWJlciwgdGFyZ2V0SGVpZ2h0OiBudW1iZXIsIHJhdGlvOiBudW1iZXIpOiB2b2lkIHtcbiAgICBsZXQgeyBfY2FudmFzOiBjYW52YXMsIF9jb250ZXh0OiBjb250ZXh0LCBpbWFnZTogaW1nIH0gPSB0aGlzXG5cbiAgICB0aGlzLl93aWR0aCA9IGNhbnZhcy53aWR0aCA9IHRhcmdldFdpZHRoXG4gICAgdGhpcy5faGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IHRhcmdldEhlaWdodFxuXG4gICAgY29udGV4dC5zY2FsZShyYXRpbywgcmF0aW8pXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKVxuICB9XG4gIGdldFBpeGVsQ291bnQgKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoICogdGhpcy5faGVpZ2h0XG4gIH1cbiAgZ2V0SW1hZ2VEYXRhICgpOiBJbWFnZURhdGEge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KVxuICB9XG4gIHJlbW92ZSAoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2NhbnZhcyAmJiB0aGlzLl9jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5fY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY2FudmFzKVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IFZpYnJhbnQgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxuaW1wb3J0IHBpcGVsaW5lIGZyb20gJy4vcGlwZWxpbmUnXG5cblZpYnJhbnQudXNlKHBpcGVsaW5lKVxuXG5leHBvcnQgPSBWaWJyYW50XG4iLCJpbXBvcnQgTU1DUSBmcm9tICdAdmlicmFudC9xdWFudGl6ZXItbW1jcSdcbmltcG9ydCBEZWZhdWx0R2VuZXJhdG9yIGZyb20gJ0B2aWJyYW50L2dlbmVyYXRvci1kZWZhdWx0J1xuXG5pbXBvcnQgeyBCYXNpY1BpcGVsaW5lIH0gZnJvbSAnQHZpYnJhbnQvY29yZS9saWIvcGlwZWxpbmUnXG5cbmNvbnN0IHBpcGVsaW5lID0gbmV3IEJhc2ljUGlwZWxpbmUoKVxuICAuZmlsdGVyLnJlZ2lzdGVyKCdkZWZhdWx0JywgKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIsIGE6IG51bWJlcikgPT5cbiAgICBhID49IDEyNVxuICAgICYmICEociA+IDI1MCAmJiBnID4gMjUwICYmIGIgPiAyNTApXG4gIClcbiAgLnF1YW50aXplci5yZWdpc3RlcignbW1jcScsIE1NQ1EpXG4gIC5nZW5lcmF0b3IucmVnaXN0ZXIoJ2RlZmF1bHQnLCBEZWZhdWx0R2VuZXJhdG9yKVxuXG5leHBvcnQgZGVmYXVsdCBwaXBlbGluZVxuIiwiaW1wb3J0IHsgUXVhbnRpemVyLCBRdWFudGl6ZXJPcHRpb25zIH0gZnJvbSAnQHZpYnJhbnQvcXVhbnRpemVyJ1xuaW1wb3J0IHtcbiAgUGl4ZWxzXG59IGZyb20gJ0B2aWJyYW50L2ltYWdlJ1xuaW1wb3J0IHsgRmlsdGVyLCBTd2F0Y2ggfSBmcm9tICdAdmlicmFudC9jb2xvcidcbmltcG9ydCBWQm94IGZyb20gJy4vdmJveCdcbmltcG9ydCBQUXVldWUgZnJvbSAnLi9wcXVldWUnXG5cbmNvbnN0IGZyYWN0QnlQb3B1bGF0aW9ucyA9IDAuNzVcblxuZnVuY3Rpb24gX3NwbGl0Qm94ZXMgKHBxOiBQUXVldWU8VkJveD4sIHRhcmdldDogbnVtYmVyKTogdm9pZCB7XG4gIGxldCBsYXN0U2l6ZSA9IHBxLnNpemUoKVxuICB3aGlsZSAocHEuc2l6ZSgpIDwgdGFyZ2V0KSB7XG4gICAgbGV0IHZib3ggPSBwcS5wb3AoKVxuXG4gICAgaWYgKHZib3ggJiYgdmJveC5jb3VudCgpID4gMCkge1xuICAgICAgbGV0IFt2Ym94MSwgdmJveDJdID0gdmJveC5zcGxpdCgpXG5cbiAgICAgIHBxLnB1c2godmJveDEpXG4gICAgICBpZiAodmJveDIgJiYgdmJveDIuY291bnQoKSA+IDApIHBxLnB1c2godmJveDIpXG5cbiAgICAgIC8vIE5vIG1vcmUgbmV3IGJveGVzLCBjb252ZXJnZWRcbiAgICAgIGlmIChwcS5zaXplKCkgPT09IGxhc3RTaXplKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0U2l6ZSA9IHBxLnNpemUoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBNTUNRID0gKHBpeGVsczogUGl4ZWxzLCBvcHRzOiBRdWFudGl6ZXJPcHRpb25zKTogQXJyYXk8U3dhdGNoPiA9PiB7XG4gIGlmIChwaXhlbHMubGVuZ3RoID09PSAwIHx8IG9wdHMuY29sb3JDb3VudCA8IDIgfHwgb3B0cy5jb2xvckNvdW50ID4gMjU2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBNTUNRIHBhcmFtZXRlcnMnKVxuICB9XG5cbiAgbGV0IHZib3ggPSBWQm94LmJ1aWxkKHBpeGVscylcbiAgbGV0IGNvbG9yQ291bnQgPSB2Ym94Lmhpc3RvZ3JhbS5jb2xvckNvdW50XG4gIGxldCBwcSA9IG5ldyBQUXVldWU8VkJveD4oKGEsIGIpID0+IGEuY291bnQoKSAtIGIuY291bnQoKSlcblxuICBwcS5wdXNoKHZib3gpXG5cbiAgLy8gZmlyc3Qgc2V0IG9mIGNvbG9ycywgc29ydGVkIGJ5IHBvcHVsYXRpb25cbiAgX3NwbGl0Qm94ZXMocHEsIGZyYWN0QnlQb3B1bGF0aW9ucyAqIG9wdHMuY29sb3JDb3VudClcblxuICAvLyBSZS1vcmRlclxuICBsZXQgcHEyID0gbmV3IFBRdWV1ZTxWQm94PigoYSwgYikgPT4gYS5jb3VudCgpICogYS52b2x1bWUoKSAtIGIuY291bnQoKSAqIGIudm9sdW1lKCkpXG4gIHBxMi5jb250ZW50cyA9IHBxLmNvbnRlbnRzXG5cbiAgLy8gbmV4dCBzZXQgLSBnZW5lcmF0ZSB0aGUgbWVkaWFuIGN1dHMgdXNpbmcgdGhlIChucGl4ICogdm9sKSBzb3J0aW5nLlxuICBfc3BsaXRCb3hlcyhwcTIsIG9wdHMuY29sb3JDb3VudCAtIHBxMi5zaXplKCkpXG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBhY3R1YWwgY29sb3JzXG4gIHJldHVybiBnZW5lcmF0ZVN3YXRjaGVzKHBxMilcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTd2F0Y2hlcyAocHE6IFBRdWV1ZTxWQm94Pikge1xuICBsZXQgc3dhdGNoZXM6IFN3YXRjaFtdID0gW11cbiAgd2hpbGUgKHBxLnNpemUoKSkge1xuICAgIGxldCB2ID0gcHEucG9wKCkhXG4gICAgbGV0IGNvbG9yID0gdi5hdmcoKVxuICAgIGxldCBbciwgZywgYl0gPSBjb2xvclxuICAgIHN3YXRjaGVzLnB1c2gobmV3IFN3YXRjaChjb2xvciwgdi5jb3VudCgpKSlcbiAgfVxuICByZXR1cm4gc3dhdGNoZXNcbn1cblxuZXhwb3J0IGRlZmF1bHQgTU1DUVxuIiwiaW1wb3J0IHsgVmVjMywgRmlsdGVyIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5pbXBvcnQgeyBQaXhlbHMgfSBmcm9tICdAdmlicmFudC9pbWFnZSdcbmltcG9ydCBIaXN0b2dyYW0gZnJvbSAnQHZpYnJhbnQvaW1hZ2UvbGliL2hpc3RvZ3JhbSdcbmV4cG9ydCBpbnRlcmZhY2UgRGltZW5zaW9uIHtcbiAgcjE6IG51bWJlclxuICByMjogbnVtYmVyXG4gIGcxOiBudW1iZXJcbiAgZzI6IG51bWJlclxuICBiMTogbnVtYmVyXG4gIGIyOiBudW1iZXJcbiAgW2Q6IHN0cmluZ106IG51bWJlclxufVxuXG5jb25zdCBTSUdCSVRTID0gNVxuY29uc3QgUlNISUZUID0gOCAtIFNJR0JJVFNcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVkJveCB7XG4gIHN0YXRpYyBidWlsZCAocGl4ZWxzOiBQaXhlbHMpOiBWQm94IHtcbiAgICBsZXQgaCA9IG5ldyBIaXN0b2dyYW0ocGl4ZWxzLCB7IHNpZ0JpdHM6IFNJR0JJVFMgfSlcbiAgICBsZXQgeyBybWluLCBybWF4LCBnbWluLCBnbWF4LCBibWluLCBibWF4IH0gPSBoXG4gICAgcmV0dXJuIG5ldyBWQm94KHJtaW4sIHJtYXgsIGdtaW4sIGdtYXgsIGJtaW4sIGJtYXgsIGgpXG4gIH1cblxuICBkaW1lbnNpb246IERpbWVuc2lvblxuXG4gIHByaXZhdGUgX3ZvbHVtZSA9IC0xXG4gIHByaXZhdGUgX2F2ZzogVmVjMyB8IG51bGxcbiAgcHJpdmF0ZSBfY291bnQgPSAtMVxuXG4gIGNvbnN0cnVjdG9yIChcbiAgICByMTogbnVtYmVyLCByMjogbnVtYmVyLFxuICAgIGcxOiBudW1iZXIsIGcyOiBudW1iZXIsXG4gICAgYjE6IG51bWJlciwgYjI6IG51bWJlcixcbiAgICBwdWJsaWMgaGlzdG9ncmFtOiBIaXN0b2dyYW1cbiAgKSB7XG4gICAgLy8gTk9URTogZGltZW5zaW9uIHdpbGwgYmUgbXV0YXRlZCBieSBzcGxpdCBvcGVyYXRpb24uXG4gICAgLy8gICAgICAgSXQgbXVzdCBiZSBzcGVjaWZpZWQgZXhwbGljaXRseSwgbm90IGZyb20gaGlzdG9ncmFtXG4gICAgdGhpcy5kaW1lbnNpb24gPSB7IHIxLCByMiwgZzEsIGcyLCBiMSwgYjIgfVxuICB9XG5cbiAgaW52YWxpZGF0ZSAoKTogdm9pZCB7XG4gICAgdGhpcy5fdm9sdW1lID0gdGhpcy5fY291bnQgPSAtMVxuICAgIHRoaXMuX2F2ZyA9IG51bGxcbiAgfVxuXG4gIHZvbHVtZSAoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5fdm9sdW1lIDwgMCkge1xuICAgICAgbGV0IHsgcjEsIHIyLCBnMSwgZzIsIGIxLCBiMiB9ID0gdGhpcy5kaW1lbnNpb25cbiAgICAgIHRoaXMuX3ZvbHVtZSA9IChyMiAtIHIxICsgMSkgKiAoZzIgLSBnMSArIDEpICogKGIyIC0gYjEgKyAxKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdm9sdW1lXG4gIH1cblxuICBjb3VudCAoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5fY291bnQgPCAwKSB7XG4gICAgICBsZXQgeyBoaXN0LCBnZXRDb2xvckluZGV4IH0gPSB0aGlzLmhpc3RvZ3JhbVxuICAgICAgbGV0IHsgcjEsIHIyLCBnMSwgZzIsIGIxLCBiMiB9ID0gdGhpcy5kaW1lbnNpb25cbiAgICAgIGxldCBjID0gMFxuXG4gICAgICBmb3IgKGxldCByID0gcjE7IHIgPD0gcjI7IHIrKykge1xuICAgICAgICBmb3IgKGxldCBnID0gZzE7IGcgPD0gZzI7IGcrKykge1xuICAgICAgICAgIGZvciAobGV0IGIgPSBiMTsgYiA8PSBiMjsgYisrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBnZXRDb2xvckluZGV4KHIsIGcsIGIpXG4gICAgICAgICAgICBjICs9IGhpc3RbaW5kZXhdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jb3VudCA9IGNcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NvdW50XG4gIH1cblxuICBjbG9uZSAoKTogVkJveCB7XG4gICAgbGV0IHsgaGlzdG9ncmFtIH0gPSB0aGlzXG4gICAgbGV0IHsgcjEsIHIyLCBnMSwgZzIsIGIxLCBiMiB9ID0gdGhpcy5kaW1lbnNpb25cbiAgICByZXR1cm4gbmV3IFZCb3gocjEsIHIyLCBnMSwgZzIsIGIxLCBiMiwgaGlzdG9ncmFtKVxuICB9XG5cbiAgYXZnICgpOiBWZWMzIHtcbiAgICBpZiAoIXRoaXMuX2F2Zykge1xuICAgICAgbGV0IHsgaGlzdCwgZ2V0Q29sb3JJbmRleCB9ID0gdGhpcy5oaXN0b2dyYW1cbiAgICAgIGxldCB7IHIxLCByMiwgZzEsIGcyLCBiMSwgYjIgfSA9IHRoaXMuZGltZW5zaW9uXG4gICAgICBsZXQgbnRvdCA9IDBcbiAgICAgIGxldCBtdWx0ID0gMSA8PCAoOCAtIFNJR0JJVFMpXG4gICAgICBsZXQgcnN1bTogbnVtYmVyXG4gICAgICBsZXQgZ3N1bTogbnVtYmVyXG4gICAgICBsZXQgYnN1bTogbnVtYmVyXG4gICAgICByc3VtID0gZ3N1bSA9IGJzdW0gPSAwXG5cbiAgICAgIGZvciAobGV0IHIgPSByMTsgciA8PSByMjsgcisrKSB7XG4gICAgICAgIGZvciAobGV0IGcgPSBnMTsgZyA8PSBnMjsgZysrKSB7XG4gICAgICAgICAgZm9yIChsZXQgYiA9IGIxOyBiIDw9IGIyOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYilcbiAgICAgICAgICAgIGxldCBoID0gaGlzdFtpbmRleF1cbiAgICAgICAgICAgIG50b3QgKz0gaFxuICAgICAgICAgICAgcnN1bSArPSAoaCAqIChyICsgMC41KSAqIG11bHQpXG4gICAgICAgICAgICBnc3VtICs9IChoICogKGcgKyAwLjUpICogbXVsdClcbiAgICAgICAgICAgIGJzdW0gKz0gKGggKiAoYiArIDAuNSkgKiBtdWx0KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG50b3QpIHtcbiAgICAgICAgdGhpcy5fYXZnID0gW1xuICAgICAgICAgIH5+KHJzdW0gLyBudG90KSxcbiAgICAgICAgICB+fihnc3VtIC8gbnRvdCksXG4gICAgICAgICAgfn4oYnN1bSAvIG50b3QpXG4gICAgICAgIF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2F2ZyA9IFtcbiAgICAgICAgICB+fihtdWx0ICogKHIxICsgcjIgKyAxKSAvIDIpLFxuICAgICAgICAgIH5+KG11bHQgKiAoZzEgKyBnMiArIDEpIC8gMiksXG4gICAgICAgICAgfn4obXVsdCAqIChiMSArIGIyICsgMSkgLyAyKVxuICAgICAgICBdXG4gICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2F2Z1xuICB9XG5cbiAgY29udGFpbnMgKHJnYjogVmVjMyk6IGJvb2xlYW4ge1xuICAgIGxldCBbciwgZywgYl0gPSByZ2JcbiAgICBsZXQgeyByMSwgcjIsIGcxLCBnMiwgYjEsIGIyIH0gPSB0aGlzLmRpbWVuc2lvblxuICAgIHIgPj49IFJTSElGVFxuICAgIGcgPj49IFJTSElGVFxuICAgIGIgPj49IFJTSElGVFxuXG4gICAgcmV0dXJuIHIgPj0gcjEgJiYgciA8PSByMlxuICAgICAgJiYgZyA+PSBnMSAmJiBnIDw9IGcyXG4gICAgICAmJiBiID49IGIxICYmIGIgPD0gYjJcbiAgfVxuXG4gIHNwbGl0ICgpOiBWQm94W10ge1xuICAgIGxldCB7IGhpc3QsIGdldENvbG9ySW5kZXggfSA9IHRoaXMuaGlzdG9ncmFtXG4gICAgbGV0IHsgcjEsIHIyLCBnMSwgZzIsIGIxLCBiMiB9ID0gdGhpcy5kaW1lbnNpb25cbiAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50KClcbiAgICBpZiAoIWNvdW50KSByZXR1cm4gW11cbiAgICBpZiAoY291bnQgPT09IDEpIHJldHVybiBbdGhpcy5jbG9uZSgpXVxuICAgIGxldCBydyA9IHIyIC0gcjEgKyAxXG4gICAgbGV0IGd3ID0gZzIgLSBnMSArIDFcbiAgICBsZXQgYncgPSBiMiAtIGIxICsgMVxuXG4gICAgbGV0IG1heHcgPSBNYXRoLm1heChydywgZ3csIGJ3KVxuICAgIGxldCBhY2NTdW06IFVpbnQzMkFycmF5IHwgbnVsbCA9IG51bGxcbiAgICBsZXQgc3VtOiBudW1iZXJcbiAgICBsZXQgdG90YWw6IG51bWJlclxuICAgIHN1bSA9IHRvdGFsID0gMFxuXG4gICAgbGV0IG1heGQ6ICdyJyB8ICdnJyB8ICdiJyB8IG51bGwgPSBudWxsXG5cbiAgICBpZiAobWF4dyA9PT0gcncpIHtcbiAgICAgIG1heGQgPSAncidcbiAgICAgIGFjY1N1bSA9IG5ldyBVaW50MzJBcnJheShyMiArIDEpXG4gICAgICBmb3IgKGxldCByID0gcjE7IHIgPD0gcjI7IHIrKykge1xuICAgICAgICBzdW0gPSAwXG4gICAgICAgIGZvciAobGV0IGcgPSBnMTsgZyA8PSBnMjsgZysrKSB7XG4gICAgICAgICAgZm9yIChsZXQgYiA9IGIxOyBiIDw9IGIyOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYilcbiAgICAgICAgICAgIHN1bSArPSBoaXN0W2luZGV4XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b3RhbCArPSBzdW1cbiAgICAgICAgYWNjU3VtW3JdID0gdG90YWxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1heHcgPT09IGd3KSB7XG4gICAgICBtYXhkID0gJ2cnXG4gICAgICBhY2NTdW0gPSBuZXcgVWludDMyQXJyYXkoZzIgKyAxKVxuICAgICAgZm9yIChsZXQgZyA9IGcxOyBnIDw9IGcyOyBnKyspIHtcbiAgICAgICAgc3VtID0gMFxuICAgICAgICBmb3IgKGxldCByID0gcjE7IHIgPD0gcjI7IHIrKykge1xuICAgICAgICAgIGZvciAobGV0IGIgPSBiMTsgYiA8PSBiMjsgYisrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBnZXRDb2xvckluZGV4KHIsIGcsIGIpXG4gICAgICAgICAgICBzdW0gKz0gaGlzdFtpbmRleF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG90YWwgKz0gc3VtXG4gICAgICAgIGFjY1N1bVtnXSA9IHRvdGFsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heGQgPSAnYidcbiAgICAgIGFjY1N1bSA9IG5ldyBVaW50MzJBcnJheShiMiArIDEpXG4gICAgICBmb3IgKGxldCBiID0gYjE7IGIgPD0gYjI7IGIrKykge1xuICAgICAgICBzdW0gPSAwXG4gICAgICAgIGZvciAobGV0IHIgPSByMTsgciA8PSByMjsgcisrKSB7XG4gICAgICAgICAgZm9yIChsZXQgZyA9IGcxOyBnIDw9IGcyOyBnKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYilcbiAgICAgICAgICAgIHN1bSArPSBoaXN0W2luZGV4XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b3RhbCArPSBzdW1cbiAgICAgICAgYWNjU3VtW2JdID0gdG90YWxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc3BsaXRQb2ludCA9IC0xXG4gICAgbGV0IHJldmVyc2VTdW0gPSBuZXcgVWludDMyQXJyYXkoYWNjU3VtLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjY1N1bS5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGQgPSBhY2NTdW1baV1cbiAgICAgIGlmIChzcGxpdFBvaW50IDwgMCAmJiBkID4gdG90YWwgLyAyKSBzcGxpdFBvaW50ID0gaVxuICAgICAgcmV2ZXJzZVN1bVtpXSA9IHRvdGFsIC0gZFxuICAgIH1cblxuICAgIGxldCB2Ym94ID0gdGhpc1xuXG4gICAgZnVuY3Rpb24gZG9DdXQgKGQ6IHN0cmluZyk6IFZCb3hbXSB7XG4gICAgICBsZXQgZGltMSA9IGQgKyAnMSdcbiAgICAgIGxldCBkaW0yID0gZCArICcyJ1xuICAgICAgbGV0IGQxID0gdmJveC5kaW1lbnNpb25bZGltMV1cbiAgICAgIGxldCBkMiA9IHZib3guZGltZW5zaW9uW2RpbTJdXG4gICAgICBsZXQgdmJveDEgPSB2Ym94LmNsb25lKClcbiAgICAgIGxldCB2Ym94MiA9IHZib3guY2xvbmUoKVxuICAgICAgbGV0IGxlZnQgPSBzcGxpdFBvaW50IC0gZDFcbiAgICAgIGxldCByaWdodCA9IGQyIC0gc3BsaXRQb2ludFxuICAgICAgaWYgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICAgICAgZDIgPSBNYXRoLm1pbihkMiAtIDEsIH5+KHNwbGl0UG9pbnQgKyByaWdodCAvIDIpKVxuICAgICAgICBkMiA9IE1hdGgubWF4KDAsIGQyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZDIgPSBNYXRoLm1heChkMSwgfn4oc3BsaXRQb2ludCAtIDEgLSBsZWZ0IC8gMikpXG4gICAgICAgIGQyID0gTWF0aC5taW4odmJveC5kaW1lbnNpb25bZGltMl0sIGQyKVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoIWFjY1N1bSFbZDJdKSBkMisrXG5cbiAgICAgIGxldCBjMiA9IHJldmVyc2VTdW1bZDJdXG4gICAgICB3aGlsZSAoIWMyICYmIGFjY1N1bSFbZDIgLSAxXSkgYzIgPSByZXZlcnNlU3VtWy0tZDJdXG5cbiAgICAgIHZib3gxLmRpbWVuc2lvbltkaW0yXSA9IGQyXG4gICAgICB2Ym94Mi5kaW1lbnNpb25bZGltMV0gPSBkMiArIDFcblxuICAgICAgcmV0dXJuIFt2Ym94MSwgdmJveDJdXG4gICAgfVxuXG4gICAgcmV0dXJuIGRvQ3V0KG1heGQpXG4gIH1cblxufVxuIiwiaW1wb3J0IHsgUGl4ZWxzIH0gZnJvbSAnLi9pbmRleCdcblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b2dyYW1PcHRpb25zIHtcbiAgc2lnQml0czogbnVtYmVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpc3RvZ3JhbSB7XG4gIGJtaW46IG51bWJlclxuICBibWF4OiBudW1iZXJcbiAgZ21pbjogbnVtYmVyXG4gIGdtYXg6IG51bWJlclxuICBybWluOiBudW1iZXJcbiAgcm1heDogbnVtYmVyXG4gIGhpc3Q6IFVpbnQzMkFycmF5XG4gIHByaXZhdGUgX2NvbG9yQ291bnQ6IG51bWJlclxuICBnZXQgY29sb3JDb3VudCAoKSB7IHJldHVybiB0aGlzLl9jb2xvckNvdW50IH1cbiAgZ2V0Q29sb3JJbmRleDogKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpID0+IG51bWJlclxuICBjb25zdHJ1Y3RvciAocHVibGljIHBpeGVsczogUGl4ZWxzLCBwdWJsaWMgb3B0czogSGlzdG9ncmFtT3B0aW9ucykge1xuICAgIGNvbnN0IHsgc2lnQml0cyB9ID0gb3B0c1xuICAgIGNvbnN0IGdldENvbG9ySW5kZXggPSAocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcikgPT5cbiAgICAgIChyIDw8ICgyICogc2lnQml0cykpICsgKGcgPDwgc2lnQml0cykgKyBiXG5cbiAgICB0aGlzLmdldENvbG9ySW5kZXggPSBnZXRDb2xvckluZGV4XG5cbiAgICBjb25zdCByc2hpZnQgPSA4IC0gc2lnQml0c1xuICAgIGNvbnN0IGhuID0gMSA8PCAoMyAqIHNpZ0JpdHMpXG4gICAgbGV0IGhpc3QgPSBuZXcgVWludDMyQXJyYXkoaG4pXG4gICAgbGV0IHJtYXg6IG51bWJlclxuICAgIGxldCBybWluOiBudW1iZXJcbiAgICBsZXQgZ21heDogbnVtYmVyXG4gICAgbGV0IGdtaW46IG51bWJlclxuICAgIGxldCBibWF4OiBudW1iZXJcbiAgICBsZXQgYm1pbjogbnVtYmVyXG4gICAgbGV0IHI6IG51bWJlclxuICAgIGxldCBnOiBudW1iZXJcbiAgICBsZXQgYjogbnVtYmVyXG4gICAgbGV0IGE6IG51bWJlclxuICAgIHJtYXggPSBnbWF4ID0gYm1heCA9IDBcbiAgICBybWluID0gZ21pbiA9IGJtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgbGV0IG4gPSBwaXhlbHMubGVuZ3RoIC8gNFxuICAgIGxldCBpID0gMFxuXG4gICAgd2hpbGUgKGkgPCBuKSB7XG5cbiAgICAgIGxldCBvZmZzZXQgPSBpICogNFxuICAgICAgaSsrXG4gICAgICByID0gcGl4ZWxzW29mZnNldCArIDBdXG4gICAgICBnID0gcGl4ZWxzW29mZnNldCArIDFdXG4gICAgICBiID0gcGl4ZWxzW29mZnNldCArIDJdXG4gICAgICBhID0gcGl4ZWxzW29mZnNldCArIDNdXG5cbiAgICAgIC8vIElnbm9yZWQgcGl4ZWxzJyBhbHBoYSBpcyBtYXJrZWQgYXMgMCBpbiBmaWx0ZXJpbmcgc3RhZ2VcbiAgICAgIGlmIChhID09PSAwKSBjb250aW51ZVxuXG4gICAgICByID0gciA+PiByc2hpZnRcbiAgICAgIGcgPSBnID4+IHJzaGlmdFxuICAgICAgYiA9IGIgPj4gcnNoaWZ0XG5cbiAgICAgIGxldCBpbmRleCA9IGdldENvbG9ySW5kZXgociwgZywgYilcbiAgICAgIGhpc3RbaW5kZXhdICs9IDFcblxuICAgICAgaWYgKHIgPiBybWF4KSBybWF4ID0gclxuICAgICAgaWYgKHIgPCBybWluKSBybWluID0gclxuICAgICAgaWYgKGcgPiBnbWF4KSBnbWF4ID0gZ1xuICAgICAgaWYgKGcgPCBnbWluKSBnbWluID0gZ1xuICAgICAgaWYgKGIgPiBibWF4KSBibWF4ID0gYlxuICAgICAgaWYgKGIgPCBibWluKSBibWluID0gYlxuICAgIH1cbiAgICB0aGlzLl9jb2xvckNvdW50ID0gaGlzdC5yZWR1Y2UoKHRvdGFsLCBjKSA9PiBjID4gMCA/IHRvdGFsICsgMSA6IHRvdGFsLCAwKVxuICAgIHRoaXMuaGlzdCA9IGhpc3RcbiAgICB0aGlzLnJtYXggPSBybWF4XG4gICAgdGhpcy5ybWluID0gcm1pblxuICAgIHRoaXMuZ21heCA9IGdtYXhcbiAgICB0aGlzLmdtaW4gPSBnbWluXG4gICAgdGhpcy5ibWF4ID0gYm1heFxuICAgIHRoaXMuYm1pbiA9IGJtaW5cbiAgfVxufVxuIiwiZXhwb3J0IGludGVyZmFjZSBQUXVldWVDb21wYXJhdG9yPFQ+IHtcbiAgKGE6IFQsIGI6IFQpOiBudW1iZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUFF1ZXVlPFQ+IHtcbiAgY29udGVudHM6IFRbXVxuICBwcml2YXRlIF9zb3J0ZWQ6IGJvb2xlYW5cbiAgcHJpdmF0ZSBfY29tcGFyYXRvcjogUFF1ZXVlQ29tcGFyYXRvcjxUPlxuICBwcml2YXRlIF9zb3J0ICgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgICAgdGhpcy5jb250ZW50cy5zb3J0KHRoaXMuX2NvbXBhcmF0b3IpXG4gICAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IgKGNvbXBhcmF0b3I6IFBRdWV1ZUNvbXBhcmF0b3I8VD4pIHtcbiAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvclxuICAgIHRoaXMuY29udGVudHMgPSBbXVxuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlXG4gIH1cblxuICBwdXNoIChpdGVtOiBUKTogdm9pZCB7XG4gICAgdGhpcy5jb250ZW50cy5wdXNoKGl0ZW0pXG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2VcbiAgfVxuXG4gIHBlZWsgKGluZGV4PzogbnVtYmVyKTogVCB7XG4gICAgdGhpcy5fc29ydCgpXG4gICAgaW5kZXggPSB0eXBlb2YgaW5kZXggPT09ICdudW1iZXInID8gaW5kZXggOiB0aGlzLmNvbnRlbnRzLmxlbmd0aCAtIDFcbiAgICByZXR1cm4gdGhpcy5jb250ZW50c1tpbmRleF1cbiAgfVxuXG4gIHBvcCAoKSB7XG4gICAgdGhpcy5fc29ydCgpXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHMucG9wKClcbiAgfVxuXG4gIHNpemUgKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudHMubGVuZ3RoXG4gIH1cblxuICBtYXA8VT4gKG1hcHBlcjogKGl0ZW06IFQsIGluZGV4OiBudW1iZXIpID0+IGFueSk6IFVbXSB7XG4gICAgdGhpcy5fc29ydCgpXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHMubWFwKG1hcHBlcilcbiAgfVxufVxuIiwiaW1wb3J0IHsgU3dhdGNoLCBQYWxldHRlIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5pbXBvcnQgeyBHZW5lcmF0b3IgfSBmcm9tICdAdmlicmFudC9nZW5lcmF0b3InXG5pbXBvcnQgeyBoc2xUb1JnYiB9IGZyb20gJ0B2aWJyYW50L2NvbG9yL2xpYi9jb252ZXJ0ZXInXG5cbmludGVyZmFjZSBEZWZhdWx0R2VuZXJhdG9yT3B0aW9ucyB7XG4gIHRhcmdldERhcmtMdW1hOiBudW1iZXIsXG4gIG1heERhcmtMdW1hOiBudW1iZXIsXG4gIG1pbkxpZ2h0THVtYTogbnVtYmVyLFxuICB0YXJnZXRMaWdodEx1bWE6IG51bWJlcixcbiAgbWluTm9ybWFsTHVtYTogbnVtYmVyLFxuICB0YXJnZXROb3JtYWxMdW1hOiBudW1iZXIsXG4gIG1heE5vcm1hbEx1bWE6IG51bWJlcixcbiAgdGFyZ2V0TXV0ZXNTYXR1cmF0aW9uOiBudW1iZXIsXG4gIG1heE11dGVzU2F0dXJhdGlvbjogbnVtYmVyLFxuICB0YXJnZXRWaWJyYW50U2F0dXJhdGlvbjogbnVtYmVyLFxuICBtaW5WaWJyYW50U2F0dXJhdGlvbjogbnVtYmVyLFxuICB3ZWlnaHRTYXR1cmF0aW9uOiBudW1iZXIsXG4gIHdlaWdodEx1bWE6IG51bWJlcixcbiAgd2VpZ2h0UG9wdWxhdGlvbjogbnVtYmVyXG59XG5cbmNvbnN0IERlZmF1bHRPcHRzOiBEZWZhdWx0R2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgdGFyZ2V0RGFya0x1bWE6IDAuMjYsXG4gIG1heERhcmtMdW1hOiAwLjQ1LFxuICBtaW5MaWdodEx1bWE6IDAuNTUsXG4gIHRhcmdldExpZ2h0THVtYTogMC43NCxcbiAgbWluTm9ybWFsTHVtYTogMC4zLFxuICB0YXJnZXROb3JtYWxMdW1hOiAwLjUsXG4gIG1heE5vcm1hbEx1bWE6IDAuNyxcbiAgdGFyZ2V0TXV0ZXNTYXR1cmF0aW9uOiAwLjMsXG4gIG1heE11dGVzU2F0dXJhdGlvbjogMC40LFxuICB0YXJnZXRWaWJyYW50U2F0dXJhdGlvbjogMS4wLFxuICBtaW5WaWJyYW50U2F0dXJhdGlvbjogMC4zNSxcbiAgd2VpZ2h0U2F0dXJhdGlvbjogMyxcbiAgd2VpZ2h0THVtYTogNi41LFxuICB3ZWlnaHRQb3B1bGF0aW9uOiAwLjVcbn1cblxuZnVuY3Rpb24gX2ZpbmRNYXhQb3B1bGF0aW9uIChzd2F0Y2hlczogQXJyYXk8U3dhdGNoPik6IG51bWJlciB7XG4gIGxldCBwID0gMFxuXG4gIHN3YXRjaGVzLmZvckVhY2goKHMpID0+IHtcbiAgICBwID0gTWF0aC5tYXgocCwgcy5wb3B1bGF0aW9uKVxuICB9KVxuXG4gIHJldHVybiBwXG59XG5cbmZ1bmN0aW9uIF9pc0FscmVhZHlTZWxlY3RlZCAocGFsZXR0ZTogUGFsZXR0ZSwgczogU3dhdGNoKTogYm9vbGVhbiB7XG4gIHJldHVybiBwYWxldHRlLlZpYnJhbnQgPT09IHNcbiAgICB8fCBwYWxldHRlLkRhcmtWaWJyYW50ID09PSBzXG4gICAgfHwgcGFsZXR0ZS5MaWdodFZpYnJhbnQgPT09IHNcbiAgICB8fCBwYWxldHRlLk11dGVkID09PSBzXG4gICAgfHwgcGFsZXR0ZS5EYXJrTXV0ZWQgPT09IHNcbiAgICB8fCBwYWxldHRlLkxpZ2h0TXV0ZWQgPT09IHNcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNvbXBhcmlzb25WYWx1ZSAoXG4gIHNhdHVyYXRpb246IG51bWJlciwgdGFyZ2V0U2F0dXJhdGlvbjogbnVtYmVyLFxuICBsdW1hOiBudW1iZXIsIHRhcmdldEx1bWE6IG51bWJlcixcbiAgcG9wdWxhdGlvbjogbnVtYmVyLCBtYXhQb3B1bGF0aW9uOiBudW1iZXIsIG9wdHM6IERlZmF1bHRHZW5lcmF0b3JPcHRpb25zKTogbnVtYmVyIHtcblxuICBmdW5jdGlvbiB3ZWlnaHRlZE1lYW4gKC4uLnZhbHVlczogbnVtYmVyW10pIHtcbiAgICBsZXQgc3VtID0gMFxuICAgIGxldCB3ZWlnaHRTdW0gPSAwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1tpXVxuICAgICAgbGV0IHdlaWdodCA9IHZhbHVlc1tpICsgMV1cbiAgICAgIHN1bSArPSB2YWx1ZSAqIHdlaWdodFxuICAgICAgd2VpZ2h0U3VtICs9IHdlaWdodFxuICAgIH1cblxuICAgIHJldHVybiBzdW0gLyB3ZWlnaHRTdW1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludmVydERpZmYgKHZhbHVlOiBudW1iZXIsIHRhcmdldFZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiAxIC0gTWF0aC5hYnModmFsdWUgLSB0YXJnZXRWYWx1ZSlcbiAgfVxuXG4gIHJldHVybiB3ZWlnaHRlZE1lYW4oXG4gICAgaW52ZXJ0RGlmZihzYXR1cmF0aW9uLCB0YXJnZXRTYXR1cmF0aW9uKSwgb3B0cy53ZWlnaHRTYXR1cmF0aW9uLFxuICAgIGludmVydERpZmYobHVtYSwgdGFyZ2V0THVtYSksIG9wdHMud2VpZ2h0THVtYSxcbiAgICBwb3B1bGF0aW9uIC8gbWF4UG9wdWxhdGlvbiwgb3B0cy53ZWlnaHRQb3B1bGF0aW9uXG4gIClcblxufVxuXG5mdW5jdGlvbiBfZmluZENvbG9yVmFyaWF0aW9uIChwYWxldHRlOiBQYWxldHRlLCBzd2F0Y2hlczogQXJyYXk8U3dhdGNoPiwgbWF4UG9wdWxhdGlvbjogbnVtYmVyLFxuICB0YXJnZXRMdW1hOiBudW1iZXIsXG4gIG1pbkx1bWE6IG51bWJlcixcbiAgbWF4THVtYTogbnVtYmVyLFxuICB0YXJnZXRTYXR1cmF0aW9uOiBudW1iZXIsXG4gIG1pblNhdHVyYXRpb246IG51bWJlcixcbiAgbWF4U2F0dXJhdGlvbjogbnVtYmVyLFxuICBvcHRzOiBEZWZhdWx0R2VuZXJhdG9yT3B0aW9ucyk6IFN3YXRjaCB8IG51bGwge1xuXG4gIGxldCBtYXg6IFN3YXRjaCB8IG51bGwgPSBudWxsXG4gIGxldCBtYXhWYWx1ZSA9IDBcblxuICBzd2F0Y2hlcy5mb3JFYWNoKChzd2F0Y2gpID0+IHtcbiAgICBsZXQgWywgcywgbF0gPSBzd2F0Y2guaHNsXG5cbiAgICBpZiAocyA+PSBtaW5TYXR1cmF0aW9uICYmIHMgPD0gbWF4U2F0dXJhdGlvblxuICAgICAgJiYgbCA+PSBtaW5MdW1hICYmIGwgPD0gbWF4THVtYVxuICAgICAgJiYgIV9pc0FscmVhZHlTZWxlY3RlZChwYWxldHRlLCBzd2F0Y2gpXG4gICAgKSB7XG4gICAgICBsZXQgdmFsdWUgPSBfY3JlYXRlQ29tcGFyaXNvblZhbHVlKHMsIHRhcmdldFNhdHVyYXRpb24sIGwsIHRhcmdldEx1bWEsIHN3YXRjaC5wb3B1bGF0aW9uLCBtYXhQb3B1bGF0aW9uLCBvcHRzKVxuXG4gICAgICBpZiAobWF4ID09PSBudWxsIHx8IHZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgbWF4ID0gc3dhdGNoXG4gICAgICAgIG1heFZhbHVlID0gdmFsdWVcbiAgICAgIH1cblxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbWF4XG59XG5cbmZ1bmN0aW9uIF9nZW5lcmF0ZVZhcmlhdGlvbkNvbG9ycyAoc3dhdGNoZXM6IEFycmF5PFN3YXRjaD4sIG1heFBvcHVsYXRpb246IG51bWJlciwgb3B0czogRGVmYXVsdEdlbmVyYXRvck9wdGlvbnMpOiBQYWxldHRlIHtcbiAgbGV0IHBhbGV0dGU6IFBhbGV0dGUgPSB7XG4gICAgVmlicmFudDogbnVsbCxcbiAgICBEYXJrVmlicmFudDogbnVsbCxcbiAgICBMaWdodFZpYnJhbnQ6IG51bGwsXG4gICAgTXV0ZWQ6IG51bGwsXG4gICAgRGFya011dGVkOiBudWxsLFxuICAgIExpZ2h0TXV0ZWQ6IG51bGxcbiAgfVxuICAvLyBtVmlicmFudFN3YXRjaCA9IGZpbmRDb2xvcihUQVJHRVRfTk9STUFMX0xVTUEsIE1JTl9OT1JNQUxfTFVNQSwgTUFYX05PUk1BTF9MVU1BLFxuICAvLyAgICAgVEFSR0VUX1ZJQlJBTlRfU0FUVVJBVElPTiwgTUlOX1ZJQlJBTlRfU0FUVVJBVElPTiwgMWYpXG4gIHBhbGV0dGUuVmlicmFudCA9IF9maW5kQ29sb3JWYXJpYXRpb24ocGFsZXR0ZSwgc3dhdGNoZXMsIG1heFBvcHVsYXRpb24sXG4gICAgb3B0cy50YXJnZXROb3JtYWxMdW1hLFxuICAgIG9wdHMubWluTm9ybWFsTHVtYSxcbiAgICBvcHRzLm1heE5vcm1hbEx1bWEsXG4gICAgb3B0cy50YXJnZXRWaWJyYW50U2F0dXJhdGlvbixcbiAgICBvcHRzLm1pblZpYnJhbnRTYXR1cmF0aW9uLFxuICAgIDEsXG4gICAgb3B0c1xuICApXG4gIC8vIG1MaWdodFZpYnJhbnRTd2F0Y2ggPSBmaW5kQ29sb3IoVEFSR0VUX0xJR0hUX0xVTUEsIE1JTl9MSUdIVF9MVU1BLCAxZixcbiAgLy8gICAgIFRBUkdFVF9WSUJSQU5UX1NBVFVSQVRJT04sIE1JTl9WSUJSQU5UX1NBVFVSQVRJT04sIDFmKVxuICBwYWxldHRlLkxpZ2h0VmlicmFudCA9IF9maW5kQ29sb3JWYXJpYXRpb24ocGFsZXR0ZSwgc3dhdGNoZXMsIG1heFBvcHVsYXRpb24sXG4gICAgb3B0cy50YXJnZXRMaWdodEx1bWEsXG4gICAgb3B0cy5taW5MaWdodEx1bWEsXG4gICAgMSxcbiAgICBvcHRzLnRhcmdldFZpYnJhbnRTYXR1cmF0aW9uLFxuICAgIG9wdHMubWluVmlicmFudFNhdHVyYXRpb24sXG4gICAgMSxcbiAgICBvcHRzXG4gIClcbiAgLy8gbURhcmtWaWJyYW50U3dhdGNoID0gZmluZENvbG9yKFRBUkdFVF9EQVJLX0xVTUEsIDBmLCBNQVhfREFSS19MVU1BLFxuICAvLyAgICAgVEFSR0VUX1ZJQlJBTlRfU0FUVVJBVElPTiwgTUlOX1ZJQlJBTlRfU0FUVVJBVElPTiwgMWYpXG4gIHBhbGV0dGUuRGFya1ZpYnJhbnQgPSBfZmluZENvbG9yVmFyaWF0aW9uKHBhbGV0dGUsIHN3YXRjaGVzLCBtYXhQb3B1bGF0aW9uLFxuICAgIG9wdHMudGFyZ2V0RGFya0x1bWEsXG4gICAgMCxcbiAgICBvcHRzLm1heERhcmtMdW1hLFxuICAgIG9wdHMudGFyZ2V0VmlicmFudFNhdHVyYXRpb24sXG4gICAgb3B0cy5taW5WaWJyYW50U2F0dXJhdGlvbixcbiAgICAxLFxuICAgIG9wdHNcbiAgKVxuICAvLyBtTXV0ZWRTd2F0Y2ggPSBmaW5kQ29sb3IoVEFSR0VUX05PUk1BTF9MVU1BLCBNSU5fTk9STUFMX0xVTUEsIE1BWF9OT1JNQUxfTFVNQSxcbiAgLy8gICAgIFRBUkdFVF9NVVRFRF9TQVRVUkFUSU9OLCAwZiwgTUFYX01VVEVEX1NBVFVSQVRJT04pXG4gIHBhbGV0dGUuTXV0ZWQgPSBfZmluZENvbG9yVmFyaWF0aW9uKHBhbGV0dGUsIHN3YXRjaGVzLCBtYXhQb3B1bGF0aW9uLFxuICAgIG9wdHMudGFyZ2V0Tm9ybWFsTHVtYSxcbiAgICBvcHRzLm1pbk5vcm1hbEx1bWEsXG4gICAgb3B0cy5tYXhOb3JtYWxMdW1hLFxuICAgIG9wdHMudGFyZ2V0TXV0ZXNTYXR1cmF0aW9uLFxuICAgIDAsXG4gICAgb3B0cy5tYXhNdXRlc1NhdHVyYXRpb24sXG4gICAgb3B0c1xuICApXG4gIC8vIG1MaWdodE11dGVkQ29sb3IgPSBmaW5kQ29sb3IoVEFSR0VUX0xJR0hUX0xVTUEsIE1JTl9MSUdIVF9MVU1BLCAxZixcbiAgLy8gICAgIFRBUkdFVF9NVVRFRF9TQVRVUkFUSU9OLCAwZiwgTUFYX01VVEVEX1NBVFVSQVRJT04pXG4gIHBhbGV0dGUuTGlnaHRNdXRlZCA9IF9maW5kQ29sb3JWYXJpYXRpb24ocGFsZXR0ZSwgc3dhdGNoZXMsIG1heFBvcHVsYXRpb24sXG4gICAgb3B0cy50YXJnZXRMaWdodEx1bWEsXG4gICAgb3B0cy5taW5MaWdodEx1bWEsXG4gICAgMSxcbiAgICBvcHRzLnRhcmdldE11dGVzU2F0dXJhdGlvbixcbiAgICAwLFxuICAgIG9wdHMubWF4TXV0ZXNTYXR1cmF0aW9uLFxuICAgIG9wdHNcbiAgKVxuICAvLyBtRGFya011dGVkU3dhdGNoID0gZmluZENvbG9yKFRBUkdFVF9EQVJLX0xVTUEsIDBmLCBNQVhfREFSS19MVU1BLFxuICAvLyAgICAgVEFSR0VUX01VVEVEX1NBVFVSQVRJT04sIDBmLCBNQVhfTVVURURfU0FUVVJBVElPTilcbiAgcGFsZXR0ZS5EYXJrTXV0ZWQgPSBfZmluZENvbG9yVmFyaWF0aW9uKHBhbGV0dGUsIHN3YXRjaGVzLCBtYXhQb3B1bGF0aW9uLFxuICAgIG9wdHMudGFyZ2V0RGFya0x1bWEsXG4gICAgMCxcbiAgICBvcHRzLm1heERhcmtMdW1hLFxuICAgIG9wdHMudGFyZ2V0TXV0ZXNTYXR1cmF0aW9uLFxuICAgIDAsXG4gICAgb3B0cy5tYXhNdXRlc1NhdHVyYXRpb24sXG4gICAgb3B0c1xuICApXG4gIHJldHVybiBwYWxldHRlXG59XG5cbmZ1bmN0aW9uIF9nZW5lcmF0ZUVtcHR5U3dhdGNoZXMgKHBhbGV0dGU6IFBhbGV0dGUsIG1heFBvcHVsYXRpb246IG51bWJlciwgb3B0czogRGVmYXVsdEdlbmVyYXRvck9wdGlvbnMpOiB2b2lkIHtcbiAgaWYgKCFwYWxldHRlLlZpYnJhbnQgJiYgIXBhbGV0dGUuRGFya1ZpYnJhbnQgJiYgIXBhbGV0dGUuTGlnaHRWaWJyYW50KSB7XG4gICAgaWYgKCFwYWxldHRlLkRhcmtWaWJyYW50ICYmIHBhbGV0dGUuRGFya011dGVkKSB7XG4gICAgICBsZXQgW2gsIHMsIGxdID0gcGFsZXR0ZS5EYXJrTXV0ZWQuaHNsXG4gICAgICBsID0gb3B0cy50YXJnZXREYXJrTHVtYVxuICAgICAgcGFsZXR0ZS5EYXJrVmlicmFudCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gICAgfVxuICAgIGlmICghcGFsZXR0ZS5MaWdodFZpYnJhbnQgJiYgcGFsZXR0ZS5MaWdodE11dGVkKSB7XG4gICAgICBsZXQgW2gsIHMsIGxdID0gcGFsZXR0ZS5MaWdodE11dGVkLmhzbFxuICAgICAgbCA9IG9wdHMudGFyZ2V0RGFya0x1bWFcbiAgICAgIHBhbGV0dGUuRGFya1ZpYnJhbnQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICAgIH1cbiAgfVxuICBpZiAoIXBhbGV0dGUuVmlicmFudCAmJiBwYWxldHRlLkRhcmtWaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuRGFya1ZpYnJhbnQuaHNsXG4gICAgbCA9IG9wdHMudGFyZ2V0Tm9ybWFsTHVtYVxuICAgIHBhbGV0dGUuVmlicmFudCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gIH0gZWxzZSBpZiAoIXBhbGV0dGUuVmlicmFudCAmJiBwYWxldHRlLkxpZ2h0VmlicmFudCkge1xuICAgIGxldCBbaCwgcywgbF0gPSBwYWxldHRlLkxpZ2h0VmlicmFudC5oc2xcbiAgICBsID0gb3B0cy50YXJnZXROb3JtYWxMdW1hXG4gICAgcGFsZXR0ZS5WaWJyYW50ID0gbmV3IFN3YXRjaChoc2xUb1JnYihoLCBzLCBsKSwgMClcbiAgfVxuICBpZiAoIXBhbGV0dGUuRGFya1ZpYnJhbnQgJiYgcGFsZXR0ZS5WaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuVmlicmFudC5oc2xcbiAgICBsID0gb3B0cy50YXJnZXREYXJrTHVtYVxuICAgIHBhbGV0dGUuRGFya1ZpYnJhbnQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICB9XG4gIGlmICghcGFsZXR0ZS5MaWdodFZpYnJhbnQgJiYgcGFsZXR0ZS5WaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuVmlicmFudC5oc2xcbiAgICBsID0gb3B0cy50YXJnZXRMaWdodEx1bWFcbiAgICBwYWxldHRlLkxpZ2h0VmlicmFudCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gIH1cbiAgaWYgKCFwYWxldHRlLk11dGVkICYmIHBhbGV0dGUuVmlicmFudCkge1xuICAgIGxldCBbaCwgcywgbF0gPSBwYWxldHRlLlZpYnJhbnQuaHNsXG4gICAgbCA9IG9wdHMudGFyZ2V0TXV0ZXNTYXR1cmF0aW9uXG4gICAgcGFsZXR0ZS5NdXRlZCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gIH1cbiAgaWYgKCFwYWxldHRlLkRhcmtNdXRlZCAmJiBwYWxldHRlLkRhcmtWaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuRGFya1ZpYnJhbnQuaHNsXG4gICAgbCA9IG9wdHMudGFyZ2V0TXV0ZXNTYXR1cmF0aW9uXG4gICAgcGFsZXR0ZS5EYXJrTXV0ZWQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICB9XG4gIGlmICghcGFsZXR0ZS5MaWdodE11dGVkICYmIHBhbGV0dGUuTGlnaHRWaWJyYW50KSB7XG4gICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuTGlnaHRWaWJyYW50LmhzbFxuICAgIGwgPSBvcHRzLnRhcmdldE11dGVzU2F0dXJhdGlvblxuICAgIHBhbGV0dGUuTGlnaHRNdXRlZCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gIH1cbn1cblxuY29uc3QgRGVmYXVsdEdlbmVyYXRvcjogR2VuZXJhdG9yID0gKHN3YXRjaGVzOiBBcnJheTxTd2F0Y2g+LCBvcHRzPzogRGVmYXVsdEdlbmVyYXRvck9wdGlvbnMpOiBQYWxldHRlID0+IHtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIERlZmF1bHRPcHRzLCBvcHRzKVxuICBsZXQgbWF4UG9wdWxhdGlvbiA9IF9maW5kTWF4UG9wdWxhdGlvbihzd2F0Y2hlcylcblxuICBsZXQgcGFsZXR0ZSA9IF9nZW5lcmF0ZVZhcmlhdGlvbkNvbG9ycyhzd2F0Y2hlcywgbWF4UG9wdWxhdGlvbiwgb3B0cylcbiAgX2dlbmVyYXRlRW1wdHlTd2F0Y2hlcyhwYWxldHRlLCBtYXhQb3B1bGF0aW9uLCBvcHRzKVxuXG4gIHJldHVybiBwYWxldHRlXG59XG5cbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRHZW5lcmF0b3JcbiIsImltcG9ydCB7IEltYWdlRGF0YSwgYXBwbHlGaWx0ZXJzIH0gZnJvbSAnQHZpYnJhbnQvaW1hZ2UnXG5pbXBvcnQgeyBRdWFudGl6ZXIgfSBmcm9tICdAdmlicmFudC9xdWFudGl6ZXInXG5pbXBvcnQgeyBHZW5lcmF0b3IgfSBmcm9tICdAdmlicmFudC9nZW5lcmF0b3InXG5pbXBvcnQgeyBQYWxldHRlLCBTd2F0Y2gsIEZpbHRlciB9IGZyb20gJ0B2aWJyYW50L2NvbG9yJ1xuXG5leHBvcnQgY2xhc3MgU3RhZ2U8VD4ge1xuICBwcml2YXRlIF9tYXA6IHsgW25hbWU6IHN0cmluZ106IFQgfSA9IHt9XG4gIGNvbnN0cnVjdG9yIChwcm90ZWN0ZWQgcGlwZWxpbmU6IEJhc2ljUGlwZWxpbmUpIHsgfVxuICBuYW1lcyAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX21hcClcbiAgfVxuICBoYXMgKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiAhIXRoaXMuX21hcFtuYW1lXVxuICB9XG4gIGdldCAobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcFtuYW1lXVxuICB9XG4gIHJlZ2lzdGVyIChuYW1lOiBzdHJpbmcsIHN0YWdlRm46IFQpIHtcbiAgICB0aGlzLl9tYXBbbmFtZV0gPSBzdGFnZUZuXG4gICAgcmV0dXJuIHRoaXMucGlwZWxpbmVcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NSZXN1bHQge1xuICBjb2xvcnM6IFN3YXRjaFtdXG4gIHBhbGV0dGVzOiB7IFtuYW1lOiBzdHJpbmddOiBQYWxldHRlIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGFnZU9wdGlvbnMge1xuICBuYW1lOiBzdHJpbmdcbiAgb3B0aW9ucz86IGFueVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NPcHRpb25zIHtcbiAgZmlsdGVyczogc3RyaW5nW11cbiAgcXVhbnRpemVyOiBzdHJpbmcgfCBTdGFnZU9wdGlvbnNcbiAgZ2VuZXJhdG9yczogKHN0cmluZyB8IFN0YWdlT3B0aW9ucylbXVxufVxuXG5pbnRlcmZhY2UgU3RhZ2VUYXNrPFE+IHtcbiAgbmFtZTogc3RyaW5nXG4gIGZuOiBRXG4gIG9wdGlvbnM/OiBhbnlcbn1cblxuaW50ZXJmYWNlIFByb2Nlc3NUYXNrcyB7XG4gIGZpbHRlcnM6IFN0YWdlVGFzazxGaWx0ZXI+W11cbiAgcXVhbnRpemVyOiBTdGFnZVRhc2s8UXVhbnRpemVyPlxuICBnZW5lcmF0b3JzOiBTdGFnZVRhc2s8R2VuZXJhdG9yPltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGlwZWxpbmUge1xuICAvLyBxdWFudGl6ZXI6IFN0YWdlPFF1YW50aXplcj5cbiAgLy8gZ2VuZXJhdG9yOiBTdGFnZTxHZW5lcmF0b3I+XG4gIHByb2Nlc3MgKGltYWdlRGF0YTogSW1hZ2VEYXRhLCBvcHRzOiBQcm9jZXNzT3B0aW9ucyk6IFByb21pc2U8UHJvY2Vzc1Jlc3VsdD5cbn1cblxuZXhwb3J0IGNsYXNzIEJhc2ljUGlwZWxpbmUgaW1wbGVtZW50cyBQaXBlbGluZSB7XG4gIHByaXZhdGUgX2J1aWxkUHJvY2Vzc1Rhc2tzICh7XG4gICAgZmlsdGVycyxcbiAgICBxdWFudGl6ZXIsXG4gICAgZ2VuZXJhdG9yc1xuICB9OiBQcm9jZXNzT3B0aW9ucyk6IFByb2Nlc3NUYXNrcyB7XG4gICAgLy8gU3VwcG9ydCB3aWxkY2FyZCBmb3IgZ2VuZXJhdG9yc1xuICAgIGlmIChnZW5lcmF0b3JzLmxlbmd0aCA9PT0gMSAmJiBnZW5lcmF0b3JzWzBdID09PSAnKicpIHtcbiAgICAgIGdlbmVyYXRvcnMgPSB0aGlzLmdlbmVyYXRvci5uYW1lcygpXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmaWx0ZXJzOiBmaWx0ZXJzLm1hcChmID0+IGNyZWF0ZVRhc2sodGhpcy5maWx0ZXIsIGYpKSxcbiAgICAgIHF1YW50aXplcjogY3JlYXRlVGFzayh0aGlzLnF1YW50aXplciwgcXVhbnRpemVyKSxcbiAgICAgIGdlbmVyYXRvcnM6IGdlbmVyYXRvcnMubWFwKGcgPT4gY3JlYXRlVGFzayh0aGlzLmdlbmVyYXRvciwgZykpXG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRhc2s8UT4gKFxuICAgICAgc3RhZ2U6IFN0YWdlPFE+LFxuICAgICAgbzogc3RyaW5nIHwgU3RhZ2VPcHRpb25zXG4gICAgKTogU3RhZ2VUYXNrPFE+IHtcbiAgICAgIGxldCBuYW1lOiBzdHJpbmdcbiAgICAgIGxldCBvcHRpb25zOiBhbnlcbiAgICAgIGlmICh0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IG9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBvLm5hbWVcbiAgICAgICAgb3B0aW9ucyA9IG8ub3B0aW9uc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBmbjogc3RhZ2UuZ2V0KG5hbWUpLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbHRlcjogU3RhZ2U8RmlsdGVyPiA9IG5ldyBTdGFnZSh0aGlzKVxuICBxdWFudGl6ZXI6IFN0YWdlPFF1YW50aXplcj4gPSBuZXcgU3RhZ2UodGhpcylcbiAgZ2VuZXJhdG9yOiBTdGFnZTxHZW5lcmF0b3I+ID0gbmV3IFN0YWdlKHRoaXMpXG4gIGFzeW5jIHByb2Nlc3MgKFxuICAgIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxuICAgIG9wdHM6IFByb2Nlc3NPcHRpb25zXG4gICk6IFByb21pc2U8UHJvY2Vzc1Jlc3VsdD4ge1xuICAgIGxldCB7IGZpbHRlcnMsIHF1YW50aXplciwgZ2VuZXJhdG9ycyB9ID0gdGhpcy5fYnVpbGRQcm9jZXNzVGFza3Mob3B0cylcbiAgICBjb25zdCBpbWFnZUZpbHRlckRhdGEgPSBhd2FpdCB0aGlzLl9maWx0ZXJDb2xvcnMoZmlsdGVycywgaW1hZ2VEYXRhKVxuICAgIGNvbnN0IGNvbG9ycyA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlQ29sb3JzKHF1YW50aXplciwgaW1hZ2VGaWx0ZXJEYXRhKVxuICAgIGNvbnN0IHBhbGV0dGVzID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVQYWxldHRlcyhnZW5lcmF0b3JzLCBjb2xvcnMpXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHBhbGV0dGVzXG4gICAgfVxuICB9XG4gIHByaXZhdGUgX2ZpbHRlckNvbG9ycyAoZmlsdGVyczogU3RhZ2VUYXNrPEZpbHRlcj5bXSwgaW1hZ2VEYXRhOiBJbWFnZURhdGEpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgYXBwbHlGaWx0ZXJzKGltYWdlRGF0YSwgZmlsdGVycy5tYXAoKHsgZm4gfSkgPT4gZm4pKVxuICAgIClcbiAgfVxuICBwcml2YXRlIF9nZW5lcmF0ZUNvbG9ycyAoXG4gICAgcXVhbnRpemVyOiBTdGFnZVRhc2s8UXVhbnRpemVyPixcbiAgICBpbWFnZURhdGE6IEltYWdlRGF0YVxuICApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHF1YW50aXplci5mbihpbWFnZURhdGEuZGF0YSwgcXVhbnRpemVyLm9wdGlvbnMpKVxuICB9XG4gIHByaXZhdGUgYXN5bmMgX2dlbmVyYXRlUGFsZXR0ZXMgKFxuICAgIGdlbmVyYXRvcnM6IFN0YWdlVGFzazxHZW5lcmF0b3I+W10sXG4gICAgY29sb3JzOiBTd2F0Y2hbXVxuICApIHtcbiAgICAvLyBNYWtlIGEgcHJvbWlzZSBtYXAgdGhhdCB3aWxsIHJ1biB0aGVtIFwiY29uY3VycmVudGx5XCIgKGJ1dCByZXR1cm4gaW4gZXhwZWN0ZWQgcmVzdWx0KVxuICAgIGNvbnN0IHByb21pc2VBcnIgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGdlbmVyYXRvcnMubWFwKCh7IGZuLCBvcHRpb25zIH0pID0+IFByb21pc2UucmVzb2x2ZShmbihjb2xvcnMsIG9wdGlvbnMpKSlcbiAgICApXG4gICAgLy8gTWFwIHRoZSB2YWx1ZXMgdG8gdGhlIGV4cGVjdGVkIG5hbWVcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgcHJvbWlzZUFyci5yZWR1Y2UoXG4gICAgICAgIChwcm9taXNlcywgcHJvbWlzZVZhbCwgaSkgPT4ge1xuICAgICAgICAgIHByb21pc2VzW2dlbmVyYXRvcnNbaV0ubmFtZV0gPSBwcm9taXNlVmFsXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VzXG4gICAgICAgIH0sXG4gICAgICAgIHt9IGFzIHsgW25hbWU6IHN0cmluZ106IFBhbGV0dGUgfVxuICAgICAgKVxuICAgIClcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/node-vibrant/dist/vibrant.js\n");

/***/ })

};
