/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
export const id = "vendors-node_modules_lit-labs_virtualizer_layouts_flow_js";
export const ids = ["vendors-node_modules_lit-labs_virtualizer_layouts_flow_js"];
export const modules = {

/***/ "./node_modules/@lit-labs/virtualizer/layouts/flow.js":
/*!************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/flow.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FlowLayout: () => (/* binding */ FlowLayout),\n/* harmony export */   flow: () => (/* binding */ flow)\n/* harmony export */ });\n/* harmony import */ var _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/SizeCache.js */ \"./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js\");\n/* harmony import */ var _shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/BaseLayout.js */ \"./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\nconst flow = config => Object.assign({\n  type: FlowLayout\n}, config);\nfunction leadingMargin(direction) {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n  constructor() {\n    this._childSizeCache = new _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__.SizeCache();\n    this._marginSizeCache = new _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__.SizeCache();\n    this._metricsCache = new Map();\n  }\n  update(metrics, direction) {\n    const marginsToUpdate = new Set();\n    Object.keys(metrics).forEach(key => {\n      const k = Number(key);\n      this._metricsCache.set(k, metrics[k]);\n      this._childSizeCache.set(k, metrics[k][(0,_shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__.dim1)(direction)]);\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n    for (const k of marginsToUpdate) {\n      var _this$_metricsCache$g, _this$_metricsCache$g2;\n      const a = ((_this$_metricsCache$g = this._metricsCache.get(k)) === null || _this$_metricsCache$g === void 0 ? void 0 : _this$_metricsCache$g[leadingMargin(direction)]) || 0;\n      const b = ((_this$_metricsCache$g2 = this._metricsCache.get(k - 1)) === null || _this$_metricsCache$g2 === void 0 ? void 0 : _this$_metricsCache$g2[trailingMargin(direction)]) || 0;\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n  get averageChildSize() {\n    return this._childSizeCache.averageSize;\n  }\n  get totalChildSize() {\n    return this._childSizeCache.totalSize;\n  }\n  get averageMarginSize() {\n    return this._marginSizeCache.averageSize;\n  }\n  get totalMarginSize() {\n    return this._marginSizeCache.totalSize;\n  }\n  getLeadingMarginValue(index, direction) {\n    var _this$_metricsCache$g3;\n    return ((_this$_metricsCache$g3 = this._metricsCache.get(index)) === null || _this$_metricsCache$g3 === void 0 ? void 0 : _this$_metricsCache$g3[leadingMargin(direction)]) || 0;\n  }\n  getChildSize(index) {\n    return this._childSizeCache.getSize(index);\n  }\n  getMarginSize(index) {\n    return this._marginSizeCache.getSize(index);\n  }\n  clear() {\n    this._childSizeCache.clear();\n    this._marginSizeCache.clear();\n    this._metricsCache.clear();\n  }\n}\nclass FlowLayout extends _shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__.BaseLayout {\n  constructor() {\n    super(...arguments);\n    /**\n     * Initial estimate of item size\n     */\n    this._itemSize = {\n      width: 100,\n      height: 100\n    };\n    /**\n     * Indices of children mapped to their (position and length) in the scrolling\n     * direction. Used to keep track of children that are in range.\n     */\n    this._physicalItems = new Map();\n    /**\n     * Used in tandem with _physicalItems to track children in range across\n     * reflows.\n     */\n    this._newPhysicalItems = new Map();\n    /**\n     * Width and height of children by their index.\n     */\n    this._metricsCache = new MetricsCache();\n    /**\n     * anchorIdx is the anchor around which we reflow. It is designed to allow\n     * jumping to any point of the scroll size. We choose it once and stick with\n     * it until stable. _first and _last are deduced around it.\n     */\n    this._anchorIdx = null;\n    /**\n     * Position in the scrolling direction of the anchor child.\n     */\n    this._anchorPos = null;\n    /**\n     * Whether all children in range were in range during the previous reflow.\n     */\n    this._stable = true;\n    this._measureChildren = true;\n    this._estimate = true;\n  }\n  // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n  // })\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n  get measureChildren() {\n    return this._measureChildren;\n  }\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n  updateItemSizes(sizes) {\n    this._metricsCache.update(sizes, this.direction);\n    // if (this._nMeasured) {\n    // this._updateItemSize();\n    this._scheduleReflow();\n    // }\n  }\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n  _getPhysicalItem(idx) {\n    var _this$_newPhysicalIte;\n    return (_this$_newPhysicalIte = this._newPhysicalItems.get(idx)) !== null && _this$_newPhysicalIte !== void 0 ? _this$_newPhysicalIte : this._physicalItems.get(idx);\n  }\n  _getSize(idx) {\n    const item = this._getPhysicalItem(idx);\n    return item && this._metricsCache.getChildSize(idx);\n  }\n  _getAverageSize() {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n  _estimatePosition(idx) {\n    const c = this._metricsCache;\n    if (this._first === -1 || this._last === -1) {\n      return c.averageMarginSize + idx * (c.averageMarginSize + this._getAverageSize());\n    } else {\n      if (idx < this._first) {\n        const delta = this._first - idx;\n        const refItem = this._getPhysicalItem(this._first);\n        return refItem.pos - (c.getMarginSize(this._first - 1) || c.averageMarginSize) - (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize);\n      } else {\n        const delta = idx - this._last;\n        const refItem = this._getPhysicalItem(this._last);\n        return refItem.pos + (c.getChildSize(this._last) || c.averageChildSize) + (c.getMarginSize(this._last) || c.averageMarginSize) + delta * (c.averageChildSize + c.averageMarginSize);\n      }\n    }\n  }\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n  _getPosition(idx) {\n    var _this$_metricsCache$g4;\n    const item = this._getPhysicalItem(idx);\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return idx === 0 ? (_this$_metricsCache$g4 = this._metricsCache.getMarginSize(0)) !== null && _this$_metricsCache$g4 !== void 0 ? _this$_metricsCache$g4 : averageMarginSize : item ? item.pos : this._estimatePosition(idx);\n  }\n  _calculateAnchor(lower, upper) {\n    if (lower <= 0) {\n      return 0;\n    }\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this.items.length - 1;\n    }\n    return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n  }\n  _getAnchor(lower, upper) {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._first < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._last < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    const firstItem = this._getPhysicalItem(this._first),\n      lastItem = this._getPhysicalItem(this._last),\n      firstMin = firstItem.pos,\n      lastMin = lastItem.pos,\n      lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n    if (lastMax < lower) {\n      // Window is entirely past physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    if (firstMin > upper) {\n      // Window is entirely before physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    // Window contains a physical item\n    // Find one, starting with the one that was previously first visible\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n      cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n    }\n    return candidateIdx;\n  }\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this.items.length === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n  /**\n   * Sets the range to empty.\n   */\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n    this._newPhysicalItems.clear();\n    this._physicalItems = items;\n    this._stable = true;\n  }\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n  _getItems() {\n    var _this$_metricsCache$g5, _this$_metricsCache$g6;\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper;\n    // The anchorIdx is the anchor around which we reflow. It is designed to\n    // allow jumping to any point of the scroll size. We choose it once and\n    // stick with it until stable. first and last are deduced around it.\n    // If we have a pinned item, we anchor on it\n    if (this.pin !== null) {\n      const {\n        index\n      } = this.pin;\n      this._anchorIdx = index;\n      this._anchorPos = this._getPosition(index);\n    }\n    // Determine the lower and upper bounds of the region to be\n    // rendered, relative to the viewport\n    lower = this._scrollPosition - this._overhang; //leadingOverhang;\n    upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n      return;\n    }\n    // If we are scrolling to a specific index or if we are doing another\n    // pass to stabilize a previously started reflow, we will already\n    // have an anchor. If not, establish an anchor now.\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n    let anchorSize = this._getSize(this._anchorIdx);\n    if (anchorSize === undefined) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n    const anchorLeadingMargin = (_this$_metricsCache$g5 = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _this$_metricsCache$g5 !== void 0 ? _this$_metricsCache$g5 : this._metricsCache.averageMarginSize;\n    const anchorTrailingMargin = (_this$_metricsCache$g6 = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _this$_metricsCache$g6 !== void 0 ? _this$_metricsCache$g6 : this._metricsCache.averageMarginSize;\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n    if (this._anchorIdx === this.items.length - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    }\n    // Anchor might be outside bounds, so prefer correcting the error and keep\n    // that anchorIdx.\n    let anchorErr = 0;\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n    items.set(this._anchorIdx, {\n      pos: this._anchorPos,\n      size: anchorSize\n    });\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos - anchorLeadingMargin;\n    this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._first);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      this._physicalMin -= size;\n      const pos = this._physicalMin;\n      items.set(this._first, {\n        pos,\n        size\n      });\n      this._physicalMin -= margin;\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n    while (this._physicalMax < upper && this._last < this.items.length - 1) {\n      let size = this._getSize(++this._last);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._last);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      const pos = this._physicalMax;\n      items.set(this._last, {\n        pos,\n        size\n      });\n      this._physicalMax += size + margin;\n      if (!this._stable && !this._estimate) {\n        break;\n      }\n    }\n    // This handles the cases where we were relying on estimated sizes.\n    const extentErr = this._calculateError();\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach(item => item.pos -= extentErr);\n      this._scrollError += extentErr;\n    }\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n      this._newPhysicalItems.clear();\n      this._physicalItems = items;\n    }\n  }\n  _calculateError() {\n    if (this._first === 0) {\n      return this._physicalMin;\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this.items.length - 1) {\n      return this._physicalMax - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return this._physicalMax - this._scrollSize + (this.items.length - 1 - this._last) * this._delta;\n    }\n    return 0;\n  }\n  _reflow() {\n    const {\n      _first,\n      _last\n    } = this;\n    super._reflow();\n    if (this._first === -1 && this._last == -1 || this._first === _first && this._last === _last) {\n      this._resetReflowState();\n    }\n  }\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n  _updateScrollSize() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) + averageMarginSize);\n  }\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n  get _delta() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n  _getItemPosition(idx) {\n    var _this$_metricsCache$g7;\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -((_this$_metricsCache$g7 = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _this$_metricsCache$g7 !== void 0 ? _this$_metricsCache$g7 : this._metricsCache.averageMarginSize)\n    };\n  }\n  /**\n   * Returns the height and width of the item at idx.\n   */\n  _getItemSize(idx) {\n    return {\n      [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim]\n    };\n  }\n  _viewDim2Changed() {\n    this._metricsCache.clear();\n    this._scheduleReflow();\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvZmxvdy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7O0FBTUE7QUFDQTtBQStCQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFtREE7QUFqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUFBOztBQUNBOzs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7O0FBSUE7QUFFQTs7OztBQUlBO0FBRUE7OztBQUdBO0FBRUE7Ozs7O0FBS0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTtBQUVBO0FBc1lBO0FBcFlBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7O0FBUUE7QUFFQTs7OztBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQU9BO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUdBO0FBSUE7QUFDQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvbGF5b3V0cy9mbG93LnRzP2M5MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbmltcG9ydCB7U2l6ZUNhY2hlfSBmcm9tICcuL3NoYXJlZC9TaXplQ2FjaGUuanMnO1xuaW1wb3J0IHtCYXNlTGF5b3V0LCBkaW0xfSBmcm9tICcuL3NoYXJlZC9CYXNlTGF5b3V0LmpzJztcbmltcG9ydCB7XG4gIFBvc2l0aW9ucyxcbiAgU2l6ZSxcbiAgTWFyZ2lucyxcbiAgbWFyZ2luLFxuICBTY3JvbGxEaXJlY3Rpb24sXG4gIG9mZnNldEF4aXMsXG4gIENoaWxkTWVhc3VyZW1lbnRzLFxuICBCYXNlTGF5b3V0Q29uZmlnLFxuICBMYXlvdXRIb3N0U2luayxcbn0gZnJvbSAnLi9zaGFyZWQvTGF5b3V0LmpzJztcblxudHlwZSBJdGVtQm91bmRzID0ge1xuICBwb3M6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xufTtcblxudHlwZSBGbG93TGF5b3V0Q29uc3RydWN0b3IgPSB7XG4gIHByb3RvdHlwZTogRmxvd0xheW91dDtcbiAgbmV3IChob3N0U2luazogTGF5b3V0SG9zdFNpbmssIGNvbmZpZz86IEJhc2VMYXlvdXRDb25maWcpOiBGbG93TGF5b3V0O1xufTtcblxudHlwZSBGbG93TGF5b3V0U3BlY2lmaWVyID0gQmFzZUxheW91dENvbmZpZyAmIHtcbiAgdHlwZTogRmxvd0xheW91dENvbnN0cnVjdG9yO1xufTtcblxudHlwZSBGbG93TGF5b3V0U3BlY2lmaWVyRmFjdG9yeSA9IChcbiAgY29uZmlnPzogQmFzZUxheW91dENvbmZpZ1xuKSA9PiBGbG93TGF5b3V0U3BlY2lmaWVyO1xuXG5leHBvcnQgY29uc3QgZmxvdzogRmxvd0xheW91dFNwZWNpZmllckZhY3RvcnkgPSAoY29uZmlnPzogQmFzZUxheW91dENvbmZpZykgPT5cbiAgT2JqZWN0LmFzc2lnbihcbiAgICB7XG4gICAgICB0eXBlOiBGbG93TGF5b3V0LFxuICAgIH0sXG4gICAgY29uZmlnXG4gICk7XG5cbmZ1bmN0aW9uIGxlYWRpbmdNYXJnaW4oZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBtYXJnaW4ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luVG9wJztcbn1cblxuZnVuY3Rpb24gdHJhaWxpbmdNYXJnaW4oZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBtYXJnaW4ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnbWFyZ2luUmlnaHQnIDogJ21hcmdpbkJvdHRvbSc7XG59XG5cbmZ1bmN0aW9uIG9mZnNldChkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbik6IG9mZnNldEF4aXMge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAneE9mZnNldCcgOiAneU9mZnNldCc7XG59XG5cbmZ1bmN0aW9uIGNvbGxhcHNlTWFyZ2lucyhhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IG0gPSBbYSwgYl0uc29ydCgpO1xuICByZXR1cm4gbVsxXSA8PSAwID8gTWF0aC5taW4oLi4ubSkgOiBtWzBdID49IDAgPyBNYXRoLm1heCguLi5tKSA6IG1bMF0gKyBtWzFdO1xufVxuXG5jbGFzcyBNZXRyaWNzQ2FjaGUge1xuICBwcml2YXRlIF9jaGlsZFNpemVDYWNoZSA9IG5ldyBTaXplQ2FjaGUoKTtcbiAgcHJpdmF0ZSBfbWFyZ2luU2l6ZUNhY2hlID0gbmV3IFNpemVDYWNoZSgpO1xuICBwcml2YXRlIF9tZXRyaWNzQ2FjaGUgPSBuZXcgTWFwPG51bWJlciwgU2l6ZSAmIE1hcmdpbnM+KCk7XG5cbiAgdXBkYXRlKG1ldHJpY3M6IHtba2V5OiBudW1iZXJdOiBTaXplICYgTWFyZ2luc30sIGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgY29uc3QgbWFyZ2luc1RvVXBkYXRlID0gbmV3IFNldDxudW1iZXI+KCk7XG4gICAgT2JqZWN0LmtleXMobWV0cmljcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBrID0gTnVtYmVyKGtleSk7XG4gICAgICB0aGlzLl9tZXRyaWNzQ2FjaGUuc2V0KGssIG1ldHJpY3Nba10pO1xuICAgICAgdGhpcy5fY2hpbGRTaXplQ2FjaGUuc2V0KGssIG1ldHJpY3Nba11bZGltMShkaXJlY3Rpb24pXSk7XG4gICAgICBtYXJnaW5zVG9VcGRhdGUuYWRkKGspO1xuICAgICAgbWFyZ2luc1RvVXBkYXRlLmFkZChrICsgMSk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBrIG9mIG1hcmdpbnNUb1VwZGF0ZSkge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX21ldHJpY3NDYWNoZS5nZXQoayk/LltsZWFkaW5nTWFyZ2luKGRpcmVjdGlvbildIHx8IDA7XG4gICAgICBjb25zdCBiID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldChrIC0gMSk/Llt0cmFpbGluZ01hcmdpbihkaXJlY3Rpb24pXSB8fCAwO1xuICAgICAgdGhpcy5fbWFyZ2luU2l6ZUNhY2hlLnNldChrLCBjb2xsYXBzZU1hcmdpbnMoYSwgYikpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhdmVyYWdlQ2hpbGRTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkU2l6ZUNhY2hlLmF2ZXJhZ2VTaXplO1xuICB9XG5cbiAgZ2V0IHRvdGFsQ2hpbGRTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkU2l6ZUNhY2hlLnRvdGFsU2l6ZTtcbiAgfVxuXG4gIGdldCBhdmVyYWdlTWFyZ2luU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9tYXJnaW5TaXplQ2FjaGUuYXZlcmFnZVNpemU7XG4gIH1cblxuICBnZXQgdG90YWxNYXJnaW5TaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmdpblNpemVDYWNoZS50b3RhbFNpemU7XG4gIH1cblxuICBnZXRMZWFkaW5nTWFyZ2luVmFsdWUoaW5kZXg6IG51bWJlciwgZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fbWV0cmljc0NhY2hlLmdldChpbmRleCk/LltsZWFkaW5nTWFyZ2luKGRpcmVjdGlvbildIHx8IDA7XG4gIH1cblxuICBnZXRDaGlsZFNpemUoaW5kZXg6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZFNpemVDYWNoZS5nZXRTaXplKGluZGV4KTtcbiAgfVxuXG4gIGdldE1hcmdpblNpemUoaW5kZXg6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9tYXJnaW5TaXplQ2FjaGUuZ2V0U2l6ZShpbmRleCk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9jaGlsZFNpemVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX21hcmdpblNpemVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX21ldHJpY3NDYWNoZS5jbGVhcigpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGbG93TGF5b3V0IGV4dGVuZHMgQmFzZUxheW91dDxCYXNlTGF5b3V0Q29uZmlnPiB7XG4gIC8qKlxuICAgKiBJbml0aWFsIGVzdGltYXRlIG9mIGl0ZW0gc2l6ZVxuICAgKi9cbiAgX2l0ZW1TaXplOiBTaXplID0ge3dpZHRoOiAxMDAsIGhlaWdodDogMTAwfTtcblxuICAvKipcbiAgICogSW5kaWNlcyBvZiBjaGlsZHJlbiBtYXBwZWQgdG8gdGhlaXIgKHBvc2l0aW9uIGFuZCBsZW5ndGgpIGluIHRoZSBzY3JvbGxpbmdcbiAgICogZGlyZWN0aW9uLiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gdGhhdCBhcmUgaW4gcmFuZ2UuXG4gICAqL1xuICBfcGh5c2ljYWxJdGVtcyA9IG5ldyBNYXA8bnVtYmVyLCBJdGVtQm91bmRzPigpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGluIHRhbmRlbSB3aXRoIF9waHlzaWNhbEl0ZW1zIHRvIHRyYWNrIGNoaWxkcmVuIGluIHJhbmdlIGFjcm9zc1xuICAgKiByZWZsb3dzLlxuICAgKi9cbiAgX25ld1BoeXNpY2FsSXRlbXMgPSBuZXcgTWFwPG51bWJlciwgSXRlbUJvdW5kcz4oKTtcblxuICAvKipcbiAgICogV2lkdGggYW5kIGhlaWdodCBvZiBjaGlsZHJlbiBieSB0aGVpciBpbmRleC5cbiAgICovXG4gIF9tZXRyaWNzQ2FjaGUgPSBuZXcgTWV0cmljc0NhY2hlKCk7XG5cbiAgLyoqXG4gICAqIGFuY2hvcklkeCBpcyB0aGUgYW5jaG9yIGFyb3VuZCB3aGljaCB3ZSByZWZsb3cuIEl0IGlzIGRlc2lnbmVkIHRvIGFsbG93XG4gICAqIGp1bXBpbmcgdG8gYW55IHBvaW50IG9mIHRoZSBzY3JvbGwgc2l6ZS4gV2UgY2hvb3NlIGl0IG9uY2UgYW5kIHN0aWNrIHdpdGhcbiAgICogaXQgdW50aWwgc3RhYmxlLiBfZmlyc3QgYW5kIF9sYXN0IGFyZSBkZWR1Y2VkIGFyb3VuZCBpdC5cbiAgICovXG4gIF9hbmNob3JJZHg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbiBvZiB0aGUgYW5jaG9yIGNoaWxkLlxuICAgKi9cbiAgX2FuY2hvclBvczogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgYWxsIGNoaWxkcmVuIGluIHJhbmdlIHdlcmUgaW4gcmFuZ2UgZHVyaW5nIHRoZSBwcmV2aW91cyByZWZsb3cuXG4gICAqL1xuICBfc3RhYmxlID0gdHJ1ZTtcblxuICBwcml2YXRlIF9tZWFzdXJlQ2hpbGRyZW4gPSB0cnVlO1xuXG4gIF9lc3RpbWF0ZSA9IHRydWU7XG5cbiAgLy8gcHJvdGVjdGVkIF9kZWZhdWx0Q29uZmlnOiBCYXNlTGF5b3V0Q29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgc3VwZXIuX2RlZmF1bHRDb25maWcsIHtcblxuICAvLyB9KVxuXG4gIC8vIGNvbnN0cnVjdG9yKGNvbmZpZzogTGF5b3V0MWRDb25maWcpIHtcbiAgLy8gICBzdXBlcihjb25maWcpO1xuICAvLyB9XG5cbiAgZ2V0IG1lYXN1cmVDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVhc3VyZUNoaWxkcmVuO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgYXZlcmFnZSBzaXplIG9mIGFsbCBjaGlsZHJlbiByZXByZXNlbnRlZCBpbiB0aGUgc2l6ZXNcbiAgICogYXJndW1lbnQuXG4gICAqL1xuICB1cGRhdGVJdGVtU2l6ZXMoc2l6ZXM6IENoaWxkTWVhc3VyZW1lbnRzKSB7XG4gICAgdGhpcy5fbWV0cmljc0NhY2hlLnVwZGF0ZShzaXplcyBhcyBTaXplICYgTWFyZ2lucywgdGhpcy5kaXJlY3Rpb24pO1xuICAgIC8vIGlmICh0aGlzLl9uTWVhc3VyZWQpIHtcbiAgICAvLyB0aGlzLl91cGRhdGVJdGVtU2l6ZSgpO1xuICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gICAgLy8gfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXZlcmFnZSBpdGVtIHNpemUgYmFzZWQgb24gdGhlIHRvdGFsIGxlbmd0aCBhbmQgbnVtYmVyIG9mIGNoaWxkcmVuXG4gICAqIGluIHJhbmdlLlxuICAgKi9cbiAgLy8gX3VwZGF0ZUl0ZW1TaXplKCkge1xuICAvLyAgIC8vIEtlZXAgaW50ZWdlciB2YWx1ZXMuXG4gIC8vICAgdGhpcy5faXRlbVNpemVbdGhpcy5fc2l6ZURpbV0gPSB0aGlzLl9tZXRyaWNzQ2FjaGUuYXZlcmFnZUNoaWxkU2l6ZTtcbiAgLy8gfVxuXG4gIF9nZXRQaHlzaWNhbEl0ZW0oaWR4OiBudW1iZXIpOiBJdGVtQm91bmRzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fbmV3UGh5c2ljYWxJdGVtcy5nZXQoaWR4KSA/PyB0aGlzLl9waHlzaWNhbEl0ZW1zLmdldChpZHgpO1xuICB9XG5cbiAgX2dldFNpemUoaWR4OiBudW1iZXIpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0oaWR4KTtcbiAgICByZXR1cm4gaXRlbSAmJiB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0Q2hpbGRTaXplKGlkeCk7XG4gIH1cblxuICBfZ2V0QXZlcmFnZVNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VDaGlsZFNpemUgfHwgdGhpcy5faXRlbVNpemVbdGhpcy5fc2l6ZURpbV07XG4gIH1cblxuICBfZXN0aW1hdGVQb3NpdGlvbihpZHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgYyA9IHRoaXMuX21ldHJpY3NDYWNoZTtcbiAgICBpZiAodGhpcy5fZmlyc3QgPT09IC0xIHx8IHRoaXMuX2xhc3QgPT09IC0xKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjLmF2ZXJhZ2VNYXJnaW5TaXplICtcbiAgICAgICAgaWR4ICogKGMuYXZlcmFnZU1hcmdpblNpemUgKyB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlkeCA8IHRoaXMuX2ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5fZmlyc3QgLSBpZHg7XG4gICAgICAgIGNvbnN0IHJlZkl0ZW0gPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0odGhpcy5fZmlyc3QpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJlZkl0ZW0hLnBvcyAtXG4gICAgICAgICAgKGMuZ2V0TWFyZ2luU2l6ZSh0aGlzLl9maXJzdCAtIDEpIHx8IGMuYXZlcmFnZU1hcmdpblNpemUpIC1cbiAgICAgICAgICAoZGVsdGEgKiBjLmF2ZXJhZ2VDaGlsZFNpemUgKyAoZGVsdGEgLSAxKSAqIGMuYXZlcmFnZU1hcmdpblNpemUpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGlkeCAtIHRoaXMuX2xhc3Q7XG4gICAgICAgIGNvbnN0IHJlZkl0ZW0gPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0odGhpcy5fbGFzdCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVmSXRlbSEucG9zICtcbiAgICAgICAgICAoYy5nZXRDaGlsZFNpemUodGhpcy5fbGFzdCkgfHwgYy5hdmVyYWdlQ2hpbGRTaXplKSArXG4gICAgICAgICAgKGMuZ2V0TWFyZ2luU2l6ZSh0aGlzLl9sYXN0KSB8fCBjLmF2ZXJhZ2VNYXJnaW5TaXplKSArXG4gICAgICAgICAgZGVsdGEgKiAoYy5hdmVyYWdlQ2hpbGRTaXplICsgYy5hdmVyYWdlTWFyZ2luU2l6ZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24gb2YgdGhlIGl0ZW0gYXQgaWR4LlxuICAgKiBFc3RpbWF0ZXMgaXQgaWYgdGhlIGl0ZW0gYXQgaWR4IGlzIG5vdCBpbiB0aGUgRE9NLlxuICAgKi9cbiAgX2dldFBvc2l0aW9uKGlkeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fZ2V0UGh5c2ljYWxJdGVtKGlkeCk7XG4gICAgY29uc3Qge2F2ZXJhZ2VNYXJnaW5TaXplfSA9IHRoaXMuX21ldHJpY3NDYWNoZTtcbiAgICByZXR1cm4gaWR4ID09PSAwXG4gICAgICA/IHRoaXMuX21ldHJpY3NDYWNoZS5nZXRNYXJnaW5TaXplKDApID8/IGF2ZXJhZ2VNYXJnaW5TaXplXG4gICAgICA6IGl0ZW1cbiAgICAgID8gaXRlbS5wb3NcbiAgICAgIDogdGhpcy5fZXN0aW1hdGVQb3NpdGlvbihpZHgpO1xuICB9XG5cbiAgX2NhbGN1bGF0ZUFuY2hvcihsb3dlcjogbnVtYmVyLCB1cHBlcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAobG93ZXIgPD0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh1cHBlciA+IHRoaXMuX3Njcm9sbFNpemUgLSB0aGlzLl92aWV3RGltMSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgMCxcbiAgICAgIE1hdGgubWluKFxuICAgICAgICB0aGlzLml0ZW1zLmxlbmd0aCAtIDEsXG4gICAgICAgIE1hdGguZmxvb3IoKGxvd2VyICsgdXBwZXIpIC8gMiAvIHRoaXMuX2RlbHRhKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBfZ2V0QW5jaG9yKGxvd2VyOiBudW1iZXIsIHVwcGVyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLl9waHlzaWNhbEl0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZpcnN0IDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGFzdCA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEl0ZW0gPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0odGhpcy5fZmlyc3QpLFxuICAgICAgbGFzdEl0ZW0gPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0odGhpcy5fbGFzdCksXG4gICAgICBmaXJzdE1pbiA9IGZpcnN0SXRlbSEucG9zLFxuICAgICAgbGFzdE1pbiA9IGxhc3RJdGVtIS5wb3MsXG4gICAgICBsYXN0TWF4ID0gbGFzdE1pbiArIHRoaXMuX21ldHJpY3NDYWNoZS5nZXRDaGlsZFNpemUodGhpcy5fbGFzdCkhO1xuXG4gICAgaWYgKGxhc3RNYXggPCBsb3dlcikge1xuICAgICAgLy8gV2luZG93IGlzIGVudGlyZWx5IHBhc3QgcGh5c2ljYWwgaXRlbXMsIGNhbGN1bGF0ZSBuZXcgYW5jaG9yXG4gICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlQW5jaG9yKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuICAgIGlmIChmaXJzdE1pbiA+IHVwcGVyKSB7XG4gICAgICAvLyBXaW5kb3cgaXMgZW50aXJlbHkgYmVmb3JlIHBoeXNpY2FsIGl0ZW1zLCBjYWxjdWxhdGUgbmV3IGFuY2hvclxuICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgIH1cbiAgICAvLyBXaW5kb3cgY29udGFpbnMgYSBwaHlzaWNhbCBpdGVtXG4gICAgLy8gRmluZCBvbmUsIHN0YXJ0aW5nIHdpdGggdGhlIG9uZSB0aGF0IHdhcyBwcmV2aW91c2x5IGZpcnN0IHZpc2libGVcbiAgICBsZXQgY2FuZGlkYXRlSWR4ID0gdGhpcy5fZmlyc3RWaXNpYmxlIC0gMTtcbiAgICBsZXQgY01heCA9IC1JbmZpbml0eTtcbiAgICB3aGlsZSAoY01heCA8IGxvd2VyKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0oKytjYW5kaWRhdGVJZHgpO1xuICAgICAgY01heCA9IGNhbmRpZGF0ZSEucG9zICsgdGhpcy5fbWV0cmljc0NhY2hlLmdldENoaWxkU2l6ZShjYW5kaWRhdGVJZHgpITtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmRpZGF0ZUlkeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIF9maXJzdCBhbmQgX2xhc3QgYmFzZWQgb24gaXRlbXMgdGhhdCBzaG91bGQgYmUgaW4gdGhlIGN1cnJlbnRcbiAgICogdmlld2VkIHJhbmdlLlxuICAgKi9cbiAgX2dldEFjdGl2ZUl0ZW1zKCkge1xuICAgIGlmICh0aGlzLl92aWV3RGltMSA9PT0gMCB8fCB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fY2xlYXJJdGVtcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nZXRJdGVtcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByYW5nZSB0byBlbXB0eS5cbiAgICovXG4gIF9jbGVhckl0ZW1zKCkge1xuICAgIHRoaXMuX2ZpcnN0ID0gLTE7XG4gICAgdGhpcy5fbGFzdCA9IC0xO1xuICAgIHRoaXMuX3BoeXNpY2FsTWluID0gMDtcbiAgICB0aGlzLl9waHlzaWNhbE1heCA9IDA7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zO1xuICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMgPSB0aGlzLl9waHlzaWNhbEl0ZW1zO1xuICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMuY2xlYXIoKTtcbiAgICB0aGlzLl9waHlzaWNhbEl0ZW1zID0gaXRlbXM7XG4gICAgdGhpcy5fc3RhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIC8qXG4gICAqIFVwZGF0ZXMgX2ZpcnN0IGFuZCBfbGFzdCBiYXNlZCBvbiBpdGVtcyB0aGF0IHNob3VsZCBiZSBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAqL1xuICBfZ2V0SXRlbXMoKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zO1xuICAgIHRoaXMuX3N0YWJsZSA9IHRydWU7XG4gICAgbGV0IGxvd2VyLCB1cHBlcjtcblxuICAgIC8vIFRoZSBhbmNob3JJZHggaXMgdGhlIGFuY2hvciBhcm91bmQgd2hpY2ggd2UgcmVmbG93LiBJdCBpcyBkZXNpZ25lZCB0b1xuICAgIC8vIGFsbG93IGp1bXBpbmcgdG8gYW55IHBvaW50IG9mIHRoZSBzY3JvbGwgc2l6ZS4gV2UgY2hvb3NlIGl0IG9uY2UgYW5kXG4gICAgLy8gc3RpY2sgd2l0aCBpdCB1bnRpbCBzdGFibGUuIGZpcnN0IGFuZCBsYXN0IGFyZSBkZWR1Y2VkIGFyb3VuZCBpdC5cblxuICAgIC8vIElmIHdlIGhhdmUgYSBwaW5uZWQgaXRlbSwgd2UgYW5jaG9yIG9uIGl0XG4gICAgaWYgKHRoaXMucGluICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7aW5kZXh9ID0gdGhpcy5waW47XG4gICAgICB0aGlzLl9hbmNob3JJZHggPSBpbmRleDtcbiAgICAgIHRoaXMuX2FuY2hvclBvcyA9IHRoaXMuX2dldFBvc2l0aW9uKGluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGxvd2VyIGFuZCB1cHBlciBib3VuZHMgb2YgdGhlIHJlZ2lvbiB0byBiZVxuICAgIC8vIHJlbmRlcmVkLCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcbiAgICBsb3dlciA9IHRoaXMuX3Njcm9sbFBvc2l0aW9uIC0gdGhpcy5fb3Zlcmhhbmc7IC8vbGVhZGluZ092ZXJoYW5nO1xuICAgIHVwcGVyID0gdGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3RGltMSArIHRoaXMuX292ZXJoYW5nOyAvLyB0cmFpbGluZ092ZXJoYW5nO1xuXG4gICAgaWYgKHVwcGVyIDwgMCB8fCBsb3dlciA+IHRoaXMuX3Njcm9sbFNpemUpIHtcbiAgICAgIHRoaXMuX2NsZWFySXRlbXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBhcmUgc2Nyb2xsaW5nIHRvIGEgc3BlY2lmaWMgaW5kZXggb3IgaWYgd2UgYXJlIGRvaW5nIGFub3RoZXJcbiAgICAvLyBwYXNzIHRvIHN0YWJpbGl6ZSBhIHByZXZpb3VzbHkgc3RhcnRlZCByZWZsb3csIHdlIHdpbGwgYWxyZWFkeVxuICAgIC8vIGhhdmUgYW4gYW5jaG9yLiBJZiBub3QsIGVzdGFibGlzaCBhbiBhbmNob3Igbm93LlxuICAgIGlmICh0aGlzLl9hbmNob3JJZHggPT09IG51bGwgfHwgdGhpcy5fYW5jaG9yUG9zID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9hbmNob3JJZHggPSB0aGlzLl9nZXRBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICAgIHRoaXMuX2FuY2hvclBvcyA9IHRoaXMuX2dldFBvc2l0aW9uKHRoaXMuX2FuY2hvcklkeCk7XG4gICAgfVxuXG4gICAgbGV0IGFuY2hvclNpemUgPSB0aGlzLl9nZXRTaXplKHRoaXMuX2FuY2hvcklkeCk7XG4gICAgaWYgKGFuY2hvclNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhYmxlID0gZmFsc2U7XG4gICAgICBhbmNob3JTaXplID0gdGhpcy5fZ2V0QXZlcmFnZVNpemUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmNob3JMZWFkaW5nTWFyZ2luID1cbiAgICAgIHRoaXMuX21ldHJpY3NDYWNoZS5nZXRNYXJnaW5TaXplKHRoaXMuX2FuY2hvcklkeCkgPz9cbiAgICAgIHRoaXMuX21ldHJpY3NDYWNoZS5hdmVyYWdlTWFyZ2luU2l6ZTtcbiAgICBjb25zdCBhbmNob3JUcmFpbGluZ01hcmdpbiA9XG4gICAgICB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZSh0aGlzLl9hbmNob3JJZHggKyAxKSA/P1xuICAgICAgdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplO1xuXG4gICAgaWYgKHRoaXMuX2FuY2hvcklkeCA9PT0gMCkge1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gYW5jaG9yTGVhZGluZ01hcmdpbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYW5jaG9ySWR4ID09PSB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuX2FuY2hvclBvcyA9IHRoaXMuX3Njcm9sbFNpemUgLSBhbmNob3JUcmFpbGluZ01hcmdpbiAtIGFuY2hvclNpemU7XG4gICAgfVxuXG4gICAgLy8gQW5jaG9yIG1pZ2h0IGJlIG91dHNpZGUgYm91bmRzLCBzbyBwcmVmZXIgY29ycmVjdGluZyB0aGUgZXJyb3IgYW5kIGtlZXBcbiAgICAvLyB0aGF0IGFuY2hvcklkeC5cbiAgICBsZXQgYW5jaG9yRXJyID0gMDtcblxuICAgIGlmICh0aGlzLl9hbmNob3JQb3MgKyBhbmNob3JTaXplICsgYW5jaG9yVHJhaWxpbmdNYXJnaW4gPCBsb3dlcikge1xuICAgICAgYW5jaG9yRXJyID0gbG93ZXIgLSAodGhpcy5fYW5jaG9yUG9zICsgYW5jaG9yU2l6ZSArIGFuY2hvclRyYWlsaW5nTWFyZ2luKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYW5jaG9yUG9zIC0gYW5jaG9yTGVhZGluZ01hcmdpbiA+IHVwcGVyKSB7XG4gICAgICBhbmNob3JFcnIgPSB1cHBlciAtICh0aGlzLl9hbmNob3JQb3MgLSBhbmNob3JMZWFkaW5nTWFyZ2luKTtcbiAgICB9XG5cbiAgICBpZiAoYW5jaG9yRXJyKSB7XG4gICAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiAtPSBhbmNob3JFcnI7XG4gICAgICBsb3dlciAtPSBhbmNob3JFcnI7XG4gICAgICB1cHBlciAtPSBhbmNob3JFcnI7XG4gICAgICB0aGlzLl9zY3JvbGxFcnJvciArPSBhbmNob3JFcnI7XG4gICAgfVxuXG4gICAgaXRlbXMuc2V0KHRoaXMuX2FuY2hvcklkeCwge3BvczogdGhpcy5fYW5jaG9yUG9zLCBzaXplOiBhbmNob3JTaXplfSk7XG5cbiAgICB0aGlzLl9maXJzdCA9IHRoaXMuX2xhc3QgPSB0aGlzLl9hbmNob3JJZHg7XG4gICAgdGhpcy5fcGh5c2ljYWxNaW4gPSB0aGlzLl9hbmNob3JQb3MgLSBhbmNob3JMZWFkaW5nTWFyZ2luO1xuICAgIHRoaXMuX3BoeXNpY2FsTWF4ID0gdGhpcy5fYW5jaG9yUG9zICsgYW5jaG9yU2l6ZSArIGFuY2hvclRyYWlsaW5nTWFyZ2luO1xuXG4gICAgd2hpbGUgKHRoaXMuX3BoeXNpY2FsTWluID4gbG93ZXIgJiYgdGhpcy5fZmlyc3QgPiAwKSB7XG4gICAgICBsZXQgc2l6ZSA9IHRoaXMuX2dldFNpemUoLS10aGlzLl9maXJzdCk7XG4gICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3N0YWJsZSA9IGZhbHNlO1xuICAgICAgICBzaXplID0gdGhpcy5fZ2V0QXZlcmFnZVNpemUoKTtcbiAgICAgIH1cbiAgICAgIGxldCBtYXJnaW4gPSB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZSh0aGlzLl9maXJzdCk7XG4gICAgICBpZiAobWFyZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc3RhYmxlID0gZmFsc2U7XG4gICAgICAgIG1hcmdpbiA9IHRoaXMuX21ldHJpY3NDYWNoZS5hdmVyYWdlTWFyZ2luU2l6ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BoeXNpY2FsTWluIC09IHNpemU7XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLl9waHlzaWNhbE1pbjtcbiAgICAgIGl0ZW1zLnNldCh0aGlzLl9maXJzdCwge3Bvcywgc2l6ZX0pO1xuICAgICAgdGhpcy5fcGh5c2ljYWxNaW4gLT0gbWFyZ2luO1xuICAgICAgaWYgKHRoaXMuX3N0YWJsZSA9PT0gZmFsc2UgJiYgdGhpcy5fZXN0aW1hdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLl9waHlzaWNhbE1heCA8IHVwcGVyICYmIHRoaXMuX2xhc3QgPCB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgIGxldCBzaXplID0gdGhpcy5fZ2V0U2l6ZSgrK3RoaXMuX2xhc3QpO1xuICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgc2l6ZSA9IHRoaXMuX2dldEF2ZXJhZ2VTaXplKCk7XG4gICAgICB9XG4gICAgICBsZXQgbWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUodGhpcy5fbGFzdCk7XG4gICAgICBpZiAobWFyZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc3RhYmxlID0gZmFsc2U7XG4gICAgICAgIG1hcmdpbiA9IHRoaXMuX21ldHJpY3NDYWNoZS5hdmVyYWdlTWFyZ2luU2l6ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX3BoeXNpY2FsTWF4O1xuICAgICAgaXRlbXMuc2V0KHRoaXMuX2xhc3QsIHtwb3MsIHNpemV9KTtcbiAgICAgIHRoaXMuX3BoeXNpY2FsTWF4ICs9IHNpemUgKyBtYXJnaW47XG4gICAgICBpZiAoIXRoaXMuX3N0YWJsZSAmJiAhdGhpcy5fZXN0aW1hdGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlcyB3aGVyZSB3ZSB3ZXJlIHJlbHlpbmcgb24gZXN0aW1hdGVkIHNpemVzLlxuICAgIGNvbnN0IGV4dGVudEVyciA9IHRoaXMuX2NhbGN1bGF0ZUVycm9yKCk7XG4gICAgaWYgKGV4dGVudEVycikge1xuICAgICAgdGhpcy5fcGh5c2ljYWxNaW4gLT0gZXh0ZW50RXJyO1xuICAgICAgdGhpcy5fcGh5c2ljYWxNYXggLT0gZXh0ZW50RXJyO1xuICAgICAgdGhpcy5fYW5jaG9yUG9zIC09IGV4dGVudEVycjtcbiAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uIC09IGV4dGVudEVycjtcbiAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IChpdGVtLnBvcyAtPSBleHRlbnRFcnIpKTtcbiAgICAgIHRoaXMuX3Njcm9sbEVycm9yICs9IGV4dGVudEVycjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhYmxlKSB7XG4gICAgICB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zID0gdGhpcy5fcGh5c2ljYWxJdGVtcztcbiAgICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuX3BoeXNpY2FsSXRlbXMgPSBpdGVtcztcbiAgICB9XG4gIH1cblxuICBfY2FsY3VsYXRlRXJyb3IoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5fZmlyc3QgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9waHlzaWNhbE1pbjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BoeXNpY2FsTWluIDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9waHlzaWNhbE1pbiAtIHRoaXMuX2ZpcnN0ICogdGhpcy5fZGVsdGE7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9sYXN0ID09PSB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9waHlzaWNhbE1heCAtIHRoaXMuX3Njcm9sbFNpemU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9waHlzaWNhbE1heCA+PSB0aGlzLl9zY3JvbGxTaXplKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLl9waHlzaWNhbE1heCAtXG4gICAgICAgIHRoaXMuX3Njcm9sbFNpemUgK1xuICAgICAgICAodGhpcy5pdGVtcy5sZW5ndGggLSAxIC0gdGhpcy5fbGFzdCkgKiB0aGlzLl9kZWx0YVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBvdmVycmlkZSBfcmVmbG93KCkge1xuICAgIGNvbnN0IHtfZmlyc3QsIF9sYXN0fSA9IHRoaXM7XG4gICAgc3VwZXIuX3JlZmxvdygpO1xuICAgIGlmIChcbiAgICAgICh0aGlzLl9maXJzdCA9PT0gLTEgJiYgdGhpcy5fbGFzdCA9PSAtMSkgfHxcbiAgICAgICh0aGlzLl9maXJzdCA9PT0gX2ZpcnN0ICYmIHRoaXMuX2xhc3QgPT09IF9sYXN0KVxuICAgICkge1xuICAgICAgdGhpcy5fcmVzZXRSZWZsb3dTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9yZXNldFJlZmxvd1N0YXRlKCkge1xuICAgIHRoaXMuX2FuY2hvcklkeCA9IG51bGw7XG4gICAgdGhpcy5fYW5jaG9yUG9zID0gbnVsbDtcbiAgICB0aGlzLl9zdGFibGUgPSB0cnVlO1xuICB9XG5cbiAgX3VwZGF0ZVNjcm9sbFNpemUoKSB7XG4gICAgY29uc3Qge2F2ZXJhZ2VNYXJnaW5TaXplfSA9IHRoaXMuX21ldHJpY3NDYWNoZTtcbiAgICB0aGlzLl9zY3JvbGxTaXplID0gTWF0aC5tYXgoXG4gICAgICAxLFxuICAgICAgdGhpcy5pdGVtcy5sZW5ndGggKiAoYXZlcmFnZU1hcmdpblNpemUgKyB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpKSArXG4gICAgICAgIGF2ZXJhZ2VNYXJnaW5TaXplXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhdmVyYWdlIHNpemUgKHByZWNpc2Ugb3IgZXN0aW1hdGVkKSBvZiBhbiBpdGVtIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLFxuICAgKiBpbmNsdWRpbmcgYW55IHN1cnJvdW5kaW5nIHNwYWNlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCBfZGVsdGEoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7YXZlcmFnZU1hcmdpblNpemV9ID0gdGhpcy5fbWV0cmljc0NhY2hlO1xuICAgIHJldHVybiB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpICsgYXZlcmFnZU1hcmdpblNpemU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9wIGFuZCBsZWZ0IHBvc2l0aW9uaW5nIG9mIHRoZSBpdGVtIGF0IGlkeC5cbiAgICovXG4gIF9nZXRJdGVtUG9zaXRpb24oaWR4OiBudW1iZXIpOiBQb3NpdGlvbnMge1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5fcG9zaXRpb25EaW1dOiB0aGlzLl9nZXRQb3NpdGlvbihpZHgpLFxuICAgICAgW3RoaXMuX3NlY29uZGFyeVBvc2l0aW9uRGltXTogMCxcbiAgICAgIFtvZmZzZXQodGhpcy5kaXJlY3Rpb24pXTogLShcbiAgICAgICAgdGhpcy5fbWV0cmljc0NhY2hlLmdldExlYWRpbmdNYXJnaW5WYWx1ZShpZHgsIHRoaXMuZGlyZWN0aW9uKSA/P1xuICAgICAgICB0aGlzLl9tZXRyaWNzQ2FjaGUuYXZlcmFnZU1hcmdpblNpemVcbiAgICAgICksXG4gICAgfSBhcyBQb3NpdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgaXRlbSBhdCBpZHguXG4gICAqL1xuICBfZ2V0SXRlbVNpemUoaWR4OiBudW1iZXIpOiBTaXplIHtcbiAgICByZXR1cm4ge1xuICAgICAgW3RoaXMuX3NpemVEaW1dOiB0aGlzLl9nZXRTaXplKGlkeCkgfHwgdGhpcy5fZ2V0QXZlcmFnZVNpemUoKSxcbiAgICAgIFt0aGlzLl9zZWNvbmRhcnlTaXplRGltXTogdGhpcy5faXRlbVNpemVbdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbV0sXG4gICAgfSBhcyBTaXplO1xuICB9XG5cbiAgX3ZpZXdEaW0yQ2hhbmdlZCgpIHtcbiAgICB0aGlzLl9tZXRyaWNzQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/flow.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SizeCache: () => (/* binding */ SizeCache)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nclass SizeCache {\n  constructor(config) {\n    this._map = new Map();\n    this._roundAverageSize = false;\n    this.totalSize = 0;\n    if ((config === null || config === void 0 ? void 0 : config.roundAverageSize) === true) {\n      this._roundAverageSize = true;\n    }\n  }\n  set(index, value) {\n    const prev = this._map.get(index) || 0;\n    this._map.set(index, value);\n    this.totalSize += value - prev;\n  }\n  get averageSize() {\n    if (this._map.size > 0) {\n      const average = this.totalSize / this._map.size;\n      return this._roundAverageSize ? Math.round(average) : average;\n    }\n    return 0;\n  }\n  getSize(index) {\n    return this._map.get(index);\n  }\n  clear() {\n    this._map.clear();\n    this.totalSize = 0;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvc2hhcmVkL1NpemVDYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0FBVUE7QUFLQTtBQUpBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vc3JjL2xheW91dHMvc2hhcmVkL1NpemVDYWNoZS50cz9lZTljIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFNpemVDYWNoZUNvbmZpZyB7XG4gIHJvdW5kQXZlcmFnZVNpemU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgU2l6ZUNhY2hlIHtcbiAgcHJpdmF0ZSBfbWFwID0gbmV3IE1hcDxudW1iZXIgfCBzdHJpbmcsIG51bWJlcj4oKTtcbiAgcHJpdmF0ZSBfcm91bmRBdmVyYWdlU2l6ZSA9IGZhbHNlO1xuICB0b3RhbFNpemUgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZz86IFNpemVDYWNoZUNvbmZpZykge1xuICAgIGlmIChjb25maWc/LnJvdW5kQXZlcmFnZVNpemUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX3JvdW5kQXZlcmFnZVNpemUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHNldChpbmRleDogbnVtYmVyIHwgc3RyaW5nLCB2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMuX21hcC5nZXQoaW5kZXgpIHx8IDA7XG4gICAgdGhpcy5fbWFwLnNldChpbmRleCwgdmFsdWUpO1xuICAgIHRoaXMudG90YWxTaXplICs9IHZhbHVlIC0gcHJldjtcbiAgfVxuXG4gIGdldCBhdmVyYWdlU2l6ZSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLl9tYXAuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGF2ZXJhZ2UgPSB0aGlzLnRvdGFsU2l6ZSAvIHRoaXMuX21hcC5zaXplO1xuICAgICAgcmV0dXJuIHRoaXMuX3JvdW5kQXZlcmFnZVNpemUgPyBNYXRoLnJvdW5kKGF2ZXJhZ2UpIDogYXZlcmFnZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXRTaXplKGluZGV4OiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldChpbmRleCk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICB0aGlzLnRvdGFsU2l6ZSA9IDA7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js\n");

/***/ })

};
