/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
export const id = "vendors-node_modules_material_web_internal_aria_delegate_js-node_modules_element-internals-po-3afeae";
export const ids = ["vendors-node_modules_material_web_internal_aria_delegate_js-node_modules_element-internals-po-3afeae"];
export const modules = {

/***/ "./node_modules/@material/web/internal/aria/aria.js":
/*!**********************************************************!*\
  !*** ./node_modules/@material/web/internal/aria/aria.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ARIA_ATTRIBUTES: () => (/* binding */ ARIA_ATTRIBUTES),\n/* harmony export */   ARIA_PROPERTIES: () => (/* binding */ ARIA_PROPERTIES),\n/* harmony export */   ariaPropertyToAttribute: () => (/* binding */ ariaPropertyToAttribute),\n/* harmony export */   isAriaAttribute: () => (/* binding */ isAriaAttribute)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Accessibility Object Model reflective aria properties.\n */\nconst ARIA_PROPERTIES = ['ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaCurrent', 'ariaDisabled', 'ariaExpanded', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText'];\n/**\n * Accessibility Object Model aria attributes.\n */\nconst ARIA_ATTRIBUTES = ARIA_PROPERTIES.map(ariaPropertyToAttribute);\n/**\n * Checks if an attribute is one of the AOM aria attributes.\n *\n * @example\n * isAriaAttribute('aria-label'); // true\n *\n * @param attribute The attribute to check.\n * @return True if the attribute is an aria attribute, or false if not.\n */\nfunction isAriaAttribute(attribute) {\n  return attribute.startsWith('aria-');\n}\n/**\n * Converts an AOM aria property into its corresponding attribute.\n *\n * @example\n * ariaPropertyToAttribute('ariaLabel'); // 'aria-label'\n *\n * @param property The aria property.\n * @return The aria attribute.\n */\nfunction ariaPropertyToAttribute(property) {\n  return property.replace('aria', 'aria-')\n  // IDREF attributes also include an \"Element\" or \"Elements\" suffix\n  .replace(/Elements?/g, '').toLowerCase();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3dlYi9pbnRlcm5hbC9hcmlhL2FyaWEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7OztBQVdBOzs7QUFHQTtBQTZDQTs7O0FBR0E7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVNBO0FBR0E7QUFHQTtBQUFBO0FBSUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9hcmlhLnRzP2JmNWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG4vKipcbiAqIEFjY2Vzc2liaWxpdHkgT2JqZWN0IE1vZGVsIHJlZmxlY3RpdmUgYXJpYSBwcm9wZXJ0eSBuYW1lIHR5cGVzLlxuICovXG5leHBvcnQgdHlwZSBBUklBUHJvcGVydHkgPSBFeGNsdWRlPGtleW9mIEFSSUFNaXhpbiwgJ3JvbGUnPjtcblxuLyoqXG4gKiBBY2Nlc3NpYmlsaXR5IE9iamVjdCBNb2RlbCByZWZsZWN0aXZlIGFyaWEgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGNvbnN0IEFSSUFfUFJPUEVSVElFUzogQVJJQVByb3BlcnR5W10gPSBbXG4gICdhcmlhQXRvbWljJyxcbiAgJ2FyaWFBdXRvQ29tcGxldGUnLFxuICAnYXJpYUJ1c3knLFxuICAnYXJpYUNoZWNrZWQnLFxuICAnYXJpYUNvbENvdW50JyxcbiAgJ2FyaWFDb2xJbmRleCcsXG4gICdhcmlhQ29sU3BhbicsXG4gICdhcmlhQ3VycmVudCcsXG4gICdhcmlhRGlzYWJsZWQnLFxuICAnYXJpYUV4cGFuZGVkJyxcbiAgJ2FyaWFIYXNQb3B1cCcsXG4gICdhcmlhSGlkZGVuJyxcbiAgJ2FyaWFJbnZhbGlkJyxcbiAgJ2FyaWFLZXlTaG9ydGN1dHMnLFxuICAnYXJpYUxhYmVsJyxcbiAgJ2FyaWFMZXZlbCcsXG4gICdhcmlhTGl2ZScsXG4gICdhcmlhTW9kYWwnLFxuICAnYXJpYU11bHRpTGluZScsXG4gICdhcmlhTXVsdGlTZWxlY3RhYmxlJyxcbiAgJ2FyaWFPcmllbnRhdGlvbicsXG4gICdhcmlhUGxhY2Vob2xkZXInLFxuICAnYXJpYVBvc0luU2V0JyxcbiAgJ2FyaWFQcmVzc2VkJyxcbiAgJ2FyaWFSZWFkT25seScsXG4gICdhcmlhUmVxdWlyZWQnLFxuICAnYXJpYVJvbGVEZXNjcmlwdGlvbicsXG4gICdhcmlhUm93Q291bnQnLFxuICAnYXJpYVJvd0luZGV4JyxcbiAgJ2FyaWFSb3dTcGFuJyxcbiAgJ2FyaWFTZWxlY3RlZCcsXG4gICdhcmlhU2V0U2l6ZScsXG4gICdhcmlhU29ydCcsXG4gICdhcmlhVmFsdWVNYXgnLFxuICAnYXJpYVZhbHVlTWluJyxcbiAgJ2FyaWFWYWx1ZU5vdycsXG4gICdhcmlhVmFsdWVUZXh0Jyxcbl07XG5cbi8qKlxuICogQWNjZXNzaWJpbGl0eSBPYmplY3QgTW9kZWwgYXJpYSBhdHRyaWJ1dGUgbmFtZSB0eXBlcy5cbiAqL1xuZXhwb3J0IHR5cGUgQVJJQUF0dHJpYnV0ZSA9IEFSSUFQcm9wZXJ0eVRvQXR0cmlidXRlPEFSSUFQcm9wZXJ0eT47XG5cbi8qKlxuICogQWNjZXNzaWJpbGl0eSBPYmplY3QgTW9kZWwgYXJpYSBhdHRyaWJ1dGVzLlxuICovXG5leHBvcnQgY29uc3QgQVJJQV9BVFRSSUJVVEVTID0gQVJJQV9QUk9QRVJUSUVTLm1hcChhcmlhUHJvcGVydHlUb0F0dHJpYnV0ZSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGF0dHJpYnV0ZSBpcyBvbmUgb2YgdGhlIEFPTSBhcmlhIGF0dHJpYnV0ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGlzQXJpYUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpOyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIGF0dHJpYnV0ZSBUaGUgYXR0cmlidXRlIHRvIGNoZWNrLlxuICogQHJldHVybiBUcnVlIGlmIHRoZSBhdHRyaWJ1dGUgaXMgYW4gYXJpYSBhdHRyaWJ1dGUsIG9yIGZhbHNlIGlmIG5vdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJpYUF0dHJpYnV0ZShhdHRyaWJ1dGU6IHN0cmluZyk6IGF0dHJpYnV0ZSBpcyBBUklBQXR0cmlidXRlIHtcbiAgcmV0dXJuIGF0dHJpYnV0ZS5zdGFydHNXaXRoKCdhcmlhLScpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIEFPTSBhcmlhIHByb3BlcnR5IGludG8gaXRzIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBhcmlhUHJvcGVydHlUb0F0dHJpYnV0ZSgnYXJpYUxhYmVsJyk7IC8vICdhcmlhLWxhYmVsJ1xuICpcbiAqIEBwYXJhbSBwcm9wZXJ0eSBUaGUgYXJpYSBwcm9wZXJ0eS5cbiAqIEByZXR1cm4gVGhlIGFyaWEgYXR0cmlidXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJpYVByb3BlcnR5VG9BdHRyaWJ1dGU8SyBleHRlbmRzIEFSSUFQcm9wZXJ0eSB8ICdyb2xlJz4oXG4gIHByb3BlcnR5OiBLLFxuKSB7XG4gIHJldHVybiAoXG4gICAgcHJvcGVydHlcbiAgICAgIC5yZXBsYWNlKCdhcmlhJywgJ2FyaWEtJylcbiAgICAgIC8vIElEUkVGIGF0dHJpYnV0ZXMgYWxzbyBpbmNsdWRlIGFuIFwiRWxlbWVudFwiIG9yIFwiRWxlbWVudHNcIiBzdWZmaXhcbiAgICAgIC5yZXBsYWNlKC9FbGVtZW50cz8vZywgJycpXG4gICAgICAudG9Mb3dlckNhc2UoKSBhcyBBUklBUHJvcGVydHlUb0F0dHJpYnV0ZTxLPlxuICApO1xufVxuXG4vLyBDb252ZXJ0cyBhbiBgYXJpYUZvb2Agc3RyaW5nIHR5cGUgdG8gYW4gYGFyaWEtZm9vYCBzdHJpbmcgdHlwZS5cbnR5cGUgQVJJQVByb3BlcnR5VG9BdHRyaWJ1dGU8SyBleHRlbmRzIHN0cmluZz4gPVxuICBLIGV4dGVuZHMgYGFyaWEke2luZmVyIFN1ZmZpeH1FbGVtZW50JHtpbmZlciBPcHRTfWBcbiAgICA/IGBhcmlhLSR7TG93ZXJjYXNlPFN1ZmZpeD59YFxuICAgIDogSyBleHRlbmRzIGBhcmlhJHtpbmZlciBTdWZmaXh9YFxuICAgID8gYGFyaWEtJHtMb3dlcmNhc2U8U3VmZml4Pn1gXG4gICAgOiBLO1xuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiBvZiBgQVJJQU1peGluYCB0aGF0IGVuZm9yY2VzIHN0cmljdCB2YWx1ZSB0eXBlcyBmb3IgYXJpYVxuICogcHJvcGVydGllcy5cbiAqXG4gKiBUaGlzIGlzIG5lZWRlZCBmb3IgY29ycmVjdCB0eXBpbmcgaW4gcmVuZGVyIGZ1bmN0aW9ucyB3aXRoIGxpdCBhbmFseXplci5cbiAqXG4gKiBAZXhhbXBsZVxuICogcmVuZGVyKCkge1xuICogICBjb25zdCB7YXJpYUxhYmVsfSA9IHRoaXMgYXMgQVJJQU1peGluU3RyaWN0O1xuICogICByZXR1cm4gaHRtbGBcbiAqICAgICA8YnV0dG9uIGFyaWEtbGFiZWw9JHthcmlhTGFiZWwgfHwgbm90aGluZ30+XG4gKiAgICAgICA8c2xvdD48L3Nsb3Q+XG4gKiAgICAgPC9idXR0b24+XG4gKiAgIGA7XG4gKiB9XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQVJJQU1peGluU3RyaWN0IGV4dGVuZHMgQVJJQU1peGluIHtcbiAgYXJpYUF0b21pYzogJ3RydWUnIHwgJ2ZhbHNlJyB8IG51bGw7XG4gIGFyaWFBdXRvQ29tcGxldGU6ICdub25lJyB8ICdpbmxpbmUnIHwgJ2xpc3QnIHwgJ2JvdGgnIHwgbnVsbDtcbiAgYXJpYUJ1c3k6ICd0cnVlJyB8ICdmYWxzZScgfCBudWxsO1xuICBhcmlhQ2hlY2tlZDogJ3RydWUnIHwgJ2ZhbHNlJyB8IG51bGw7XG4gIGFyaWFDb2xDb3VudDogYCR7bnVtYmVyfWAgfCBudWxsO1xuICBhcmlhQ29sSW5kZXg6IGAke251bWJlcn1gIHwgbnVsbDtcbiAgYXJpYUNvbFNwYW46IGAke251bWJlcn1gIHwgbnVsbDtcbiAgYXJpYUN1cnJlbnQ6XG4gICAgfCAncGFnZSdcbiAgICB8ICdzdGVwJ1xuICAgIHwgJ2xvY2F0aW9uJ1xuICAgIHwgJ2RhdGUnXG4gICAgfCAndGltZSdcbiAgICB8ICd0cnVlJ1xuICAgIHwgJ2ZhbHNlJ1xuICAgIHwgbnVsbDtcbiAgYXJpYURpc2FibGVkOiAndHJ1ZScgfCAnZmFsc2UnIHwgbnVsbDtcbiAgYXJpYUV4cGFuZGVkOiAndHJ1ZScgfCAnZmFsc2UnIHwgbnVsbDtcbiAgYXJpYUhhc1BvcHVwOlxuICAgIHwgJ2ZhbHNlJ1xuICAgIHwgJ3RydWUnXG4gICAgfCAnbWVudSdcbiAgICB8ICdsaXN0Ym94J1xuICAgIHwgJ3RyZWUnXG4gICAgfCAnZ3JpZCdcbiAgICB8ICdkaWFsb2cnXG4gICAgfCBudWxsO1xuICBhcmlhSGlkZGVuOiAndHJ1ZScgfCAnZmFsc2UnIHwgbnVsbDtcbiAgYXJpYUludmFsaWQ6ICd0cnVlJyB8ICdmYWxzZScgfCBudWxsO1xuICBhcmlhS2V5U2hvcnRjdXRzOiBzdHJpbmcgfCBudWxsO1xuICBhcmlhTGFiZWw6IHN0cmluZyB8IG51bGw7XG4gIGFyaWFMZXZlbDogYCR7bnVtYmVyfWAgfCBudWxsO1xuICBhcmlhTGl2ZTogJ2Fzc2VydGl2ZScgfCAnb2ZmJyB8ICdwb2xpdGUnIHwgbnVsbDtcbiAgYXJpYU1vZGFsOiAndHJ1ZScgfCAnZmFsc2UnIHwgbnVsbDtcbiAgYXJpYU11bHRpTGluZTogJ3RydWUnIHwgJ2ZhbHNlJyB8IG51bGw7XG4gIGFyaWFNdWx0aVNlbGVjdGFibGU6ICd0cnVlJyB8ICdmYWxzZScgfCBudWxsO1xuICBhcmlhT3JpZW50YXRpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcgfCAndW5kZWZpbmVkJyB8IG51bGw7XG4gIGFyaWFQbGFjZWhvbGRlcjogc3RyaW5nIHwgbnVsbDtcbiAgYXJpYVBvc0luU2V0OiBgJHtudW1iZXJ9YCB8IG51bGw7XG4gIGFyaWFQcmVzc2VkOiAndHJ1ZScgfCAnZmFsc2UnIHwgbnVsbDtcbiAgYXJpYVJlYWRPbmx5OiAndHJ1ZScgfCAnZmFsc2UnIHwgbnVsbDtcbiAgYXJpYVJlcXVpcmVkOiAndHJ1ZScgfCAnZmFsc2UnIHwgbnVsbDtcbiAgYXJpYVJvbGVEZXNjcmlwdGlvbjogc3RyaW5nIHwgbnVsbDtcbiAgYXJpYVJvd0NvdW50OiBgJHtudW1iZXJ9YCB8IG51bGw7XG4gIGFyaWFSb3dJbmRleDogYCR7bnVtYmVyfWAgfCBudWxsO1xuICBhcmlhUm93U3BhbjogYCR7bnVtYmVyfWAgfCBudWxsO1xuICBhcmlhU2VsZWN0ZWQ6ICd0cnVlJyB8ICdmYWxzZScgfCBudWxsO1xuICBhcmlhU2V0U2l6ZTogYCR7bnVtYmVyfWAgfCBudWxsO1xuICBhcmlhU29ydDogJ2FzY2VuZGluZycgfCAnZGVzY2VuZGluZycgfCAnbm9uZScgfCAnb3RoZXInIHwgbnVsbDtcbiAgYXJpYVZhbHVlTWF4OiBgJHtudW1iZXJ9YCB8IG51bGw7XG4gIGFyaWFWYWx1ZU1pbjogYCR7bnVtYmVyfWAgfCBudWxsO1xuICBhcmlhVmFsdWVOb3c6IGAke251bWJlcn1gIHwgbnVsbDtcbiAgYXJpYVZhbHVlVGV4dDogc3RyaW5nIHwgbnVsbDtcbiAgcm9sZTogQVJJQVJvbGUgfCBudWxsO1xufVxuXG4vKipcbiAqIFZhbGlkIHZhbHVlcyBmb3IgYHJvbGVgLlxuICovXG5leHBvcnQgdHlwZSBBUklBUm9sZSA9XG4gIHwgJ2FsZXJ0J1xuICB8ICdhbGVydGRpYWxvZydcbiAgfCAnYnV0dG9uJ1xuICB8ICdjaGVja2JveCdcbiAgfCAnZGlhbG9nJ1xuICB8ICdncmlkY2VsbCdcbiAgfCAnbGluaydcbiAgfCAnbG9nJ1xuICB8ICdtYXJxdWVlJ1xuICB8ICdtZW51aXRlbSdcbiAgfCAnbWVudWl0ZW1jaGVja2JveCdcbiAgfCAnbWVudWl0ZW1yYWRpbydcbiAgfCAnb3B0aW9uJ1xuICB8ICdwcm9ncmVzc2JhcidcbiAgfCAncmFkaW8nXG4gIHwgJ3Njcm9sbGJhcidcbiAgfCAnc2VhcmNoYm94J1xuICB8ICdzbGlkZXInXG4gIHwgJ3NwaW5idXR0b24nXG4gIHwgJ3N0YXR1cydcbiAgfCAnc3dpdGNoJ1xuICB8ICd0YWInXG4gIHwgJ3RhYnBhbmVsJ1xuICB8ICd0ZXh0Ym94J1xuICB8ICd0aW1lcidcbiAgfCAndG9vbHRpcCdcbiAgfCAndHJlZWl0ZW0nXG4gIHwgJ2NvbWJvYm94J1xuICB8ICdncmlkJ1xuICB8ICdsaXN0Ym94J1xuICB8ICdtZW51J1xuICB8ICdtZW51YmFyJ1xuICB8ICdyYWRpb2dyb3VwJ1xuICB8ICd0YWJsaXN0J1xuICB8ICd0cmVlJ1xuICB8ICd0cmVlZ3JpZCdcbiAgfCAnYXBwbGljYXRpb24nXG4gIHwgJ2FydGljbGUnXG4gIHwgJ2NlbGwnXG4gIHwgJ2NvbHVtbmhlYWRlcidcbiAgfCAnZGVmaW5pdGlvbidcbiAgfCAnZGlyZWN0b3J5J1xuICB8ICdkb2N1bWVudCdcbiAgfCAnZmVlZCdcbiAgfCAnZmlndXJlJ1xuICB8ICdncm91cCdcbiAgfCAnaGVhZGluZydcbiAgfCAnaW1nJ1xuICB8ICdsaXN0J1xuICB8ICdsaXN0aXRlbSdcbiAgfCAnbWF0aCdcbiAgfCAnbm9uZSdcbiAgfCAnbm90ZSdcbiAgfCAncHJlc2VudGF0aW9uJ1xuICB8ICdyZWdpb24nXG4gIHwgJ3JvdydcbiAgfCAncm93Z3JvdXAnXG4gIHwgJ3Jvd2hlYWRlcidcbiAgfCAnc2VwYXJhdG9yJ1xuICB8ICd0YWJsZSdcbiAgfCAndGVybSdcbiAgfCAndGV4dCdcbiAgfCAndG9vbGJhcidcbiAgfCAnYmFubmVyJ1xuICB8ICdjb21wbGVtZW50YXJ5J1xuICB8ICdjb250ZW50aW5mbydcbiAgfCAnZm9ybSdcbiAgfCAnbWFpbidcbiAgfCAnbmF2aWdhdGlvbidcbiAgfCAncmVnaW9uJ1xuICB8ICdzZWFyY2gnXG4gIHwgJ2RvYy1hYnN0cmFjdCdcbiAgfCAnZG9jLWFja25vd2xlZGdtZW50cydcbiAgfCAnZG9jLWFmdGVyd29yZCdcbiAgfCAnZG9jLWFwcGVuZGl4J1xuICB8ICdkb2MtYmFja2xpbmsnXG4gIHwgJ2RvYy1iaWJsaW9lbnRyeSdcbiAgfCAnZG9jLWJpYmxpb2dyYXBoeSdcbiAgfCAnZG9jLWJpYmxpb3JlZidcbiAgfCAnZG9jLWNoYXB0ZXInXG4gIHwgJ2RvYy1jb2xvcGhvbidcbiAgfCAnZG9jLWNvbmNsdXNpb24nXG4gIHwgJ2RvYy1jb3ZlcidcbiAgfCAnZG9jLWNyZWRpdCdcbiAgfCAnZG9jLWNyZWRpdHMnXG4gIHwgJ2RvYy1kZWRpY2F0aW9uJ1xuICB8ICdkb2MtZW5kbm90ZSdcbiAgfCAnZG9jLWVuZG5vdGVzJ1xuICB8ICdkb2MtZXBpZ3JhcGgnXG4gIHwgJ2RvYy1lcGlsb2d1ZSdcbiAgfCAnZG9jLWVycmF0YSdcbiAgfCAnZG9jLWV4YW1wbGUnXG4gIHwgJ2RvYy1mb290bm90ZSdcbiAgfCAnZG9jLWZvcmV3b3JkJ1xuICB8ICdkb2MtZ2xvc3NhcnknXG4gIHwgJ2RvYy1nbG9zc3JlZidcbiAgfCAnZG9jLWluZGV4J1xuICB8ICdkb2MtaW50cm9kdWN0aW9uJ1xuICB8ICdkb2Mtbm90ZXJlZidcbiAgfCAnZG9jLW5vdGljZSdcbiAgfCAnZG9jLXBhZ2VicmVhaydcbiAgfCAnZG9jLXBhZ2VsaXN0J1xuICB8ICdkb2MtcGFydCdcbiAgfCAnZG9jLXByZWZhY2UnXG4gIHwgJ2RvYy1wcm9sb2d1ZSdcbiAgfCAnZG9jLXB1bGxxdW90ZSdcbiAgfCAnZG9jLXFuYSdcbiAgfCAnZG9jLXN1YnRpdGxlJ1xuICB8ICdkb2MtdGlwJ1xuICB8ICdkb2MtdG9jJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@material/web/internal/aria/aria.js\n");

/***/ }),

/***/ "./node_modules/@material/web/internal/aria/delegate.js":
/*!**************************************************************!*\
  !*** ./node_modules/@material/web/internal/aria/delegate.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requestUpdateOnAriaChange: () => (/* binding */ requestUpdateOnAriaChange)\n/* harmony export */ });\n/* harmony import */ var _aria_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aria.js */ \"./node_modules/@material/web/internal/aria/aria.js\");\n/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Sets up a `ReactiveElement` constructor to enable updates when delegating\n * aria attributes. Elements may bind `this.aria*` properties to `aria-*`\n * attributes in their render functions.\n *\n * This function will:\n * - Call `requestUpdate()` when an aria attribute changes.\n * - Add `role=\"presentation\"` to the host.\n *\n * NOTE: The following features are not currently supported:\n * - Delegating IDREF attributes (ex: `aria-labelledby`, `aria-controls`)\n * - Delegating the `role` attribute\n *\n * @example\n * class XButton extends LitElement {\n *   static {\n *     requestUpdateOnAriaChange(XButton);\n *   }\n *\n *   protected override render() {\n *     return html`\n *       <button aria-label=${this.ariaLabel || nothing}>\n *         <slot></slot>\n *       </button>\n *     `;\n *   }\n * }\n *\n * @param ctor The `ReactiveElement` constructor to patch.\n */\nfunction requestUpdateOnAriaChange(ctor) {\n  for (const ariaProperty of _aria_js__WEBPACK_IMPORTED_MODULE_0__.ARIA_PROPERTIES) {\n    ctor.createProperty(ariaProperty, {\n      attribute: (0,_aria_js__WEBPACK_IMPORTED_MODULE_0__.ariaPropertyToAttribute)(ariaProperty),\n      reflect: true\n    });\n  }\n  ctor.addInitializer(element => {\n    const controller = {\n      hostConnected() {\n        element.setAttribute('role', 'presentation');\n      }\n    };\n    element.addController(controller);\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3dlYi9pbnRlcm5hbC9hcmlhL2RlbGVnYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7O0FBUUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9kZWxlZ2F0ZS50cz8wNjdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHtSZWFjdGl2ZUVsZW1lbnR9IGZyb20gJ2xpdCc7XG5cbmltcG9ydCB7QVJJQV9QUk9QRVJUSUVTLCBhcmlhUHJvcGVydHlUb0F0dHJpYnV0ZX0gZnJvbSAnLi9hcmlhLmpzJztcblxuLyoqXG4gKiBTZXRzIHVwIGEgYFJlYWN0aXZlRWxlbWVudGAgY29uc3RydWN0b3IgdG8gZW5hYmxlIHVwZGF0ZXMgd2hlbiBkZWxlZ2F0aW5nXG4gKiBhcmlhIGF0dHJpYnV0ZXMuIEVsZW1lbnRzIG1heSBiaW5kIGB0aGlzLmFyaWEqYCBwcm9wZXJ0aWVzIHRvIGBhcmlhLSpgXG4gKiBhdHRyaWJ1dGVzIGluIHRoZWlyIHJlbmRlciBmdW5jdGlvbnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsOlxuICogLSBDYWxsIGByZXF1ZXN0VXBkYXRlKClgIHdoZW4gYW4gYXJpYSBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAqIC0gQWRkIGByb2xlPVwicHJlc2VudGF0aW9uXCJgIHRvIHRoZSBob3N0LlxuICpcbiAqIE5PVEU6IFRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkOlxuICogLSBEZWxlZ2F0aW5nIElEUkVGIGF0dHJpYnV0ZXMgKGV4OiBgYXJpYS1sYWJlbGxlZGJ5YCwgYGFyaWEtY29udHJvbHNgKVxuICogLSBEZWxlZ2F0aW5nIHRoZSBgcm9sZWAgYXR0cmlidXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGNsYXNzIFhCdXR0b24gZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAqICAgc3RhdGljIHtcbiAqICAgICByZXF1ZXN0VXBkYXRlT25BcmlhQ2hhbmdlKFhCdXR0b24pO1xuICogICB9XG4gKlxuICogICBwcm90ZWN0ZWQgb3ZlcnJpZGUgcmVuZGVyKCkge1xuICogICAgIHJldHVybiBodG1sYFxuICogICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPSR7dGhpcy5hcmlhTGFiZWwgfHwgbm90aGluZ30+XG4gKiAgICAgICAgIDxzbG90Pjwvc2xvdD5cbiAqICAgICAgIDwvYnV0dG9uPlxuICogICAgIGA7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gY3RvciBUaGUgYFJlYWN0aXZlRWxlbWVudGAgY29uc3RydWN0b3IgdG8gcGF0Y2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0VXBkYXRlT25BcmlhQ2hhbmdlKGN0b3I6IHR5cGVvZiBSZWFjdGl2ZUVsZW1lbnQpIHtcbiAgZm9yIChjb25zdCBhcmlhUHJvcGVydHkgb2YgQVJJQV9QUk9QRVJUSUVTKSB7XG4gICAgY3Rvci5jcmVhdGVQcm9wZXJ0eShhcmlhUHJvcGVydHksIHtcbiAgICAgIGF0dHJpYnV0ZTogYXJpYVByb3BlcnR5VG9BdHRyaWJ1dGUoYXJpYVByb3BlcnR5KSxcbiAgICAgIHJlZmxlY3Q6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICBjdG9yLmFkZEluaXRpYWxpemVyKChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IHtcbiAgICAgIGhvc3RDb25uZWN0ZWQoKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgZWxlbWVudC5hZGRDb250cm9sbGVyKGNvbnRyb2xsZXIpO1xuICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@material/web/internal/aria/delegate.js\n");

/***/ }),

/***/ "./node_modules/element-internals-polyfill/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/element-internals-polyfill/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n(function (exports) {\n  'use strict';\n\n  const refMap = new WeakMap();\n  const validityMap = new WeakMap();\n  const hiddenInputMap = new WeakMap();\n  const internalsMap = new WeakMap();\n  const validationMessageMap = new WeakMap();\n  const formsMap = new WeakMap();\n  const shadowHostsMap = new WeakMap();\n  const formElementsMap = new WeakMap();\n  const refValueMap = new WeakMap();\n  const upgradeMap = new WeakMap();\n  const shadowRootMap = new WeakMap();\n  const validationAnchorMap = new WeakMap();\n  const documentFragmentMap = new WeakMap();\n  const connectedCallbackMap = new WeakMap();\n  const validityUpgradeMap = new WeakMap();\n  const aom = {\n    ariaAtomic: 'aria-atomic',\n    ariaAutoComplete: 'aria-autocomplete',\n    ariaBusy: 'aria-busy',\n    ariaChecked: 'aria-checked',\n    ariaColCount: 'aria-colcount',\n    ariaColIndex: 'aria-colindex',\n    ariaColIndexText: 'aria-colindextext',\n    ariaColSpan: 'aria-colspan',\n    ariaCurrent: 'aria-current',\n    ariaDisabled: 'aria-disabled',\n    ariaExpanded: 'aria-expanded',\n    ariaHasPopup: 'aria-haspopup',\n    ariaHidden: 'aria-hidden',\n    ariaInvalid: 'aria-invalid',\n    ariaKeyShortcuts: 'aria-keyshortcuts',\n    ariaLabel: 'aria-label',\n    ariaLevel: 'aria-level',\n    ariaLive: 'aria-live',\n    ariaModal: 'aria-modal',\n    ariaMultiLine: 'aria-multiline',\n    ariaMultiSelectable: 'aria-multiselectable',\n    ariaOrientation: 'aria-orientation',\n    ariaPlaceholder: 'aria-placeholder',\n    ariaPosInSet: 'aria-posinset',\n    ariaPressed: 'aria-pressed',\n    ariaReadOnly: 'aria-readonly',\n    ariaRelevant: 'aria-relevant',\n    ariaRequired: 'aria-required',\n    ariaRoleDescription: 'aria-roledescription',\n    ariaRowCount: 'aria-rowcount',\n    ariaRowIndex: 'aria-rowindex',\n    ariaRowIndexText: 'aria-rowindextext',\n    ariaRowSpan: 'aria-rowspan',\n    ariaSelected: 'aria-selected',\n    ariaSetSize: 'aria-setsize',\n    ariaSort: 'aria-sort',\n    ariaValueMax: 'aria-valuemax',\n    ariaValueMin: 'aria-valuemin',\n    ariaValueNow: 'aria-valuenow',\n    ariaValueText: 'aria-valuetext',\n    role: 'role'\n  };\n  const initAom = (ref, internals) => {\n    for (let key in aom) {\n      internals[key] = null;\n      let closureValue = null;\n      const attributeName = aom[key];\n      Object.defineProperty(internals, key, {\n        get() {\n          return closureValue;\n        },\n        set(value) {\n          closureValue = value;\n          if (ref.isConnected) {\n            ref.setAttribute(attributeName, value);\n          } else {\n            upgradeMap.set(ref, internals);\n          }\n        }\n      });\n    }\n  };\n  function initNode(node) {\n    const internals = internalsMap.get(node);\n    const {\n      form\n    } = internals;\n    initForm(node, form, internals);\n    initLabels(node, internals.labels);\n  }\n  const walkFieldset = (node, firstRender = false) => {\n    const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, {\n      acceptNode(node) {\n        return internalsMap.has(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n      }\n    });\n    let current = walker.nextNode();\n    const isCallNecessary = !firstRender || node.disabled;\n    while (current) {\n      if (current.formDisabledCallback && isCallNecessary) {\n        setDisabled(current, node.disabled);\n      }\n      current = walker.nextNode();\n    }\n  };\n  const disabledOrNameObserverConfig = {\n    attributes: true,\n    attributeFilter: ['disabled', 'name']\n  };\n  const disabledOrNameObserver = mutationObserverExists() ? new MutationObserver(mutationsList => {\n    for (const mutation of mutationsList) {\n      const target = mutation.target;\n      if (mutation.attributeName === 'disabled') {\n        if (target.constructor['formAssociated']) {\n          setDisabled(target, target.hasAttribute('disabled'));\n        } else if (target.localName === 'fieldset') {\n          walkFieldset(target);\n        }\n      }\n      if (mutation.attributeName === 'name') {\n        if (target.constructor['formAssociated']) {\n          const internals = internalsMap.get(target);\n          const value = refValueMap.get(target);\n          internals.setFormValue(value);\n        }\n      }\n    }\n  }) : {};\n  function observerCallback(mutationList) {\n    mutationList.forEach(mutationRecord => {\n      const {\n        addedNodes,\n        removedNodes\n      } = mutationRecord;\n      const added = Array.from(addedNodes);\n      const removed = Array.from(removedNodes);\n      added.forEach(node => {\n        if (internalsMap.has(node) && node.constructor['formAssociated']) {\n          initNode(node);\n        }\n        if (upgradeMap.has(node)) {\n          const internals = upgradeMap.get(node);\n          const aomKeys = Object.keys(aom);\n          aomKeys.filter(key => internals[key] !== null).forEach(key => {\n            node.setAttribute(aom[key], internals[key]);\n          });\n          upgradeMap.delete(node);\n        }\n        if (validityUpgradeMap.has(node)) {\n          const internals = validityUpgradeMap.get(node);\n          node.setAttribute('internals-valid', internals.validity.valid.toString());\n          node.setAttribute('internals-invalid', (!internals.validity.valid).toString());\n          node.setAttribute('aria-invalid', (!internals.validity.valid).toString());\n          validityUpgradeMap.delete(node);\n        }\n        if (node.localName === 'form') {\n          const formElements = formElementsMap.get(node);\n          const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, {\n            acceptNode(node) {\n              return internalsMap.has(node) && node.constructor['formAssociated'] && !(formElements && formElements.has(node)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n            }\n          });\n          let current = walker.nextNode();\n          while (current) {\n            initNode(current);\n            current = walker.nextNode();\n          }\n        }\n        if (node.localName === 'fieldset') {\n          var _disabledOrNameObserv;\n          (_disabledOrNameObserv = disabledOrNameObserver.observe) === null || _disabledOrNameObserv === void 0 || _disabledOrNameObserv.call(disabledOrNameObserver, node, disabledOrNameObserverConfig);\n          walkFieldset(node, true);\n        }\n      });\n      removed.forEach(node => {\n        const internals = internalsMap.get(node);\n        if (internals && hiddenInputMap.get(internals)) {\n          removeHiddenInputs(internals);\n        }\n        if (shadowHostsMap.has(node)) {\n          const observer = shadowHostsMap.get(node);\n          observer.disconnect();\n        }\n      });\n    });\n  }\n  function fragmentObserverCallback(mutationList) {\n    mutationList.forEach(mutation => {\n      const {\n        removedNodes\n      } = mutation;\n      removedNodes.forEach(node => {\n        const observer = documentFragmentMap.get(mutation.target);\n        if (internalsMap.has(node)) {\n          upgradeInternals(node);\n        }\n        observer.disconnect();\n      });\n    });\n  }\n  const deferUpgrade = fragment => {\n    var _window, _observer$observe;\n    const observer = new MutationObserver(fragmentObserverCallback);\n    if ((_window = window) !== null && _window !== void 0 && (_window = _window.ShadyDOM) !== null && _window !== void 0 && _window.inUse && fragment.mode && fragment.host) {\n      fragment = fragment.host;\n    }\n    (_observer$observe = observer.observe) === null || _observer$observe === void 0 || _observer$observe.call(observer, fragment, {\n      childList: true\n    });\n    documentFragmentMap.set(fragment, observer);\n  };\n  mutationObserverExists() ? new MutationObserver(observerCallback) : {};\n  const observerConfig = {\n    childList: true,\n    subtree: true\n  };\n  const setDisabled = (ref, disabled) => {\n    ref.toggleAttribute('internals-disabled', disabled);\n    if (disabled) {\n      ref.setAttribute('aria-disabled', 'true');\n    } else {\n      ref.removeAttribute('aria-disabled');\n    }\n    if (ref.formDisabledCallback) {\n      ref.formDisabledCallback.apply(ref, [disabled]);\n    }\n  };\n  const removeHiddenInputs = internals => {\n    const hiddenInputs = hiddenInputMap.get(internals);\n    hiddenInputs.forEach(hiddenInput => {\n      hiddenInput.remove();\n    });\n    hiddenInputMap.set(internals, []);\n  };\n  const createHiddenInput = (ref, internals) => {\n    const input = document.createElement('input');\n    input.type = 'hidden';\n    input.name = ref.getAttribute('name');\n    ref.after(input);\n    hiddenInputMap.get(internals).push(input);\n    return input;\n  };\n  const initRef = (ref, internals) => {\n    var _disabledOrNameObserv2;\n    hiddenInputMap.set(internals, []);\n    (_disabledOrNameObserv2 = disabledOrNameObserver.observe) === null || _disabledOrNameObserv2 === void 0 || _disabledOrNameObserv2.call(disabledOrNameObserver, ref, disabledOrNameObserverConfig);\n  };\n  const initLabels = (ref, labels) => {\n    if (labels.length) {\n      Array.from(labels).forEach(label => label.addEventListener('click', ref.click.bind(ref)));\n      let firstLabelId = labels[0].id;\n      if (!labels[0].id) {\n        firstLabelId = `${labels[0].htmlFor}_Label`;\n        labels[0].id = firstLabelId;\n      }\n      ref.setAttribute('aria-labelledby', firstLabelId);\n    }\n  };\n  const setFormValidity = form => {\n    const nativeControlValidity = Array.from(form.elements).filter(element => !element.tagName.includes('-') && element.validity).map(element => element.validity.valid);\n    const polyfilledElements = formElementsMap.get(form) || [];\n    const polyfilledValidity = Array.from(polyfilledElements).filter(control => control.isConnected).map(control => internalsMap.get(control).validity.valid);\n    const hasInvalid = [...nativeControlValidity, ...polyfilledValidity].includes(false);\n    form.toggleAttribute('internals-invalid', hasInvalid);\n    form.toggleAttribute('internals-valid', !hasInvalid);\n  };\n  const formInputCallback = event => {\n    setFormValidity(findParentForm(event.target));\n  };\n  const formChangeCallback = event => {\n    setFormValidity(findParentForm(event.target));\n  };\n  const wireSubmitLogic = form => {\n    const submitButtonSelector = ['button[type=submit]', 'input[type=submit]', 'button:not([type])'].map(sel => `${sel}:not([disabled])`).map(sel => `${sel}:not([form])${form.id ? `,${sel}[form='${form.id}']` : ''}`).join(',');\n    form.addEventListener('click', event => {\n      const target = event.target;\n      if (target.closest(submitButtonSelector)) {\n        const elements = formElementsMap.get(form);\n        if (form.noValidate) {\n          return;\n        }\n        if (elements.size) {\n          const nodes = Array.from(elements);\n          const validityList = nodes.reverse().map(node => {\n            const internals = internalsMap.get(node);\n            return internals.reportValidity();\n          });\n          if (validityList.includes(false)) {\n            event.preventDefault();\n          }\n        }\n      }\n    });\n  };\n  const formResetCallback = event => {\n    const elements = formElementsMap.get(event.target);\n    if (elements && elements.size) {\n      elements.forEach(element => {\n        if (element.constructor.formAssociated && element.formResetCallback) {\n          element.formResetCallback.apply(element);\n        }\n      });\n    }\n  };\n  const initForm = (ref, form, internals) => {\n    if (form) {\n      const formElements = formElementsMap.get(form);\n      if (formElements) {\n        formElements.add(ref);\n      } else {\n        const initSet = new Set();\n        initSet.add(ref);\n        formElementsMap.set(form, initSet);\n        wireSubmitLogic(form);\n        form.addEventListener('reset', formResetCallback);\n        form.addEventListener('input', formInputCallback);\n        form.addEventListener('change', formChangeCallback);\n      }\n      formsMap.set(form, {\n        ref,\n        internals\n      });\n      if (ref.constructor['formAssociated'] && ref.formAssociatedCallback) {\n        setTimeout(() => {\n          ref.formAssociatedCallback.apply(ref, [form]);\n        }, 0);\n      }\n      setFormValidity(form);\n    }\n  };\n  const findParentForm = elem => {\n    let parent = elem.parentNode;\n    if (parent && parent.tagName !== 'FORM') {\n      parent = findParentForm(parent);\n    }\n    return parent;\n  };\n  const throwIfNotFormAssociated = (ref, message, ErrorType = DOMException) => {\n    if (!ref.constructor['formAssociated']) {\n      throw new ErrorType(message);\n    }\n  };\n  const overrideFormMethod = (form, returnValue, method) => {\n    const elements = formElementsMap.get(form);\n    if (elements && elements.size) {\n      elements.forEach(element => {\n        const internals = internalsMap.get(element);\n        const valid = internals[method]();\n        if (!valid) {\n          returnValue = false;\n        }\n      });\n    }\n    return returnValue;\n  };\n  const upgradeInternals = ref => {\n    if (ref.constructor['formAssociated']) {\n      const internals = internalsMap.get(ref);\n      const {\n        labels,\n        form\n      } = internals;\n      initLabels(ref, labels);\n      initForm(ref, form, internals);\n    }\n  };\n  function mutationObserverExists() {\n    return typeof MutationObserver !== 'undefined';\n  }\n  class ValidityState {\n    constructor() {\n      this.badInput = false;\n      this.customError = false;\n      this.patternMismatch = false;\n      this.rangeOverflow = false;\n      this.rangeUnderflow = false;\n      this.stepMismatch = false;\n      this.tooLong = false;\n      this.tooShort = false;\n      this.typeMismatch = false;\n      this.valid = true;\n      this.valueMissing = false;\n      Object.seal(this);\n    }\n  }\n  const setValid = validityObject => {\n    validityObject.badInput = false;\n    validityObject.customError = false;\n    validityObject.patternMismatch = false;\n    validityObject.rangeOverflow = false;\n    validityObject.rangeUnderflow = false;\n    validityObject.stepMismatch = false;\n    validityObject.tooLong = false;\n    validityObject.tooShort = false;\n    validityObject.typeMismatch = false;\n    validityObject.valid = true;\n    validityObject.valueMissing = false;\n    return validityObject;\n  };\n  const reconcileValidity = (validityObject, newState, form) => {\n    validityObject.valid = isValid(newState);\n    Object.keys(newState).forEach(key => validityObject[key] = newState[key]);\n    if (form) {\n      setFormValidity(form);\n    }\n    return validityObject;\n  };\n  const isValid = validityState => {\n    let valid = true;\n    for (let key in validityState) {\n      if (key !== 'valid' && validityState[key] !== false) {\n        valid = false;\n      }\n    }\n    return valid;\n  };\n  const customStateMap = new WeakMap();\n  function addState(ref, stateName) {\n    ref.toggleAttribute(stateName, true);\n    if (ref.part) {\n      ref.part.add(stateName);\n    }\n  }\n  class CustomStateSet extends Set {\n    static get isPolyfilled() {\n      return true;\n    }\n    constructor(ref) {\n      super();\n      if (!ref || !ref.tagName || ref.tagName.indexOf('-') === -1) {\n        throw new TypeError('Illegal constructor');\n      }\n      customStateMap.set(this, ref);\n    }\n    add(state) {\n      if (!/^--/.test(state) || typeof state !== 'string') {\n        throw new DOMException(`Failed to execute 'add' on 'CustomStateSet': The specified value ${state} must start with '--'.`);\n      }\n      const result = super.add(state);\n      const ref = customStateMap.get(this);\n      const stateName = `state${state}`;\n      if (ref.isConnected) {\n        addState(ref, stateName);\n      } else {\n        setTimeout(() => {\n          addState(ref, stateName);\n        });\n      }\n      return result;\n    }\n    clear() {\n      for (let [entry] of this.entries()) {\n        this.delete(entry);\n      }\n      super.clear();\n    }\n    delete(state) {\n      const result = super.delete(state);\n      const ref = customStateMap.get(this);\n      if (ref.isConnected) {\n        ref.toggleAttribute(`state${state}`, false);\n        if (ref.part) {\n          ref.part.remove(`state${state}`);\n        }\n      } else {\n        setTimeout(() => {\n          ref.toggleAttribute(`state${state}`, false);\n          if (ref.part) {\n            ref.part.remove(`state${state}`);\n          }\n        });\n      }\n      return result;\n    }\n  }\n  function __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n  }\n  function __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n  }\n  var _HTMLFormControlsCollection_elements;\n  class HTMLFormControlsCollection {\n    constructor(elements) {\n      _HTMLFormControlsCollection_elements.set(this, void 0);\n      __classPrivateFieldSet(this, _HTMLFormControlsCollection_elements, elements, \"f\");\n      for (let i = 0; i < elements.length; i++) {\n        let element = elements[i];\n        this[i] = element;\n        if (element.hasAttribute('name')) {\n          this[element.getAttribute('name')] = element;\n        }\n      }\n      Object.freeze(this);\n    }\n    get length() {\n      return __classPrivateFieldGet(this, _HTMLFormControlsCollection_elements, \"f\").length;\n    }\n    [(_HTMLFormControlsCollection_elements = new WeakMap(), Symbol.iterator)]() {\n      return __classPrivateFieldGet(this, _HTMLFormControlsCollection_elements, \"f\")[Symbol.iterator]();\n    }\n    item(i) {\n      return this[i] == null ? null : this[i];\n    }\n    namedItem(name) {\n      return this[name] == null ? null : this[name];\n    }\n  }\n  function patchFormPrototype() {\n    const checkValidity = HTMLFormElement.prototype.checkValidity;\n    HTMLFormElement.prototype.checkValidity = checkValidityOverride;\n    const reportValidity = HTMLFormElement.prototype.reportValidity;\n    HTMLFormElement.prototype.reportValidity = reportValidityOverride;\n    function checkValidityOverride(...args) {\n      let returnValue = checkValidity.apply(this, args);\n      return overrideFormMethod(this, returnValue, 'checkValidity');\n    }\n    function reportValidityOverride(...args) {\n      let returnValue = reportValidity.apply(this, args);\n      return overrideFormMethod(this, returnValue, 'reportValidity');\n    }\n    const {\n      get\n    } = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'elements');\n    Object.defineProperty(HTMLFormElement.prototype, 'elements', {\n      get(...args) {\n        const elements = get.call(this, ...args);\n        const polyfilledElements = Array.from(formElementsMap.get(this) || []);\n        if (polyfilledElements.length === 0) {\n          return elements;\n        }\n        const orderedElements = Array.from(elements).concat(polyfilledElements).sort((a, b) => {\n          if (a.compareDocumentPosition) {\n            return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n          }\n          return 0;\n        });\n        return new HTMLFormControlsCollection(orderedElements);\n      }\n    });\n  }\n  class ElementInternals {\n    static get isPolyfilled() {\n      return true;\n    }\n    constructor(ref) {\n      if (!ref || !ref.tagName || ref.tagName.indexOf('-') === -1) {\n        throw new TypeError('Illegal constructor');\n      }\n      const rootNode = ref.getRootNode();\n      const validity = new ValidityState();\n      this.states = new CustomStateSet(ref);\n      refMap.set(this, ref);\n      validityMap.set(this, validity);\n      internalsMap.set(ref, this);\n      initAom(ref, this);\n      initRef(ref, this);\n      Object.seal(this);\n      if (rootNode instanceof DocumentFragment) {\n        deferUpgrade(rootNode);\n      }\n    }\n    checkValidity() {\n      const ref = refMap.get(this);\n      throwIfNotFormAssociated(ref, `Failed to execute 'checkValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n      if (!this.willValidate) {\n        return true;\n      }\n      const validity = validityMap.get(this);\n      if (!validity.valid) {\n        const validityEvent = new Event('invalid', {\n          bubbles: false,\n          cancelable: true,\n          composed: false\n        });\n        ref.dispatchEvent(validityEvent);\n      }\n      return validity.valid;\n    }\n    get form() {\n      const ref = refMap.get(this);\n      throwIfNotFormAssociated(ref, `Failed to read the 'form' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n      let form;\n      if (ref.constructor['formAssociated'] === true) {\n        form = findParentForm(ref);\n      }\n      return form;\n    }\n    get labels() {\n      const ref = refMap.get(this);\n      throwIfNotFormAssociated(ref, `Failed to read the 'labels' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n      const id = ref.getAttribute('id');\n      const hostRoot = ref.getRootNode();\n      if (hostRoot && id) {\n        return hostRoot.querySelectorAll(`[for=\"${id}\"]`);\n      }\n      return [];\n    }\n    reportValidity() {\n      const ref = refMap.get(this);\n      throwIfNotFormAssociated(ref, `Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n      if (!this.willValidate) {\n        return true;\n      }\n      const valid = this.checkValidity();\n      const anchor = validationAnchorMap.get(this);\n      if (anchor && !ref.constructor['formAssociated']) {\n        throw new DOMException(`Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n      }\n      if (!valid && anchor) {\n        ref.focus();\n        anchor.focus();\n      }\n      return valid;\n    }\n    setFormValue(value) {\n      const ref = refMap.get(this);\n      throwIfNotFormAssociated(ref, `Failed to execute 'setFormValue' on 'ElementInternals': The target element is not a form-associated custom element.`);\n      removeHiddenInputs(this);\n      if (value != null && !(value instanceof FormData)) {\n        if (ref.getAttribute('name')) {\n          const hiddenInput = createHiddenInput(ref, this);\n          hiddenInput.value = value;\n        }\n      } else if (value != null && value instanceof FormData) {\n        Array.from(value).reverse().forEach(([formDataKey, formDataValue]) => {\n          if (typeof formDataValue === 'string') {\n            const hiddenInput = createHiddenInput(ref, this);\n            hiddenInput.name = formDataKey;\n            hiddenInput.value = formDataValue;\n          }\n        });\n      }\n      refValueMap.set(ref, value);\n    }\n    setValidity(validityChanges, validationMessage, anchor) {\n      const ref = refMap.get(this);\n      throwIfNotFormAssociated(ref, `Failed to execute 'setValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n      if (!validityChanges) {\n        throw new TypeError('Failed to execute \\'setValidity\\' on \\'ElementInternals\\': 1 argument required, but only 0 present.');\n      }\n      validationAnchorMap.set(this, anchor);\n      const validity = validityMap.get(this);\n      const validityChangesObj = {};\n      for (const key in validityChanges) {\n        validityChangesObj[key] = validityChanges[key];\n      }\n      if (Object.keys(validityChangesObj).length === 0) {\n        setValid(validity);\n      }\n      const check = {\n        ...validity,\n        ...validityChangesObj\n      };\n      delete check.valid;\n      const {\n        valid\n      } = reconcileValidity(validity, check, this.form);\n      if (!valid && !validationMessage) {\n        throw new DOMException(`Failed to execute 'setValidity' on 'ElementInternals': The second argument should not be empty if one or more flags in the first argument are true.`);\n      }\n      validationMessageMap.set(this, valid ? '' : validationMessage);\n      if (ref.isConnected) {\n        ref.toggleAttribute('internals-invalid', !valid);\n        ref.toggleAttribute('internals-valid', valid);\n        ref.setAttribute('aria-invalid', `${!valid}`);\n      } else {\n        validityUpgradeMap.set(ref, this);\n      }\n    }\n    get shadowRoot() {\n      const ref = refMap.get(this);\n      const shadowRoot = shadowRootMap.get(ref);\n      if (shadowRoot) {\n        return shadowRoot;\n      }\n      return null;\n    }\n    get validationMessage() {\n      const ref = refMap.get(this);\n      throwIfNotFormAssociated(ref, `Failed to read the 'validationMessage' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n      return validationMessageMap.get(this);\n    }\n    get validity() {\n      const ref = refMap.get(this);\n      throwIfNotFormAssociated(ref, `Failed to read the 'validity' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n      const validity = validityMap.get(this);\n      return validity;\n    }\n    get willValidate() {\n      const ref = refMap.get(this);\n      throwIfNotFormAssociated(ref, `Failed to read the 'willValidate' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n      if (ref.disabled || ref.hasAttribute('disabled') || ref.hasAttribute('readonly')) {\n        return false;\n      }\n      return true;\n    }\n  }\n  function isElementInternalsSupported() {\n    if (typeof window === 'undefined' || !window.ElementInternals || !HTMLElement.prototype.attachInternals) {\n      return false;\n    }\n    class ElementInternalsFeatureDetection extends HTMLElement {\n      constructor() {\n        super();\n        this.internals = this.attachInternals();\n      }\n    }\n    const randomName = `element-internals-feature-detection-${Math.random().toString(36).replace(/[^a-z]+/g, '')}`;\n    customElements.define(randomName, ElementInternalsFeatureDetection);\n    const featureDetectionElement = new ElementInternalsFeatureDetection();\n    return ['shadowRoot', 'form', 'willValidate', 'validity', 'validationMessage', 'labels', 'setFormValue', 'setValidity', 'checkValidity', 'reportValidity'].every(prop => prop in featureDetectionElement.internals);\n  }\n  let hasElementInternalsPolyfillBeenApplied = false;\n  let hasCustomStateSetPolyfillBeenApplied = false;\n  function forceCustomStateSetPolyfill(attachInternals) {\n    if (hasCustomStateSetPolyfillBeenApplied) {\n      return;\n    }\n    hasCustomStateSetPolyfillBeenApplied = true;\n    window.CustomStateSet = CustomStateSet;\n    if (attachInternals) {\n      HTMLElement.prototype.attachInternals = function (...args) {\n        const internals = attachInternals.call(this, args);\n        internals.states = new CustomStateSet(this);\n        return internals;\n      };\n    }\n  }\n  function forceElementInternalsPolyfill(forceCustomStateSet = true) {\n    if (hasElementInternalsPolyfillBeenApplied) {\n      return;\n    }\n    hasElementInternalsPolyfillBeenApplied = true;\n    if (typeof window !== 'undefined') {\n      window.ElementInternals = ElementInternals;\n    }\n    if (typeof CustomElementRegistry !== 'undefined') {\n      const define = CustomElementRegistry.prototype.define;\n      CustomElementRegistry.prototype.define = function (name, constructor, options) {\n        if (constructor.formAssociated) {\n          const connectedCallback = constructor.prototype.connectedCallback;\n          constructor.prototype.connectedCallback = function () {\n            if (!connectedCallbackMap.has(this)) {\n              connectedCallbackMap.set(this, true);\n              if (this.hasAttribute('disabled')) {\n                setDisabled(this, true);\n              }\n            }\n            if (connectedCallback != null) {\n              connectedCallback.apply(this);\n            }\n            upgradeInternals(this);\n          };\n        }\n        define.call(this, name, constructor, options);\n      };\n    }\n    if (typeof HTMLElement !== 'undefined') {\n      HTMLElement.prototype.attachInternals = function () {\n        if (!this.tagName) {\n          return {};\n        } else if (this.tagName.indexOf('-') === -1) {\n          throw new Error(`Failed to execute 'attachInternals' on 'HTMLElement': Unable to attach ElementInternals to non-custom elements.`);\n        }\n        if (internalsMap.has(this)) {\n          throw new DOMException(`DOMException: Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.`);\n        }\n        return new ElementInternals(this);\n      };\n    }\n    if (typeof Element !== 'undefined') {\n      function attachShadowObserver(...args) {\n        const shadowRoot = attachShadow.apply(this, args);\n        shadowRootMap.set(this, shadowRoot);\n        if (mutationObserverExists()) {\n          const observer = new MutationObserver(observerCallback);\n          if (window.ShadyDOM) {\n            observer.observe(this, observerConfig);\n          } else {\n            observer.observe(shadowRoot, observerConfig);\n          }\n          shadowHostsMap.set(this, observer);\n        }\n        return shadowRoot;\n      }\n      const attachShadow = Element.prototype.attachShadow;\n      Element.prototype.attachShadow = attachShadowObserver;\n    }\n    if (mutationObserverExists() && typeof document !== 'undefined') {\n      const documentObserver = new MutationObserver(observerCallback);\n      documentObserver.observe(document.documentElement, observerConfig);\n    }\n    if (typeof HTMLFormElement !== 'undefined') {\n      patchFormPrototype();\n    }\n    if (forceCustomStateSet || typeof window !== \"undefined\" && !window.CustomStateSet) {\n      forceCustomStateSetPolyfill();\n    }\n  }\n  const isCePolyfill = !!customElements.polyfillWrapFlushCallback;\n  if (!isCePolyfill) {\n    if (!isElementInternalsSupported()) {\n      forceElementInternalsPolyfill(false);\n    } else if (typeof window !== \"undefined\" && !window.CustomStateSet) {\n      forceCustomStateSetPolyfill(HTMLElement.prototype.attachInternals);\n    }\n  }\n  exports.forceCustomStateSetPolyfill = forceCustomStateSetPolyfill;\n  exports.forceElementInternalsPolyfill = forceElementInternalsPolyfill;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  return exports;\n})({});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWxlbWVudC1pbnRlcm5hbHMtcG9seWZpbGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9lbGVtZW50LWludGVybmFscy1wb2x5ZmlsbC9kaXN0L2luZGV4LmpzPzYzNTEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgcmVmTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCB2YWxpZGl0eU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3QgaGlkZGVuSW5wdXRNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IGludGVybmFsc01hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3QgdmFsaWRhdGlvbk1lc3NhZ2VNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IGZvcm1zTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBzaGFkb3dIb3N0c01hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3QgZm9ybUVsZW1lbnRzTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCByZWZWYWx1ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3QgdXBncmFkZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3Qgc2hhZG93Um9vdE1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3QgdmFsaWRhdGlvbkFuY2hvck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3QgZG9jdW1lbnRGcmFnbWVudE1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3QgY29ubmVjdGVkQ2FsbGJhY2tNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IHZhbGlkaXR5VXBncmFkZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICBjb25zdCBhb20gPSB7XG4gICAgICAgIGFyaWFBdG9taWM6ICdhcmlhLWF0b21pYycsXG4gICAgICAgIGFyaWFBdXRvQ29tcGxldGU6ICdhcmlhLWF1dG9jb21wbGV0ZScsXG4gICAgICAgIGFyaWFCdXN5OiAnYXJpYS1idXN5JyxcbiAgICAgICAgYXJpYUNoZWNrZWQ6ICdhcmlhLWNoZWNrZWQnLFxuICAgICAgICBhcmlhQ29sQ291bnQ6ICdhcmlhLWNvbGNvdW50JyxcbiAgICAgICAgYXJpYUNvbEluZGV4OiAnYXJpYS1jb2xpbmRleCcsXG4gICAgICAgIGFyaWFDb2xJbmRleFRleHQ6ICdhcmlhLWNvbGluZGV4dGV4dCcsXG4gICAgICAgIGFyaWFDb2xTcGFuOiAnYXJpYS1jb2xzcGFuJyxcbiAgICAgICAgYXJpYUN1cnJlbnQ6ICdhcmlhLWN1cnJlbnQnLFxuICAgICAgICBhcmlhRGlzYWJsZWQ6ICdhcmlhLWRpc2FibGVkJyxcbiAgICAgICAgYXJpYUV4cGFuZGVkOiAnYXJpYS1leHBhbmRlZCcsXG4gICAgICAgIGFyaWFIYXNQb3B1cDogJ2FyaWEtaGFzcG9wdXAnLFxuICAgICAgICBhcmlhSGlkZGVuOiAnYXJpYS1oaWRkZW4nLFxuICAgICAgICBhcmlhSW52YWxpZDogJ2FyaWEtaW52YWxpZCcsXG4gICAgICAgIGFyaWFLZXlTaG9ydGN1dHM6ICdhcmlhLWtleXNob3J0Y3V0cycsXG4gICAgICAgIGFyaWFMYWJlbDogJ2FyaWEtbGFiZWwnLFxuICAgICAgICBhcmlhTGV2ZWw6ICdhcmlhLWxldmVsJyxcbiAgICAgICAgYXJpYUxpdmU6ICdhcmlhLWxpdmUnLFxuICAgICAgICBhcmlhTW9kYWw6ICdhcmlhLW1vZGFsJyxcbiAgICAgICAgYXJpYU11bHRpTGluZTogJ2FyaWEtbXVsdGlsaW5lJyxcbiAgICAgICAgYXJpYU11bHRpU2VsZWN0YWJsZTogJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJyxcbiAgICAgICAgYXJpYU9yaWVudGF0aW9uOiAnYXJpYS1vcmllbnRhdGlvbicsXG4gICAgICAgIGFyaWFQbGFjZWhvbGRlcjogJ2FyaWEtcGxhY2Vob2xkZXInLFxuICAgICAgICBhcmlhUG9zSW5TZXQ6ICdhcmlhLXBvc2luc2V0JyxcbiAgICAgICAgYXJpYVByZXNzZWQ6ICdhcmlhLXByZXNzZWQnLFxuICAgICAgICBhcmlhUmVhZE9ubHk6ICdhcmlhLXJlYWRvbmx5JyxcbiAgICAgICAgYXJpYVJlbGV2YW50OiAnYXJpYS1yZWxldmFudCcsXG4gICAgICAgIGFyaWFSZXF1aXJlZDogJ2FyaWEtcmVxdWlyZWQnLFxuICAgICAgICBhcmlhUm9sZURlc2NyaXB0aW9uOiAnYXJpYS1yb2xlZGVzY3JpcHRpb24nLFxuICAgICAgICBhcmlhUm93Q291bnQ6ICdhcmlhLXJvd2NvdW50JyxcbiAgICAgICAgYXJpYVJvd0luZGV4OiAnYXJpYS1yb3dpbmRleCcsXG4gICAgICAgIGFyaWFSb3dJbmRleFRleHQ6ICdhcmlhLXJvd2luZGV4dGV4dCcsXG4gICAgICAgIGFyaWFSb3dTcGFuOiAnYXJpYS1yb3dzcGFuJyxcbiAgICAgICAgYXJpYVNlbGVjdGVkOiAnYXJpYS1zZWxlY3RlZCcsXG4gICAgICAgIGFyaWFTZXRTaXplOiAnYXJpYS1zZXRzaXplJyxcbiAgICAgICAgYXJpYVNvcnQ6ICdhcmlhLXNvcnQnLFxuICAgICAgICBhcmlhVmFsdWVNYXg6ICdhcmlhLXZhbHVlbWF4JyxcbiAgICAgICAgYXJpYVZhbHVlTWluOiAnYXJpYS12YWx1ZW1pbicsXG4gICAgICAgIGFyaWFWYWx1ZU5vdzogJ2FyaWEtdmFsdWVub3cnLFxuICAgICAgICBhcmlhVmFsdWVUZXh0OiAnYXJpYS12YWx1ZXRleHQnLFxuICAgICAgICByb2xlOiAncm9sZSdcbiAgICB9O1xuICAgIGNvbnN0IGluaXRBb20gPSAocmVmLCBpbnRlcm5hbHMpID0+IHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGFvbSkge1xuICAgICAgICAgICAgaW50ZXJuYWxzW2tleV0gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGNsb3N1cmVWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gYW9tW2tleV07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW50ZXJuYWxzLCBrZXksIHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zdXJlVmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc3VyZVZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWYuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZi5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBncmFkZU1hcC5zZXQocmVmLCBpbnRlcm5hbHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW5pdE5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBpbnRlcm5hbHMgPSBpbnRlcm5hbHNNYXAuZ2V0KG5vZGUpO1xuICAgICAgICBjb25zdCB7IGZvcm0gfSA9IGludGVybmFscztcbiAgICAgICAgaW5pdEZvcm0obm9kZSwgZm9ybSwgaW50ZXJuYWxzKTtcbiAgICAgICAgaW5pdExhYmVscyhub2RlLCBpbnRlcm5hbHMubGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3Qgd2Fsa0ZpZWxkc2V0ID0gKG5vZGUsIGZpcnN0UmVuZGVyID0gZmFsc2UpID0+IHtcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihub2RlLCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwge1xuICAgICAgICAgICAgYWNjZXB0Tm9kZShub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsc01hcC5oYXMobm9kZSkgP1xuICAgICAgICAgICAgICAgICAgICBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgY29uc3QgaXNDYWxsTmVjZXNzYXJ5ID0gKCFmaXJzdFJlbmRlciB8fCBub2RlLmRpc2FibGVkKTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmZvcm1EaXNhYmxlZENhbGxiYWNrICYmIGlzQ2FsbE5lY2Vzc2FyeSkge1xuICAgICAgICAgICAgICAgIHNldERpc2FibGVkKGN1cnJlbnQsIG5vZGUuZGlzYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkaXNhYmxlZE9yTmFtZU9ic2VydmVyQ29uZmlnID0geyBhdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVGaWx0ZXI6IFsnZGlzYWJsZWQnLCAnbmFtZSddIH07XG4gICAgY29uc3QgZGlzYWJsZWRPck5hbWVPYnNlcnZlciA9IG11dGF0aW9uT2JzZXJ2ZXJFeGlzdHMoKSA/IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnNMaXN0KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNvbnN0cnVjdG9yWydmb3JtQXNzb2NpYXRlZCddKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERpc2FibGVkKHRhcmdldCwgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldC5sb2NhbE5hbWUgPT09ICdmaWVsZHNldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa0ZpZWxkc2V0KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09ICduYW1lJykge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29uc3RydWN0b3JbJ2Zvcm1Bc3NvY2lhdGVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxzID0gaW50ZXJuYWxzTWFwLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlZlZhbHVlTWFwLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuc2V0Rm9ybVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSA6IHt9O1xuICAgIGZ1bmN0aW9uIG9ic2VydmVyQ2FsbGJhY2sobXV0YXRpb25MaXN0KSB7XG4gICAgICAgIG11dGF0aW9uTGlzdC5mb3JFYWNoKG11dGF0aW9uUmVjb3JkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzIH0gPSBtdXRhdGlvblJlY29yZDtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkID0gQXJyYXkuZnJvbShhZGRlZE5vZGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSBBcnJheS5mcm9tKHJlbW92ZWROb2Rlcyk7XG4gICAgICAgICAgICBhZGRlZC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHNNYXAuaGFzKG5vZGUpICYmIG5vZGUuY29uc3RydWN0b3JbJ2Zvcm1Bc3NvY2lhdGVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cGdyYWRlTWFwLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbHMgPSB1cGdyYWRlTWFwLmdldChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW9tS2V5cyA9IE9iamVjdC5rZXlzKGFvbSk7XG4gICAgICAgICAgICAgICAgICAgIGFvbUtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoa2V5ID0+IGludGVybmFsc1trZXldICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGFvbVtrZXldLCBpbnRlcm5hbHNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB1cGdyYWRlTWFwLmRlbGV0ZShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkaXR5VXBncmFkZU1hcC5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxzID0gdmFsaWRpdHlVcGdyYWRlTWFwLmdldChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2ludGVybmFscy12YWxpZCcsIGludGVybmFscy52YWxpZGl0eS52YWxpZC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2ludGVybmFscy1pbnZhbGlkJywgKCFpbnRlcm5hbHMudmFsaWRpdHkudmFsaWQpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgKCFpbnRlcm5hbHMudmFsaWRpdHkudmFsaWQpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGl0eVVwZ3JhZGVNYXAuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT09ICdmb3JtJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtRWxlbWVudHMgPSBmb3JtRWxlbWVudHNNYXAuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKG5vZGUsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHROb2RlKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGludGVybmFsc01hcC5oYXMobm9kZSkgJiYgbm9kZS5jb25zdHJ1Y3RvclsnZm9ybUFzc29jaWF0ZWQnXSAmJiAhKGZvcm1FbGVtZW50cyAmJiBmb3JtRWxlbWVudHMuaGFzKG5vZGUpKSkgPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXROb2RlKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PT0gJ2ZpZWxkc2V0Jykge1xuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZE9yTmFtZU9ic2VydmVyLm9ic2VydmU/Lihub2RlLCBkaXNhYmxlZE9yTmFtZU9ic2VydmVyQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa0ZpZWxkc2V0KG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVtb3ZlZC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFscyA9IGludGVybmFsc01hcC5nZXQobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscyAmJiBoaWRkZW5JbnB1dE1hcC5nZXQoaW50ZXJuYWxzKSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVIaWRkZW5JbnB1dHMoaW50ZXJuYWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNoYWRvd0hvc3RzTWFwLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IHNoYWRvd0hvc3RzTWFwLmdldChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnJhZ21lbnRPYnNlcnZlckNhbGxiYWNrKG11dGF0aW9uTGlzdCkge1xuICAgICAgICBtdXRhdGlvbkxpc3QuZm9yRWFjaChtdXRhdGlvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHJlbW92ZWROb2RlcyB9ID0gbXV0YXRpb247XG4gICAgICAgICAgICByZW1vdmVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IGRvY3VtZW50RnJhZ21lbnRNYXAuZ2V0KG11dGF0aW9uLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFsc01hcC5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBncmFkZUludGVybmFscyhub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBkZWZlclVwZ3JhZGUgPSAoZnJhZ21lbnQpID0+IHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmcmFnbWVudE9ic2VydmVyQ2FsbGJhY2spO1xuICAgICAgICBpZiAod2luZG93Py5TaGFkeURPTT8uaW5Vc2UgJiZcbiAgICAgICAgICAgIGZyYWdtZW50Lm1vZGUgJiZcbiAgICAgICAgICAgIGZyYWdtZW50Lmhvc3QpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlPy4oZnJhZ21lbnQsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICBkb2N1bWVudEZyYWdtZW50TWFwLnNldChmcmFnbWVudCwgb2JzZXJ2ZXIpO1xuICAgIH07XG4gICAgbXV0YXRpb25PYnNlcnZlckV4aXN0cygpID8gbmV3IE11dGF0aW9uT2JzZXJ2ZXIob2JzZXJ2ZXJDYWxsYmFjaykgOiB7fTtcbiAgICBjb25zdCBvYnNlcnZlckNvbmZpZyA9IHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0IHNldERpc2FibGVkID0gKHJlZiwgZGlzYWJsZWQpID0+IHtcbiAgICAgICAgcmVmLnRvZ2dsZUF0dHJpYnV0ZSgnaW50ZXJuYWxzLWRpc2FibGVkJywgZGlzYWJsZWQpO1xuICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJlZi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYuZm9ybURpc2FibGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlZi5mb3JtRGlzYWJsZWRDYWxsYmFjay5hcHBseShyZWYsIFtkaXNhYmxlZF0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVIaWRkZW5JbnB1dHMgPSAoaW50ZXJuYWxzKSA9PiB7XG4gICAgICAgIGNvbnN0IGhpZGRlbklucHV0cyA9IGhpZGRlbklucHV0TWFwLmdldChpbnRlcm5hbHMpO1xuICAgICAgICBoaWRkZW5JbnB1dHMuZm9yRWFjaChoaWRkZW5JbnB1dCA9PiB7XG4gICAgICAgICAgICBoaWRkZW5JbnB1dC5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhpZGRlbklucHV0TWFwLnNldChpbnRlcm5hbHMsIFtdKTtcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZUhpZGRlbklucHV0ID0gKHJlZiwgaW50ZXJuYWxzKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgaW5wdXQudHlwZSA9ICdoaWRkZW4nO1xuICAgICAgICBpbnB1dC5uYW1lID0gcmVmLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgICByZWYuYWZ0ZXIoaW5wdXQpO1xuICAgICAgICBoaWRkZW5JbnB1dE1hcC5nZXQoaW50ZXJuYWxzKS5wdXNoKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH07XG4gICAgY29uc3QgaW5pdFJlZiA9IChyZWYsIGludGVybmFscykgPT4ge1xuICAgICAgICBoaWRkZW5JbnB1dE1hcC5zZXQoaW50ZXJuYWxzLCBbXSk7XG4gICAgICAgIGRpc2FibGVkT3JOYW1lT2JzZXJ2ZXIub2JzZXJ2ZT8uKHJlZiwgZGlzYWJsZWRPck5hbWVPYnNlcnZlckNvbmZpZyk7XG4gICAgfTtcbiAgICBjb25zdCBpbml0TGFiZWxzID0gKHJlZiwgbGFiZWxzKSA9PiB7XG4gICAgICAgIGlmIChsYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKGxhYmVscykuZm9yRWFjaChsYWJlbCA9PiBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJlZi5jbGljay5iaW5kKHJlZikpKTtcbiAgICAgICAgICAgIGxldCBmaXJzdExhYmVsSWQgPSBsYWJlbHNbMF0uaWQ7XG4gICAgICAgICAgICBpZiAoIWxhYmVsc1swXS5pZCkge1xuICAgICAgICAgICAgICAgIGZpcnN0TGFiZWxJZCA9IGAke2xhYmVsc1swXS5odG1sRm9yfV9MYWJlbGA7XG4gICAgICAgICAgICAgICAgbGFiZWxzWzBdLmlkID0gZmlyc3RMYWJlbElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5JywgZmlyc3RMYWJlbElkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0Rm9ybVZhbGlkaXR5ID0gKGZvcm0pID0+IHtcbiAgICAgICAgY29uc3QgbmF0aXZlQ29udHJvbFZhbGlkaXR5ID0gQXJyYXkuZnJvbShmb3JtLmVsZW1lbnRzKVxuICAgICAgICAgICAgLmZpbHRlcigoZWxlbWVudCkgPT4gIWVsZW1lbnQudGFnTmFtZS5pbmNsdWRlcygnLScpICYmIGVsZW1lbnQudmFsaWRpdHkpXG4gICAgICAgICAgICAubWFwKChlbGVtZW50KSA9PiBlbGVtZW50LnZhbGlkaXR5LnZhbGlkKTtcbiAgICAgICAgY29uc3QgcG9seWZpbGxlZEVsZW1lbnRzID0gZm9ybUVsZW1lbnRzTWFwLmdldChmb3JtKSB8fCBbXTtcbiAgICAgICAgY29uc3QgcG9seWZpbGxlZFZhbGlkaXR5ID0gQXJyYXkuZnJvbShwb2x5ZmlsbGVkRWxlbWVudHMpXG4gICAgICAgICAgICAuZmlsdGVyKGNvbnRyb2wgPT4gY29udHJvbC5pc0Nvbm5lY3RlZClcbiAgICAgICAgICAgIC5tYXAoKGNvbnRyb2wpID0+IGludGVybmFsc01hcC5nZXQoY29udHJvbCkudmFsaWRpdHkudmFsaWQpO1xuICAgICAgICBjb25zdCBoYXNJbnZhbGlkID0gWy4uLm5hdGl2ZUNvbnRyb2xWYWxpZGl0eSwgLi4ucG9seWZpbGxlZFZhbGlkaXR5XS5pbmNsdWRlcyhmYWxzZSk7XG4gICAgICAgIGZvcm0udG9nZ2xlQXR0cmlidXRlKCdpbnRlcm5hbHMtaW52YWxpZCcsIGhhc0ludmFsaWQpO1xuICAgICAgICBmb3JtLnRvZ2dsZUF0dHJpYnV0ZSgnaW50ZXJuYWxzLXZhbGlkJywgIWhhc0ludmFsaWQpO1xuICAgIH07XG4gICAgY29uc3QgZm9ybUlucHV0Q2FsbGJhY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgc2V0Rm9ybVZhbGlkaXR5KGZpbmRQYXJlbnRGb3JtKGV2ZW50LnRhcmdldCkpO1xuICAgIH07XG4gICAgY29uc3QgZm9ybUNoYW5nZUNhbGxiYWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHNldEZvcm1WYWxpZGl0eShmaW5kUGFyZW50Rm9ybShldmVudC50YXJnZXQpKTtcbiAgICB9O1xuICAgIGNvbnN0IHdpcmVTdWJtaXRMb2dpYyA9IChmb3JtKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1Ym1pdEJ1dHRvblNlbGVjdG9yID0gWydidXR0b25bdHlwZT1zdWJtaXRdJywgJ2lucHV0W3R5cGU9c3VibWl0XScsICdidXR0b246bm90KFt0eXBlXSknXVxuICAgICAgICAgICAgLm1hcChzZWwgPT4gYCR7c2VsfTpub3QoW2Rpc2FibGVkXSlgKVxuICAgICAgICAgICAgLm1hcChzZWwgPT4gYCR7c2VsfTpub3QoW2Zvcm1dKSR7Zm9ybS5pZCA/IGAsJHtzZWx9W2Zvcm09JyR7Zm9ybS5pZH0nXWAgOiAnJ31gKVxuICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgZm9ybS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuY2xvc2VzdChzdWJtaXRCdXR0b25TZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGZvcm1FbGVtZW50c01hcC5nZXQoZm9ybSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm0ubm9WYWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gQXJyYXkuZnJvbShlbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkaXR5TGlzdCA9IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxzID0gaW50ZXJuYWxzTWFwLmdldChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMucmVwb3J0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGl0eUxpc3QuaW5jbHVkZXMoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcm1SZXNldENhbGxiYWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZm9ybUVsZW1lbnRzTWFwLmdldChldmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoZWxlbWVudHMgJiYgZWxlbWVudHMuc2l6ZSkge1xuICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jb25zdHJ1Y3Rvci5mb3JtQXNzb2NpYXRlZCAmJiBlbGVtZW50LmZvcm1SZXNldENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZm9ybVJlc2V0Q2FsbGJhY2suYXBwbHkoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluaXRGb3JtID0gKHJlZiwgZm9ybSwgaW50ZXJuYWxzKSA9PiB7XG4gICAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRWxlbWVudHMgPSBmb3JtRWxlbWVudHNNYXAuZ2V0KGZvcm0pO1xuICAgICAgICAgICAgaWYgKGZvcm1FbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGZvcm1FbGVtZW50cy5hZGQocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgaW5pdFNldC5hZGQocmVmKTtcbiAgICAgICAgICAgICAgICBmb3JtRWxlbWVudHNNYXAuc2V0KGZvcm0sIGluaXRTZXQpO1xuICAgICAgICAgICAgICAgIHdpcmVTdWJtaXRMb2dpYyhmb3JtKTtcbiAgICAgICAgICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2V0JywgZm9ybVJlc2V0Q2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBmb3JtSW5wdXRDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgZm9ybS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmb3JtQ2hhbmdlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9ybXNNYXAuc2V0KGZvcm0sIHsgcmVmLCBpbnRlcm5hbHMgfSk7XG4gICAgICAgICAgICBpZiAocmVmLmNvbnN0cnVjdG9yWydmb3JtQXNzb2NpYXRlZCddICYmIHJlZi5mb3JtQXNzb2NpYXRlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5mb3JtQXNzb2NpYXRlZENhbGxiYWNrLmFwcGx5KHJlZiwgW2Zvcm1dKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEZvcm1WYWxpZGl0eShmb3JtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZmluZFBhcmVudEZvcm0gPSAoZWxlbSkgPT4ge1xuICAgICAgICBsZXQgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50YWdOYW1lICE9PSAnRk9STScpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IGZpbmRQYXJlbnRGb3JtKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9O1xuICAgIGNvbnN0IHRocm93SWZOb3RGb3JtQXNzb2NpYXRlZCA9IChyZWYsIG1lc3NhZ2UsIEVycm9yVHlwZSA9IERPTUV4Y2VwdGlvbikgPT4ge1xuICAgICAgICBpZiAoIXJlZi5jb25zdHJ1Y3RvclsnZm9ybUFzc29jaWF0ZWQnXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yVHlwZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb3ZlcnJpZGVGb3JtTWV0aG9kID0gKGZvcm0sIHJldHVyblZhbHVlLCBtZXRob2QpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBmb3JtRWxlbWVudHNNYXAuZ2V0KGZvcm0pO1xuICAgICAgICBpZiAoZWxlbWVudHMgJiYgZWxlbWVudHMuc2l6ZSkge1xuICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbHMgPSBpbnRlcm5hbHNNYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gaW50ZXJuYWxzW21ldGhvZF0oKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH07XG4gICAgY29uc3QgdXBncmFkZUludGVybmFscyA9IChyZWYpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jb25zdHJ1Y3RvclsnZm9ybUFzc29jaWF0ZWQnXSkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxzID0gaW50ZXJuYWxzTWFwLmdldChyZWYpO1xuICAgICAgICAgICAgY29uc3QgeyBsYWJlbHMsIGZvcm0gfSA9IGludGVybmFscztcbiAgICAgICAgICAgIGluaXRMYWJlbHMocmVmLCBsYWJlbHMpO1xuICAgICAgICAgICAgaW5pdEZvcm0ocmVmLCBmb3JtLCBpbnRlcm5hbHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtdXRhdGlvbk9ic2VydmVyRXhpc3RzKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIGNsYXNzIFZhbGlkaXR5U3RhdGUge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuYmFkSW5wdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGF0dGVybk1pc21hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJhbmdlT3ZlcmZsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VVbmRlcmZsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RlcE1pc21hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnRvb0xvbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudG9vU2hvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudHlwZU1pc21hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVNaXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZXRWYWxpZCA9ICh2YWxpZGl0eU9iamVjdCkgPT4ge1xuICAgICAgICB2YWxpZGl0eU9iamVjdC5iYWRJbnB1dCA9IGZhbHNlO1xuICAgICAgICB2YWxpZGl0eU9iamVjdC5jdXN0b21FcnJvciA9IGZhbHNlO1xuICAgICAgICB2YWxpZGl0eU9iamVjdC5wYXR0ZXJuTWlzbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdmFsaWRpdHlPYmplY3QucmFuZ2VPdmVyZmxvdyA9IGZhbHNlO1xuICAgICAgICB2YWxpZGl0eU9iamVjdC5yYW5nZVVuZGVyZmxvdyA9IGZhbHNlO1xuICAgICAgICB2YWxpZGl0eU9iamVjdC5zdGVwTWlzbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdmFsaWRpdHlPYmplY3QudG9vTG9uZyA9IGZhbHNlO1xuICAgICAgICB2YWxpZGl0eU9iamVjdC50b29TaG9ydCA9IGZhbHNlO1xuICAgICAgICB2YWxpZGl0eU9iamVjdC50eXBlTWlzbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdmFsaWRpdHlPYmplY3QudmFsaWQgPSB0cnVlO1xuICAgICAgICB2YWxpZGl0eU9iamVjdC52YWx1ZU1pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZhbGlkaXR5T2JqZWN0O1xuICAgIH07XG4gICAgY29uc3QgcmVjb25jaWxlVmFsaWRpdHkgPSAodmFsaWRpdHlPYmplY3QsIG5ld1N0YXRlLCBmb3JtKSA9PiB7XG4gICAgICAgIHZhbGlkaXR5T2JqZWN0LnZhbGlkID0gaXNWYWxpZChuZXdTdGF0ZSk7XG4gICAgICAgIE9iamVjdC5rZXlzKG5ld1N0YXRlKS5mb3JFYWNoKGtleSA9PiB2YWxpZGl0eU9iamVjdFtrZXldID0gbmV3U3RhdGVba2V5XSk7XG4gICAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgICAgICBzZXRGb3JtVmFsaWRpdHkoZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkaXR5T2JqZWN0O1xuICAgIH07XG4gICAgY29uc3QgaXNWYWxpZCA9ICh2YWxpZGl0eVN0YXRlKSA9PiB7XG4gICAgICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiB2YWxpZGl0eVN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAndmFsaWQnICYmIHZhbGlkaXR5U3RhdGVba2V5XSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9O1xuXG4gICAgY29uc3QgY3VzdG9tU3RhdGVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIGZ1bmN0aW9uIGFkZFN0YXRlKHJlZiwgc3RhdGVOYW1lKSB7XG4gICAgICAgIHJlZi50b2dnbGVBdHRyaWJ1dGUoc3RhdGVOYW1lLCB0cnVlKTtcbiAgICAgICAgaWYgKHJlZi5wYXJ0KSB7XG4gICAgICAgICAgICByZWYucGFydC5hZGQoc3RhdGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGFzcyBDdXN0b21TdGF0ZVNldCBleHRlbmRzIFNldCB7XG4gICAgICAgIHN0YXRpYyBnZXQgaXNQb2x5ZmlsbGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IocmVmKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgaWYgKCFyZWYgfHwgIXJlZi50YWdOYW1lIHx8IHJlZi50YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXN0b21TdGF0ZU1hcC5zZXQodGhpcywgcmVmKTtcbiAgICAgICAgfVxuICAgICAgICBhZGQoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmICghL14tLS8udGVzdChzdGF0ZSkgfHwgdHlwZW9mIHN0YXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oYEZhaWxlZCB0byBleGVjdXRlICdhZGQnIG9uICdDdXN0b21TdGF0ZVNldCc6IFRoZSBzcGVjaWZpZWQgdmFsdWUgJHtzdGF0ZX0gbXVzdCBzdGFydCB3aXRoICctLScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5hZGQoc3RhdGUpO1xuICAgICAgICAgICAgY29uc3QgcmVmID0gY3VzdG9tU3RhdGVNYXAuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVOYW1lID0gYHN0YXRlJHtzdGF0ZX1gO1xuICAgICAgICAgICAgaWYgKHJlZi5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIGFkZFN0YXRlKHJlZiwgc3RhdGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdGF0ZShyZWYsIHN0YXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgZm9yIChsZXQgW2VudHJ5XSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1cGVyLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlKHN0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5kZWxldGUoc3RhdGUpO1xuICAgICAgICAgICAgY29uc3QgcmVmID0gY3VzdG9tU3RhdGVNYXAuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKHJlZi5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJlZi50b2dnbGVBdHRyaWJ1dGUoYHN0YXRlJHtzdGF0ZX1gLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZi5wYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5wYXJ0LnJlbW92ZShgc3RhdGUke3N0YXRlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWYudG9nZ2xlQXR0cmlidXRlKGBzdGF0ZSR7c3RhdGV9YCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmLnBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZi5wYXJ0LnJlbW92ZShgc3RhdGUke3N0YXRlfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgICAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgX0hUTUxGb3JtQ29udHJvbHNDb2xsZWN0aW9uX2VsZW1lbnRzO1xuICAgIGNsYXNzIEhUTUxGb3JtQ29udHJvbHNDb2xsZWN0aW9uIHtcbiAgICAgICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIF9IVE1MRm9ybUNvbnRyb2xzQ29sbGVjdGlvbl9lbGVtZW50cy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0hUTUxGb3JtQ29udHJvbHNDb2xsZWN0aW9uX2VsZW1lbnRzLCBlbGVtZW50cywgXCJmXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCduYW1lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0hUTUxGb3JtQ29udHJvbHNDb2xsZWN0aW9uX2VsZW1lbnRzLCBcImZcIikubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIFsoX0hUTUxGb3JtQ29udHJvbHNDb2xsZWN0aW9uX2VsZW1lbnRzID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSFRNTEZvcm1Db250cm9sc0NvbGxlY3Rpb25fZWxlbWVudHMsIFwiZlwiKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbShpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tpXSA9PSBudWxsID8gbnVsbCA6IHRoaXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgbmFtZWRJdGVtKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW25hbWVdID09IG51bGwgPyBudWxsIDogdGhpc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGNoRm9ybVByb3RvdHlwZSgpIHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWxpZGl0eSA9IEhUTUxGb3JtRWxlbWVudC5wcm90b3R5cGUuY2hlY2tWYWxpZGl0eTtcbiAgICAgICAgSFRNTEZvcm1FbGVtZW50LnByb3RvdHlwZS5jaGVja1ZhbGlkaXR5ID0gY2hlY2tWYWxpZGl0eU92ZXJyaWRlO1xuICAgICAgICBjb25zdCByZXBvcnRWYWxpZGl0eSA9IEhUTUxGb3JtRWxlbWVudC5wcm90b3R5cGUucmVwb3J0VmFsaWRpdHk7XG4gICAgICAgIEhUTUxGb3JtRWxlbWVudC5wcm90b3R5cGUucmVwb3J0VmFsaWRpdHkgPSByZXBvcnRWYWxpZGl0eU92ZXJyaWRlO1xuICAgICAgICBmdW5jdGlvbiBjaGVja1ZhbGlkaXR5T3ZlcnJpZGUoLi4uYXJncykge1xuICAgICAgICAgICAgbGV0IHJldHVyblZhbHVlID0gY2hlY2tWYWxpZGl0eS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBvdmVycmlkZUZvcm1NZXRob2QodGhpcywgcmV0dXJuVmFsdWUsICdjaGVja1ZhbGlkaXR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwb3J0VmFsaWRpdHlPdmVycmlkZSguLi5hcmdzKSB7XG4gICAgICAgICAgICBsZXQgcmV0dXJuVmFsdWUgPSByZXBvcnRWYWxpZGl0eS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBvdmVycmlkZUZvcm1NZXRob2QodGhpcywgcmV0dXJuVmFsdWUsICdyZXBvcnRWYWxpZGl0eScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZ2V0IH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxGb3JtRWxlbWVudC5wcm90b3R5cGUsICdlbGVtZW50cycpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEZvcm1FbGVtZW50LnByb3RvdHlwZSwgJ2VsZW1lbnRzJywge1xuICAgICAgICAgICAgZ2V0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGdldC5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvbHlmaWxsZWRFbGVtZW50cyA9IEFycmF5LmZyb20oZm9ybUVsZW1lbnRzTWFwLmdldCh0aGlzKSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlmaWxsZWRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkRWxlbWVudHMgPSBBcnJheS5mcm9tKGVsZW1lbnRzKS5jb25jYXQocG9seWZpbGxlZEVsZW1lbnRzKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDIgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIVE1MRm9ybUNvbnRyb2xzQ29sbGVjdGlvbihvcmRlcmVkRWxlbWVudHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xhc3MgRWxlbWVudEludGVybmFscyB7XG4gICAgICAgIHN0YXRpYyBnZXQgaXNQb2x5ZmlsbGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IocmVmKSB7XG4gICAgICAgICAgICBpZiAoIXJlZiB8fCAhcmVmLnRhZ05hbWUgfHwgcmVmLnRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvb3ROb2RlID0gcmVmLmdldFJvb3ROb2RlKCk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGl0eSA9IG5ldyBWYWxpZGl0eVN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcyA9IG5ldyBDdXN0b21TdGF0ZVNldChyZWYpO1xuICAgICAgICAgICAgcmVmTWFwLnNldCh0aGlzLCByZWYpO1xuICAgICAgICAgICAgdmFsaWRpdHlNYXAuc2V0KHRoaXMsIHZhbGlkaXR5KTtcbiAgICAgICAgICAgIGludGVybmFsc01hcC5zZXQocmVmLCB0aGlzKTtcbiAgICAgICAgICAgIGluaXRBb20ocmVmLCB0aGlzKTtcbiAgICAgICAgICAgIGluaXRSZWYocmVmLCB0aGlzKTtcbiAgICAgICAgICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHJvb3ROb2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIGRlZmVyVXBncmFkZShyb290Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHJlZk1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgICB0aHJvd0lmTm90Rm9ybUFzc29jaWF0ZWQocmVmLCBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2NoZWNrVmFsaWRpdHknIG9uICdFbGVtZW50SW50ZXJuYWxzJzogVGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBhIGZvcm0tYXNzb2NpYXRlZCBjdXN0b20gZWxlbWVudC5gKTtcbiAgICAgICAgICAgIGlmICghdGhpcy53aWxsVmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbGlkaXR5ID0gdmFsaWRpdHlNYXAuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGl0eS52YWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkaXR5RXZlbnQgPSBuZXcgRXZlbnQoJ2ludmFsaWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb21wb3NlZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWYuZGlzcGF0Y2hFdmVudCh2YWxpZGl0eUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWxpZGl0eS52YWxpZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZm9ybSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHJlZk1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgICB0aHJvd0lmTm90Rm9ybUFzc29jaWF0ZWQocmVmLCBgRmFpbGVkIHRvIHJlYWQgdGhlICdmb3JtJyBwcm9wZXJ0eSBmcm9tICdFbGVtZW50SW50ZXJuYWxzJzogVGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBhIGZvcm0tYXNzb2NpYXRlZCBjdXN0b20gZWxlbWVudC5gKTtcbiAgICAgICAgICAgIGxldCBmb3JtO1xuICAgICAgICAgICAgaWYgKHJlZi5jb25zdHJ1Y3RvclsnZm9ybUFzc29jaWF0ZWQnXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGZvcm0gPSBmaW5kUGFyZW50Rm9ybShyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGxhYmVscygpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHJlZk1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgICB0aHJvd0lmTm90Rm9ybUFzc29jaWF0ZWQocmVmLCBgRmFpbGVkIHRvIHJlYWQgdGhlICdsYWJlbHMnIHByb3BlcnR5IGZyb20gJ0VsZW1lbnRJbnRlcm5hbHMnOiBUaGUgdGFyZ2V0IGVsZW1lbnQgaXMgbm90IGEgZm9ybS1hc3NvY2lhdGVkIGN1c3RvbSBlbGVtZW50LmApO1xuICAgICAgICAgICAgY29uc3QgaWQgPSByZWYuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgY29uc3QgaG9zdFJvb3QgPSByZWYuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChob3N0Um9vdCAmJiBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBob3N0Um9vdC5xdWVyeVNlbGVjdG9yQWxsKGBbZm9yPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXBvcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHJlZk1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgICB0aHJvd0lmTm90Rm9ybUFzc29jaWF0ZWQocmVmLCBgRmFpbGVkIHRvIGV4ZWN1dGUgJ3JlcG9ydFZhbGlkaXR5JyBvbiAnRWxlbWVudEludGVybmFscyc6IFRoZSB0YXJnZXQgZWxlbWVudCBpcyBub3QgYSBmb3JtLWFzc29jaWF0ZWQgY3VzdG9tIGVsZW1lbnQuYCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2lsbFZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMuY2hlY2tWYWxpZGl0eSgpO1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gdmFsaWRhdGlvbkFuY2hvck1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgICBpZiAoYW5jaG9yICYmICFyZWYuY29uc3RydWN0b3JbJ2Zvcm1Bc3NvY2lhdGVkJ10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGBGYWlsZWQgdG8gZXhlY3V0ZSAncmVwb3J0VmFsaWRpdHknIG9uICdFbGVtZW50SW50ZXJuYWxzJzogVGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBhIGZvcm0tYXNzb2NpYXRlZCBjdXN0b20gZWxlbWVudC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsaWQgJiYgYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgcmVmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgYW5jaG9yLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Rm9ybVZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSByZWZNYXAuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgdGhyb3dJZk5vdEZvcm1Bc3NvY2lhdGVkKHJlZiwgYEZhaWxlZCB0byBleGVjdXRlICdzZXRGb3JtVmFsdWUnIG9uICdFbGVtZW50SW50ZXJuYWxzJzogVGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBhIGZvcm0tYXNzb2NpYXRlZCBjdXN0b20gZWxlbWVudC5gKTtcbiAgICAgICAgICAgIHJlbW92ZUhpZGRlbklucHV0cyh0aGlzKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICEodmFsdWUgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmLmdldEF0dHJpYnV0ZSgnbmFtZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZGRlbklucHV0ID0gY3JlYXRlSGlkZGVuSW5wdXQocmVmLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuSW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHZhbHVlKS5yZXZlcnNlKCkuZm9yRWFjaCgoW2Zvcm1EYXRhS2V5LCBmb3JtRGF0YVZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1EYXRhVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoaWRkZW5JbnB1dCA9IGNyZWF0ZUhpZGRlbklucHV0KHJlZiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5JbnB1dC5uYW1lID0gZm9ybURhdGFLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5JbnB1dC52YWx1ZSA9IGZvcm1EYXRhVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZlZhbHVlTWFwLnNldChyZWYsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWxpZGl0eSh2YWxpZGl0eUNoYW5nZXMsIHZhbGlkYXRpb25NZXNzYWdlLCBhbmNob3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHJlZk1hcC5nZXQodGhpcyk7XG4gICAgICAgICAgICB0aHJvd0lmTm90Rm9ybUFzc29jaWF0ZWQocmVmLCBgRmFpbGVkIHRvIGV4ZWN1dGUgJ3NldFZhbGlkaXR5JyBvbiAnRWxlbWVudEludGVybmFscyc6IFRoZSB0YXJnZXQgZWxlbWVudCBpcyBub3QgYSBmb3JtLWFzc29jaWF0ZWQgY3VzdG9tIGVsZW1lbnQuYCk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkaXR5Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFxcJ3NldFZhbGlkaXR5XFwnIG9uIFxcJ0VsZW1lbnRJbnRlcm5hbHNcXCc6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRpb25BbmNob3JNYXAuc2V0KHRoaXMsIGFuY2hvcik7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGl0eSA9IHZhbGlkaXR5TWFwLmdldCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkaXR5Q2hhbmdlc09iaiA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsaWRpdHlDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRpdHlDaGFuZ2VzT2JqW2tleV0gPSB2YWxpZGl0eUNoYW5nZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWxpZGl0eUNoYW5nZXNPYmopLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNldFZhbGlkKHZhbGlkaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0geyAuLi52YWxpZGl0eSwgLi4udmFsaWRpdHlDaGFuZ2VzT2JqIH07XG4gICAgICAgICAgICBkZWxldGUgY2hlY2sudmFsaWQ7XG4gICAgICAgICAgICBjb25zdCB7IHZhbGlkIH0gPSByZWNvbmNpbGVWYWxpZGl0eSh2YWxpZGl0eSwgY2hlY2ssIHRoaXMuZm9ybSk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkICYmICF2YWxpZGF0aW9uTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oYEZhaWxlZCB0byBleGVjdXRlICdzZXRWYWxpZGl0eScgb24gJ0VsZW1lbnRJbnRlcm5hbHMnOiBUaGUgc2Vjb25kIGFyZ3VtZW50IHNob3VsZCBub3QgYmUgZW1wdHkgaWYgb25lIG9yIG1vcmUgZmxhZ3MgaW4gdGhlIGZpcnN0IGFyZ3VtZW50IGFyZSB0cnVlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGlvbk1lc3NhZ2VNYXAuc2V0KHRoaXMsIHZhbGlkID8gJycgOiB2YWxpZGF0aW9uTWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAocmVmLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmVmLnRvZ2dsZUF0dHJpYnV0ZSgnaW50ZXJuYWxzLWludmFsaWQnLCAhdmFsaWQpO1xuICAgICAgICAgICAgICAgIHJlZi50b2dnbGVBdHRyaWJ1dGUoJ2ludGVybmFscy12YWxpZCcsIHZhbGlkKTtcbiAgICAgICAgICAgICAgICByZWYuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCBgJHshdmFsaWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWxpZGl0eVVwZ3JhZGVNYXAuc2V0KHJlZiwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHNoYWRvd1Jvb3QoKSB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSByZWZNYXAuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IHNoYWRvd1Jvb3RNYXAuZ2V0KHJlZik7XG4gICAgICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dSb290O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHZhbGlkYXRpb25NZXNzYWdlKCkge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmTWFwLmdldCh0aGlzKTtcbiAgICAgICAgICAgIHRocm93SWZOb3RGb3JtQXNzb2NpYXRlZChyZWYsIGBGYWlsZWQgdG8gcmVhZCB0aGUgJ3ZhbGlkYXRpb25NZXNzYWdlJyBwcm9wZXJ0eSBmcm9tICdFbGVtZW50SW50ZXJuYWxzJzogVGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBhIGZvcm0tYXNzb2NpYXRlZCBjdXN0b20gZWxlbWVudC5gKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0aW9uTWVzc2FnZU1hcC5nZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHZhbGlkaXR5KCkge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmTWFwLmdldCh0aGlzKTtcbiAgICAgICAgICAgIHRocm93SWZOb3RGb3JtQXNzb2NpYXRlZChyZWYsIGBGYWlsZWQgdG8gcmVhZCB0aGUgJ3ZhbGlkaXR5JyBwcm9wZXJ0eSBmcm9tICdFbGVtZW50SW50ZXJuYWxzJzogVGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBhIGZvcm0tYXNzb2NpYXRlZCBjdXN0b20gZWxlbWVudC5gKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkaXR5ID0gdmFsaWRpdHlNYXAuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkaXR5O1xuICAgICAgICB9XG4gICAgICAgIGdldCB3aWxsVmFsaWRhdGUoKSB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSByZWZNYXAuZ2V0KHRoaXMpO1xuICAgICAgICAgICAgdGhyb3dJZk5vdEZvcm1Bc3NvY2lhdGVkKHJlZiwgYEZhaWxlZCB0byByZWFkIHRoZSAnd2lsbFZhbGlkYXRlJyBwcm9wZXJ0eSBmcm9tICdFbGVtZW50SW50ZXJuYWxzJzogVGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBhIGZvcm0tYXNzb2NpYXRlZCBjdXN0b20gZWxlbWVudC5gKTtcbiAgICAgICAgICAgIGlmICgocmVmLmRpc2FibGVkIHx8IHJlZi5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHx8XG4gICAgICAgICAgICAgICAgcmVmLmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRWxlbWVudEludGVybmFsc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuRWxlbWVudEludGVybmFscyB8fCAhSFRNTEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaEludGVybmFscykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzIEVsZW1lbnRJbnRlcm5hbHNGZWF0dXJlRGV0ZWN0aW9uIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFscyA9IHRoaXMuYXR0YWNoSW50ZXJuYWxzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZG9tTmFtZSA9IGBlbGVtZW50LWludGVybmFscy1mZWF0dXJlLWRldGVjdGlvbi0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnJlcGxhY2UoL1teYS16XSsvZywgJycpfWA7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZShyYW5kb21OYW1lLCBFbGVtZW50SW50ZXJuYWxzRmVhdHVyZURldGVjdGlvbik7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVEZXRlY3Rpb25FbGVtZW50ID0gbmV3IEVsZW1lbnRJbnRlcm5hbHNGZWF0dXJlRGV0ZWN0aW9uKCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnc2hhZG93Um9vdCcsXG4gICAgICAgICAgICAnZm9ybScsXG4gICAgICAgICAgICAnd2lsbFZhbGlkYXRlJyxcbiAgICAgICAgICAgICd2YWxpZGl0eScsXG4gICAgICAgICAgICAndmFsaWRhdGlvbk1lc3NhZ2UnLFxuICAgICAgICAgICAgJ2xhYmVscycsXG4gICAgICAgICAgICAnc2V0Rm9ybVZhbHVlJyxcbiAgICAgICAgICAgICdzZXRWYWxpZGl0eScsXG4gICAgICAgICAgICAnY2hlY2tWYWxpZGl0eScsXG4gICAgICAgICAgICAncmVwb3J0VmFsaWRpdHknXG4gICAgICAgIF0uZXZlcnkocHJvcCA9PiBwcm9wIGluIGZlYXR1cmVEZXRlY3Rpb25FbGVtZW50LmludGVybmFscyk7XG4gICAgfVxuICAgIGxldCBoYXNFbGVtZW50SW50ZXJuYWxzUG9seWZpbGxCZWVuQXBwbGllZCA9IGZhbHNlO1xuICAgIGxldCBoYXNDdXN0b21TdGF0ZVNldFBvbHlmaWxsQmVlbkFwcGxpZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBmb3JjZUN1c3RvbVN0YXRlU2V0UG9seWZpbGwoYXR0YWNoSW50ZXJuYWxzKSB7XG4gICAgICAgIGlmIChoYXNDdXN0b21TdGF0ZVNldFBvbHlmaWxsQmVlbkFwcGxpZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYXNDdXN0b21TdGF0ZVNldFBvbHlmaWxsQmVlbkFwcGxpZWQgPSB0cnVlO1xuICAgICAgICB3aW5kb3cuQ3VzdG9tU3RhdGVTZXQgPSBDdXN0b21TdGF0ZVNldDtcbiAgICAgICAgaWYgKGF0dGFjaEludGVybmFscykge1xuICAgICAgICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaEludGVybmFscyA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxzID0gYXR0YWNoSW50ZXJuYWxzLmNhbGwodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzLnN0YXRlcyA9IG5ldyBDdXN0b21TdGF0ZVNldCh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JjZUVsZW1lbnRJbnRlcm5hbHNQb2x5ZmlsbChmb3JjZUN1c3RvbVN0YXRlU2V0ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaGFzRWxlbWVudEludGVybmFsc1BvbHlmaWxsQmVlbkFwcGxpZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYXNFbGVtZW50SW50ZXJuYWxzUG9seWZpbGxCZWVuQXBwbGllZCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2luZG93LkVsZW1lbnRJbnRlcm5hbHMgPSBFbGVtZW50SW50ZXJuYWxzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgZGVmaW5lID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5kZWZpbmU7XG4gICAgICAgICAgICBDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBjb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChjb25zdHJ1Y3Rvci5mb3JtQXNzb2NpYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0ZWRDYWxsYmFjayA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25uZWN0ZWRDYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbm5lY3RlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWRDYWxsYmFja01hcC5oYXModGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRDYWxsYmFja01hcC5zZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldERpc2FibGVkKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0ZWRDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2suYXBwbHkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGdyYWRlSW50ZXJuYWxzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZpbmUuY2FsbCh0aGlzLCBuYW1lLCBjb25zdHJ1Y3Rvciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoSW50ZXJuYWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnYXR0YWNoSW50ZXJuYWxzJyBvbiAnSFRNTEVsZW1lbnQnOiBVbmFibGUgdG8gYXR0YWNoIEVsZW1lbnRJbnRlcm5hbHMgdG8gbm9uLWN1c3RvbSBlbGVtZW50cy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFsc01hcC5oYXModGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihgRE9NRXhjZXB0aW9uOiBGYWlsZWQgdG8gZXhlY3V0ZSAnYXR0YWNoSW50ZXJuYWxzJyBvbiAnSFRNTEVsZW1lbnQnOiBFbGVtZW50SW50ZXJuYWxzIGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgd2FzIGFscmVhZHkgYXR0YWNoZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudEludGVybmFscyh0aGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZnVuY3Rpb24gYXR0YWNoU2hhZG93T2JzZXJ2ZXIoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBhdHRhY2hTaGFkb3cuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgc2hhZG93Um9vdE1hcC5zZXQodGhpcywgc2hhZG93Um9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJFeGlzdHMoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG9ic2VydmVyQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LlNoYWR5RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIG9ic2VydmVyQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoc2hhZG93Um9vdCwgb2JzZXJ2ZXJDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0hvc3RzTWFwLnNldCh0aGlzLCBvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dSb290O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXR0YWNoU2hhZG93ID0gRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93O1xuICAgICAgICAgICAgRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93ID0gYXR0YWNoU2hhZG93T2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJFeGlzdHMoKSAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIob2JzZXJ2ZXJDYWxsYmFjayk7XG4gICAgICAgICAgICBkb2N1bWVudE9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBvYnNlcnZlckNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MRm9ybUVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXRjaEZvcm1Qcm90b3R5cGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yY2VDdXN0b21TdGF0ZVNldCB8fFxuICAgICAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXdpbmRvdy5DdXN0b21TdGF0ZVNldCkpIHtcbiAgICAgICAgICAgIGZvcmNlQ3VzdG9tU3RhdGVTZXRQb2x5ZmlsbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaXNDZVBvbHlmaWxsID0gISFjdXN0b21FbGVtZW50cy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrO1xuICAgIGlmICghaXNDZVBvbHlmaWxsKSB7XG4gICAgICAgIGlmICghaXNFbGVtZW50SW50ZXJuYWxzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIGZvcmNlRWxlbWVudEludGVybmFsc1BvbHlmaWxsKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICF3aW5kb3cuQ3VzdG9tU3RhdGVTZXQpIHtcbiAgICAgICAgICAgIGZvcmNlQ3VzdG9tU3RhdGVTZXRQb2x5ZmlsbChIVE1MRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoSW50ZXJuYWxzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHMuZm9yY2VDdXN0b21TdGF0ZVNldFBvbHlmaWxsID0gZm9yY2VDdXN0b21TdGF0ZVNldFBvbHlmaWxsO1xuICAgIGV4cG9ydHMuZm9yY2VFbGVtZW50SW50ZXJuYWxzUG9seWZpbGwgPSBmb3JjZUVsZW1lbnRJbnRlcm5hbHNQb2x5ZmlsbDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgICByZXR1cm4gZXhwb3J0cztcblxufSkoe30pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/element-internals-polyfill/dist/index.js\n");

/***/ })

};
