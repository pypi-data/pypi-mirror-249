/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
export const id = "vendors-node_modules_qr-scanner_qr-scanner_min_js";
export const ids = ["vendors-node_modules_qr-scanner_qr-scanner_min_js"];
export const modules = {

/***/ "./node_modules/qr-scanner/qr-scanner.min.js":
/*!***************************************************!*\
  !*** ./node_modules/qr-scanner/qr-scanner.min.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass e {\n  constructor(a, b, c, d, f) {\n    this._legacyCanvasSize = e.DEFAULT_CANVAS_SIZE;\n    this._preferredCamera = \"environment\";\n    this._maxScansPerSecond = 25;\n    this._lastScanTimestamp = -1;\n    this._destroyed = this._flashOn = this._paused = this._active = !1;\n    this.$video = a;\n    this.$canvas = document.createElement(\"canvas\");\n    c && \"object\" === typeof c ? this._onDecode = b : (c || d || f ? console.warn(\"You're using a deprecated version of the QrScanner constructor which will be removed in the future\") : console.warn(\"Note that the type of the scan result passed to onDecode will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.\"), this._legacyOnDecode = b);\n    b = \"object\" === typeof c ? c : {};\n    this._onDecodeError = b.onDecodeError || (\"function\" === typeof c ? c : this._onDecodeError);\n    this._calculateScanRegion = b.calculateScanRegion || (\"function\" === typeof d ? d : this._calculateScanRegion);\n    this._preferredCamera = b.preferredCamera || f || this._preferredCamera;\n    this._legacyCanvasSize = \"number\" === typeof c ? c : \"number\" === typeof d ? d : this._legacyCanvasSize;\n    this._maxScansPerSecond = b.maxScansPerSecond || this._maxScansPerSecond;\n    this._onPlay = this._onPlay.bind(this);\n    this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n    this._onVisibilityChange = this._onVisibilityChange.bind(this);\n    this._updateOverlay = this._updateOverlay.bind(this);\n    a.disablePictureInPicture = !0;\n    a.playsInline = !0;\n    a.muted = !0;\n    let h = !1;\n    a.hidden && (a.hidden = !1, h = !0);\n    document.body.contains(a) || (document.body.appendChild(a), h = !0);\n    c = a.parentElement;\n    if (b.highlightScanRegion || b.highlightCodeOutline) {\n      d = !!b.overlay;\n      this.$overlay = b.overlay || document.createElement(\"div\");\n      f = this.$overlay.style;\n      f.position = \"absolute\";\n      f.display = \"none\";\n      f.pointerEvents = \"none\";\n      this.$overlay.classList.add(\"scan-region-highlight\");\n      if (!d && b.highlightScanRegion) {\n        this.$overlay.innerHTML = '<svg class=\"scan-region-highlight-svg\" viewBox=\"0 0 238 238\" preserveAspectRatio=\"none\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round\"><path d=\"M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 0H10a8 8 0 0 1-8-8v-21\"/></svg>';\n        try {\n          this.$overlay.firstElementChild.animate({\n            transform: [\"scale(.98)\", \"scale(1.01)\"]\n          }, {\n            duration: 400,\n            iterations: Infinity,\n            direction: \"alternate\",\n            easing: \"ease-in-out\"\n          });\n        } catch (m) {}\n        c.insertBefore(this.$overlay, this.$video.nextSibling);\n      }\n      b.highlightCodeOutline && (this.$overlay.insertAdjacentHTML(\"beforeend\", '<svg class=\"code-outline-highlight\" preserveAspectRatio=\"none\" style=\"display:none;width:100%;height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;stroke-linecap:round;stroke-linejoin:round\"><polygon/></svg>'), this.$codeOutlineHighlight = this.$overlay.lastElementChild);\n    }\n    this._scanRegion = this._calculateScanRegion(a);\n    requestAnimationFrame(() => {\n      let m = window.getComputedStyle(a);\n      \"none\" === m.display && (a.style.setProperty(\"display\", \"block\", \"important\"), h = !0);\n      \"visible\" !== m.visibility && (a.style.setProperty(\"visibility\", \"visible\", \"important\"), h = !0);\n      h && (console.warn(\"QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.\"), a.style.opacity = \"0\", a.style.width = \"0\", a.style.height = \"0\", this.$overlay && this.$overlay.parentElement && this.$overlay.parentElement.removeChild(this.$overlay), delete this.$overlay, delete this.$codeOutlineHighlight);\n      this.$overlay && this._updateOverlay();\n    });\n    a.addEventListener(\"play\", this._onPlay);\n    a.addEventListener(\"loadedmetadata\", this._onLoadedMetaData);\n    document.addEventListener(\"visibilitychange\", this._onVisibilityChange);\n    window.addEventListener(\"resize\", this._updateOverlay);\n    this._qrEnginePromise = e.createQrEngine();\n  }\n  static set WORKER_PATH(a) {\n    console.warn(\"Setting QrScanner.WORKER_PATH is not required and not supported anymore. Have a look at the README for new setup instructions.\");\n  }\n  static async hasCamera() {\n    try {\n      return !!(await e.listCameras(!1)).length;\n    } catch (a) {\n      return !1;\n    }\n  }\n  static async listCameras(a = !1) {\n    if (!navigator.mediaDevices) return [];\n    let b = async () => (await navigator.mediaDevices.enumerateDevices()).filter(d => \"videoinput\" === d.kind),\n      c;\n    try {\n      a && (await b()).every(d => !d.label) && (c = await navigator.mediaDevices.getUserMedia({\n        audio: !1,\n        video: !0\n      }));\n    } catch (d) {}\n    try {\n      return (await b()).map((d, f) => ({\n        id: d.deviceId,\n        label: d.label || (0 === f ? \"Default Camera\" : `Camera ${f + 1}`)\n      }));\n    } finally {\n      c && (console.warn(\"Call listCameras after successfully starting a QR scanner to avoid creating a temporary video stream\"), e._stopVideoStream(c));\n    }\n  }\n  async hasFlash() {\n    let a;\n    try {\n      if (this.$video.srcObject) {\n        if (!(this.$video.srcObject instanceof MediaStream)) return !1;\n        a = this.$video.srcObject;\n      } else a = (await this._getCameraStream()).stream;\n      return \"torch\" in a.getVideoTracks()[0].getSettings();\n    } catch (b) {\n      return !1;\n    } finally {\n      a && a !== this.$video.srcObject && (console.warn(\"Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream\"), e._stopVideoStream(a));\n    }\n  }\n  isFlashOn() {\n    return this._flashOn;\n  }\n  async toggleFlash() {\n    this._flashOn ? await this.turnFlashOff() : await this.turnFlashOn();\n  }\n  async turnFlashOn() {\n    if (!this._flashOn && !this._destroyed && (this._flashOn = !0, this._active && !this._paused)) try {\n      if (!(await this.hasFlash())) throw \"No flash available\";\n      await this.$video.srcObject.getVideoTracks()[0].applyConstraints({\n        advanced: [{\n          torch: !0\n        }]\n      });\n    } catch (a) {\n      throw this._flashOn = !1, a;\n    }\n  }\n  async turnFlashOff() {\n    this._flashOn && (this._flashOn = !1, await this._restartVideoStream());\n  }\n  destroy() {\n    this.$video.removeEventListener(\"loadedmetadata\", this._onLoadedMetaData);\n    this.$video.removeEventListener(\"play\", this._onPlay);\n    document.removeEventListener(\"visibilitychange\", this._onVisibilityChange);\n    window.removeEventListener(\"resize\", this._updateOverlay);\n    this._destroyed = !0;\n    this._flashOn = !1;\n    this.stop();\n    e._postWorkerMessage(this._qrEnginePromise, \"close\");\n  }\n  async start() {\n    if (this._destroyed) throw Error(\"The QR scanner can not be started as it had been destroyed.\");\n    if (!this._active || this._paused) if (\"https:\" !== window.location.protocol && console.warn(\"The camera stream is only accessible if the page is transferred via https.\"), this._active = !0, !document.hidden) if (this._paused = !1, this.$video.srcObject) await this.$video.play();else try {\n      let {\n        stream: a,\n        facingMode: b\n      } = await this._getCameraStream();\n      !this._active || this._paused ? e._stopVideoStream(a) : (this._setVideoMirror(b), this.$video.srcObject = a, await this.$video.play(), this._flashOn && (this._flashOn = !1, this.turnFlashOn().catch(() => {})));\n    } catch (a) {\n      if (!this._paused) throw this._active = !1, a;\n    }\n  }\n  stop() {\n    this.pause();\n    this._active = !1;\n  }\n  async pause(a = !1) {\n    this._paused = !0;\n    if (!this._active) return !0;\n    this.$video.pause();\n    this.$overlay && (this.$overlay.style.display = \"none\");\n    let b = () => {\n      this.$video.srcObject instanceof MediaStream && (e._stopVideoStream(this.$video.srcObject), this.$video.srcObject = null);\n    };\n    if (a) return b(), !0;\n    await new Promise(c => setTimeout(c, 300));\n    if (!this._paused) return !1;\n    b();\n    return !0;\n  }\n  async setCamera(a) {\n    a !== this._preferredCamera && (this._preferredCamera = a, await this._restartVideoStream());\n  }\n  static async scanImage(a, b, c, d, f = !1, h = !1) {\n    let m,\n      n = !1;\n    b && (\"scanRegion\" in b || \"qrEngine\" in b || \"canvas\" in b || \"disallowCanvasResizing\" in b || \"alsoTryWithoutScanRegion\" in b || \"returnDetailedScanResult\" in b) ? (m = b.scanRegion, c = b.qrEngine, d = b.canvas, f = b.disallowCanvasResizing || !1, h = b.alsoTryWithoutScanRegion || !1, n = !0) : b || c || d || f || h ? console.warn(\"You're using a deprecated api for scanImage which will be removed in the future.\") : console.warn(\"Note that the return type of scanImage will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.\");\n    b = !!c;\n    try {\n      let p, k;\n      [c, p] = await Promise.all([c || e.createQrEngine(), e._loadImage(a)]);\n      [d, k] = e._drawToCanvas(p, m, d, f);\n      let q;\n      if (c instanceof Worker) {\n        let g = c;\n        b || e._postWorkerMessageSync(g, \"inversionMode\", \"both\");\n        q = await new Promise((l, v) => {\n          let w,\n            u,\n            r,\n            y = -1;\n          u = t => {\n            t.data.id === y && (g.removeEventListener(\"message\", u), g.removeEventListener(\"error\", r), clearTimeout(w), null !== t.data.data ? l({\n              data: t.data.data,\n              cornerPoints: e._convertPoints(t.data.cornerPoints, m)\n            }) : v(e.NO_QR_CODE_FOUND));\n          };\n          r = t => {\n            g.removeEventListener(\"message\", u);\n            g.removeEventListener(\"error\", r);\n            clearTimeout(w);\n            v(\"Scanner error: \" + (t ? t.message || t : \"Unknown Error\"));\n          };\n          g.addEventListener(\"message\", u);\n          g.addEventListener(\"error\", r);\n          w = setTimeout(() => r(\"timeout\"), 1E4);\n          let x = k.getImageData(0, 0, d.width, d.height);\n          y = e._postWorkerMessageSync(g, \"decode\", x, [x.data.buffer]);\n        });\n      } else q = await Promise.race([new Promise((g, l) => window.setTimeout(() => l(\"Scanner error: timeout\"), 1E4)), (async () => {\n        try {\n          var [g] = await c.detect(d);\n          if (!g) throw e.NO_QR_CODE_FOUND;\n          return {\n            data: g.rawValue,\n            cornerPoints: e._convertPoints(g.cornerPoints, m)\n          };\n        } catch (l) {\n          g = l.message || l;\n          if (/not implemented|service unavailable/.test(g)) return e._disableBarcodeDetector = !0, e.scanImage(a, {\n            scanRegion: m,\n            canvas: d,\n            disallowCanvasResizing: f,\n            alsoTryWithoutScanRegion: h\n          });\n          throw `Scanner error: ${g}`;\n        }\n      })()]);\n      return n ? q : q.data;\n    } catch (p) {\n      if (!m || !h) throw p;\n      let k = await e.scanImage(a, {\n        qrEngine: c,\n        canvas: d,\n        disallowCanvasResizing: f\n      });\n      return n ? k : k.data;\n    } finally {\n      b || e._postWorkerMessage(c, \"close\");\n    }\n  }\n  setGrayscaleWeights(a, b, c, d = !0) {\n    e._postWorkerMessage(this._qrEnginePromise, \"grayscaleWeights\", {\n      red: a,\n      green: b,\n      blue: c,\n      useIntegerApproximation: d\n    });\n  }\n  setInversionMode(a) {\n    e._postWorkerMessage(this._qrEnginePromise, \"inversionMode\", a);\n  }\n  static async createQrEngine(a) {\n    a && console.warn(\"Specifying a worker path is not required and not supported anymore.\");\n    a = () => __webpack_require__.e(/*! import() */ \"vendors-node_modules_qr-scanner_qr-scanner-worker_min_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./qr-scanner-worker.min.js */ \"./node_modules/qr-scanner/qr-scanner-worker.min.js\")).then(c => c.createWorker());\n    if (!(!e._disableBarcodeDetector && \"BarcodeDetector\" in window && BarcodeDetector.getSupportedFormats && (await BarcodeDetector.getSupportedFormats()).includes(\"qr_code\"))) return a();\n    let b = navigator.userAgentData;\n    return b && b.brands.some(({\n      brand: c\n    }) => /Chromium/i.test(c)) && /mac ?OS/i.test(b.platform) && (await b.getHighEntropyValues([\"architecture\", \"platformVersion\"]).then(({\n      architecture: c,\n      platformVersion: d\n    }) => /arm/i.test(c || \"arm\") && 13 <= parseInt(d || \"13\")).catch(() => !0)) ? a() : new BarcodeDetector({\n      formats: [\"qr_code\"]\n    });\n  }\n  _onPlay() {\n    this._scanRegion = this._calculateScanRegion(this.$video);\n    this._updateOverlay();\n    this.$overlay && (this.$overlay.style.display = \"\");\n    this._scanFrame();\n  }\n  _onLoadedMetaData() {\n    this._scanRegion = this._calculateScanRegion(this.$video);\n    this._updateOverlay();\n  }\n  _onVisibilityChange() {\n    document.hidden ? this.pause() : this._active && this.start();\n  }\n  _calculateScanRegion(a) {\n    let b = Math.round(2 / 3 * Math.min(a.videoWidth, a.videoHeight));\n    return {\n      x: Math.round((a.videoWidth - b) / 2),\n      y: Math.round((a.videoHeight - b) / 2),\n      width: b,\n      height: b,\n      downScaledWidth: this._legacyCanvasSize,\n      downScaledHeight: this._legacyCanvasSize\n    };\n  }\n  _updateOverlay() {\n    requestAnimationFrame(() => {\n      if (this.$overlay) {\n        var a = this.$video,\n          b = a.videoWidth,\n          c = a.videoHeight,\n          d = a.offsetWidth,\n          f = a.offsetHeight,\n          h = a.offsetLeft,\n          m = a.offsetTop,\n          n = window.getComputedStyle(a),\n          p = n.objectFit,\n          k = b / c,\n          q = d / f;\n        switch (p) {\n          case \"none\":\n            var g = b;\n            var l = c;\n            break;\n          case \"fill\":\n            g = d;\n            l = f;\n            break;\n          default:\n            (\"cover\" === p ? k > q : k < q) ? (l = f, g = l * k) : (g = d, l = g / k), \"scale-down\" === p && (g = Math.min(g, b), l = Math.min(l, c));\n        }\n        var [v, w] = n.objectPosition.split(\" \").map((r, y) => {\n          const x = parseFloat(r);\n          return r.endsWith(\"%\") ? (y ? f - l : d - g) * x / 100 : x;\n        });\n        n = this._scanRegion.width || b;\n        q = this._scanRegion.height || c;\n        p = this._scanRegion.x || 0;\n        var u = this._scanRegion.y || 0;\n        k = this.$overlay.style;\n        k.width = `${n / b * g}px`;\n        k.height = `${q / c * l}px`;\n        k.top = `${m + w + u / c * l}px`;\n        c = /scaleX\\(-1\\)/.test(a.style.transform);\n        k.left = `${h + (c ? d - v - g : v) + (c ? b - p - n : p) / b * g}px`;\n        k.transform = a.style.transform;\n      }\n    });\n  }\n  static _convertPoints(a, b) {\n    if (!b) return a;\n    let c = b.x || 0,\n      d = b.y || 0,\n      f = b.width && b.downScaledWidth ? b.width / b.downScaledWidth : 1;\n    b = b.height && b.downScaledHeight ? b.height / b.downScaledHeight : 1;\n    for (let h of a) h.x = h.x * f + c, h.y = h.y * b + d;\n    return a;\n  }\n  _scanFrame() {\n    !this._active || this.$video.paused || this.$video.ended || (\"requestVideoFrameCallback\" in this.$video ? this.$video.requestVideoFrameCallback.bind(this.$video) : requestAnimationFrame)(async () => {\n      if (!(1 >= this.$video.readyState)) {\n        var a = Date.now() - this._lastScanTimestamp,\n          b = 1E3 / this._maxScansPerSecond;\n        a < b && (await new Promise(d => setTimeout(d, b - a)));\n        this._lastScanTimestamp = Date.now();\n        try {\n          var c = await e.scanImage(this.$video, {\n            scanRegion: this._scanRegion,\n            qrEngine: this._qrEnginePromise,\n            canvas: this.$canvas\n          });\n        } catch (d) {\n          if (!this._active) return;\n          this._onDecodeError(d);\n        }\n        !e._disableBarcodeDetector || (await this._qrEnginePromise) instanceof Worker || (this._qrEnginePromise = e.createQrEngine());\n        c ? (this._onDecode ? this._onDecode(c) : this._legacyOnDecode && this._legacyOnDecode(c.data), this.$codeOutlineHighlight && (clearTimeout(this._codeOutlineHighlightRemovalTimeout), this._codeOutlineHighlightRemovalTimeout = void 0, this.$codeOutlineHighlight.setAttribute(\"viewBox\", `${this._scanRegion.x || 0} ` + `${this._scanRegion.y || 0} ` + `${this._scanRegion.width || this.$video.videoWidth} ` + `${this._scanRegion.height || this.$video.videoHeight}`), this.$codeOutlineHighlight.firstElementChild.setAttribute(\"points\", c.cornerPoints.map(({\n          x: d,\n          y: f\n        }) => `${d},${f}`).join(\" \")), this.$codeOutlineHighlight.style.display = \"\")) : this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout && (this._codeOutlineHighlightRemovalTimeout = setTimeout(() => this.$codeOutlineHighlight.style.display = \"none\", 100));\n      }\n      this._scanFrame();\n    });\n  }\n  _onDecodeError(a) {\n    a !== e.NO_QR_CODE_FOUND && console.log(a);\n  }\n  async _getCameraStream() {\n    if (!navigator.mediaDevices) throw \"Camera not found.\";\n    let a = /^(environment|user)$/.test(this._preferredCamera) ? \"facingMode\" : \"deviceId\",\n      b = [{\n        width: {\n          min: 1024\n        }\n      }, {\n        width: {\n          min: 768\n        }\n      }, {}],\n      c = b.map(d => Object.assign({}, d, {\n        [a]: {\n          exact: this._preferredCamera\n        }\n      }));\n    for (let d of [...c, ...b]) try {\n      let f = await navigator.mediaDevices.getUserMedia({\n          video: d,\n          audio: !1\n        }),\n        h = this._getFacingMode(f) || (d.facingMode ? this._preferredCamera : \"environment\" === this._preferredCamera ? \"user\" : \"environment\");\n      return {\n        stream: f,\n        facingMode: h\n      };\n    } catch (f) {}\n    throw \"Camera not found.\";\n  }\n  async _restartVideoStream() {\n    let a = this._paused;\n    (await this.pause(!0)) && !a && this._active && (await this.start());\n  }\n  static _stopVideoStream(a) {\n    for (let b of a.getTracks()) b.stop(), a.removeTrack(b);\n  }\n  _setVideoMirror(a) {\n    this.$video.style.transform = \"scaleX(\" + (\"user\" === a ? -1 : 1) + \")\";\n  }\n  _getFacingMode(a) {\n    return (a = a.getVideoTracks()[0]) ? /rear|back|environment/i.test(a.label) ? \"environment\" : /front|user|face/i.test(a.label) ? \"user\" : null : null;\n  }\n  static _drawToCanvas(a, b, c, d = !1) {\n    c = c || document.createElement(\"canvas\");\n    let f = b && b.x ? b.x : 0,\n      h = b && b.y ? b.y : 0,\n      m = b && b.width ? b.width : a.videoWidth || a.width,\n      n = b && b.height ? b.height : a.videoHeight || a.height;\n    d || (d = b && b.downScaledWidth ? b.downScaledWidth : m, b = b && b.downScaledHeight ? b.downScaledHeight : n, c.width !== d && (c.width = d), c.height !== b && (c.height = b));\n    b = c.getContext(\"2d\", {\n      alpha: !1\n    });\n    b.imageSmoothingEnabled = !1;\n    b.drawImage(a, f, h, m, n, 0, 0, c.width, c.height);\n    return [c, b];\n  }\n  static async _loadImage(a) {\n    if (a instanceof Image) return await e._awaitImageLoad(a), a;\n    if (a instanceof HTMLVideoElement || a instanceof HTMLCanvasElement || a instanceof SVGImageElement || \"OffscreenCanvas\" in window && a instanceof OffscreenCanvas || \"ImageBitmap\" in window && a instanceof ImageBitmap) return a;\n    if (a instanceof File || a instanceof Blob || a instanceof URL || \"string\" === typeof a) {\n      let b = new Image();\n      b.src = a instanceof File || a instanceof Blob ? URL.createObjectURL(a) : a.toString();\n      try {\n        return await e._awaitImageLoad(b), b;\n      } finally {\n        (a instanceof File || a instanceof Blob) && URL.revokeObjectURL(b.src);\n      }\n    } else throw \"Unsupported image type.\";\n  }\n  static async _awaitImageLoad(a) {\n    a.complete && 0 !== a.naturalWidth || (await new Promise((b, c) => {\n      let d = f => {\n        a.removeEventListener(\"load\", d);\n        a.removeEventListener(\"error\", d);\n        f instanceof ErrorEvent ? c(\"Image load error\") : b();\n      };\n      a.addEventListener(\"load\", d);\n      a.addEventListener(\"error\", d);\n    }));\n  }\n  static async _postWorkerMessage(a, b, c, d) {\n    return e._postWorkerMessageSync(await a, b, c, d);\n  }\n  static _postWorkerMessageSync(a, b, c, d) {\n    if (!(a instanceof Worker)) return -1;\n    let f = e._workerMessageId++;\n    a.postMessage({\n      id: f,\n      type: b,\n      data: c\n    }, d);\n    return f;\n  }\n}\ne.DEFAULT_CANVAS_SIZE = 400;\ne.NO_QR_CODE_FOUND = \"No QR code found\";\ne._disableBarcodeDetector = !1;\ne._workerMessageId = 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (e);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcXItc2Nhbm5lci9xci1zY2FubmVyLm1pbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBMEdBO0FBN0NBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUF1REE7QUFDQTtBQUVBO0FBc0JBO0FBR0E7QUFHQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFHQTtBQUlBO0FBQ0E7QUFJQTtBQUFBO0FBTUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFEQTtBQVFBO0FBaEJBO0FBa0JBO0FBMUJBO0FBcUNBO0FBRUE7QUFFQTtBQUNBO0FBSUE7QUFJQTtBQWVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFsUUE7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBQUE7QUFLQTtBQUNBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBRkE7QUFBQTtBQStOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQU1BO0FBUEE7QUFTQTtBQURBO0FBSUE7QUFGQTtBQUFBO0FBVUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUdBO0FBSUE7QUFDQTtBQUlBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFGQTtBQUhBO0FBU0E7QUFGQTtBQUFBO0FBTUE7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFpQkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBaUJBO0FBREE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFBQTtBQU9BO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQTZCQTtBQWlCQTtBQUNBO0FBQ0E7QUF1QkE7QUFNQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBRkE7QUFQQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQXRDQTtBQW9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUhBO0FBT0E7QUFFQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQXBCQTtBQUFBO0FBeUJBO0FBL0ZBO0FBaUdBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFEQTtBQUdBO0FBTkE7QUFRQTtBQURBO0FBQUE7QUFPQTtBQUdBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBT0E7QUFHQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBS0E7QUFPQTtBQWtCQTtBQVRBO0FBQUE7QUFNQTtBQUFBO0FBQUE7QUFLQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFHQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQUE7QUFVQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBa0NBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFJQTtBQXRFQTtBQUFBO0FBSEE7QUE2RUE7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUlBO0FBSUE7QUFJQTtBQUFBO0FBR0E7QUFDQTtBQVVBO0FBU0E7QUFBQTtBQUVBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQU9BO0FBQ0E7QUFGQTtBQUtBO0FBS0E7QUFrQkE7QUFBQTtBQUFBO0FBcERBO0FBS0E7QUFBQTtBQU5BO0FBb0VBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFEQTtBQUxBO0FBU0E7QUFBQTtBQUFBO0FBREE7QUFJQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFZQTtBQUFBO0FBQUE7QUFBQTtBQWJBO0FBaUJBO0FBQUE7QUFHQTtBQUdBO0FBQUE7QUFHQTtBQUdBO0FBQ0E7QUFFQTtBQUlBO0FBR0E7QUFBQTtBQUdBO0FBRUE7QUFBQTtBQVNBO0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQVNBO0FBQUE7QUFpQkE7QUFBQTtBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBR0E7QUFLQTtBQUdBO0FBTUE7QUFFQTtBQUVBO0FBSUE7QUFFQTtBQUZBO0FBSUE7QUFEQTtBQVZBO0FBZ0JBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQUE7QUFYQTtBQWVBO0FBTUE7QUFBQTtBQUlBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUFBO0FBeGlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcXItc2Nhbm5lci50cz85ODEzIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFFyU2Nhbm5lciB7XG4gICAgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfQ0FOVkFTX1NJWkUgPSA0MDA7XG4gICAgc3RhdGljIHJlYWRvbmx5IE5PX1FSX0NPREVfRk9VTkQgPSAnTm8gUVIgY29kZSBmb3VuZCc7XG4gICAgcHJpdmF0ZSBzdGF0aWMgX2Rpc2FibGVCYXJjb2RlRGV0ZWN0b3IgPSBmYWxzZTtcbiAgICBwcml2YXRlIHN0YXRpYyBfd29ya2VyTWVzc2FnZUlkID0gMDtcblxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHN0YXRpYyBzZXQgV09SS0VSX1BBVEgod29ya2VyUGF0aDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU2V0dGluZyBRclNjYW5uZXIuV09SS0VSX1BBVEggaXMgbm90IHJlcXVpcmVkIGFuZCBub3Qgc3VwcG9ydGVkIGFueW1vcmUuICdcbiAgICAgICAgICAgICsgJ0hhdmUgYSBsb29rIGF0IHRoZSBSRUFETUUgZm9yIG5ldyBzZXR1cCBpbnN0cnVjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIGhhc0NhbWVyYSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIShhd2FpdCBRclNjYW5uZXIubGlzdENhbWVyYXMoZmFsc2UpKS5sZW5ndGg7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBsaXN0Q2FtZXJhcyhyZXF1ZXN0TGFiZWxzID0gZmFsc2UpOiBQcm9taXNlPEFycmF5PFFyU2Nhbm5lci5DYW1lcmE+PiB7XG4gICAgICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgcmV0dXJuIFtdO1xuXG4gICAgICAgIGNvbnN0IGVudW1lcmF0ZUNhbWVyYXMgPSBhc3luYyAoKTogUHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8+PiA9PlxuICAgICAgICAgICAgKGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpKS5maWx0ZXIoKGRldmljZSkgPT4gZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IGVudW1lcmF0ZURldmljZXMgY2FuIGFsd2F5cyBiZSBjYWxsZWQgYW5kIGRvZXMgbm90IHByb21wdCB0aGUgdXNlciBmb3IgcGVybWlzc2lvbi5cbiAgICAgICAgLy8gSG93ZXZlciwgZW51bWVyYXRlRGV2aWNlcyBvbmx5IGluY2x1ZGVzIGRldmljZSBsYWJlbHMgaWYgc2VydmVkIHZpYSBodHRwcyBhbmQgYW4gYWN0aXZlIG1lZGlhIHN0cmVhbSBleGlzdHNcbiAgICAgICAgLy8gb3IgcGVybWlzc2lvbiB0byBhY2Nlc3MgdGhlIGNhbWVyYSB3YXMgZ2l2ZW4uIFRoZXJlZm9yZSwgaWYgd2UncmUgbm90IGdldHRpbmcgbGFiZWxzIGJ1dCBsYWJlbHMgYXJlIHJlcXVlc3RlZFxuICAgICAgICAvLyBhc2sgZm9yIGNhbWVyYSBwZXJtaXNzaW9uIGJ5IG9wZW5pbmcgYSBzdHJlYW0uXG4gICAgICAgIGxldCBvcGVuZWRTdHJlYW06IE1lZGlhU3RyZWFtIHwgdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RMYWJlbHMgJiYgKGF3YWl0IGVudW1lcmF0ZUNhbWVyYXMoKSkuZXZlcnkoKGNhbWVyYSkgPT4gIWNhbWVyYS5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICBvcGVuZWRTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IGF1ZGlvOiBmYWxzZSwgdmlkZW86IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEZhaWwgZ3JhY2VmdWxseSwgZXNwZWNpYWxseSBpZiB0aGUgZGV2aWNlIGhhcyBubyBjYW1lcmEgb3Igb24gbW9iaWxlIHdoZW4gdGhlIGNhbWVyYSBpcyBhbHJlYWR5IGluIHVzZVxuICAgICAgICAgICAgLy8gYW5kIHNvbWUgYnJvd3NlcnMgZGlzYWxsb3cgYSBzZWNvbmQgc3RyZWFtLlxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgZW51bWVyYXRlQ2FtZXJhcygpKS5tYXAoKGNhbWVyYSwgaSkgPT4gKHtcbiAgICAgICAgICAgICAgICBpZDogY2FtZXJhLmRldmljZUlkLFxuICAgICAgICAgICAgICAgIGxhYmVsOiBjYW1lcmEubGFiZWwgfHwgKGkgPT09IDAgPyAnRGVmYXVsdCBDYW1lcmEnIDogYENhbWVyYSAke2kgKyAxfWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gY2xvc2UgdGhlIHN0cmVhbSB3ZSBqdXN0IG9wZW5lZCBmb3IgZ2V0dGluZyBjYW1lcmEgYWNjZXNzIGZvciBsaXN0aW5nIHRoZSBkZXZpY2UgbGFiZWxzXG4gICAgICAgICAgICBpZiAob3BlbmVkU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDYWxsIGxpc3RDYW1lcmFzIGFmdGVyIHN1Y2Nlc3NmdWxseSBzdGFydGluZyBhIFFSIHNjYW5uZXIgdG8gYXZvaWQgY3JlYXRpbmcgJ1xuICAgICAgICAgICAgICAgICAgICArICdhIHRlbXBvcmFyeSB2aWRlbyBzdHJlYW0nKTtcbiAgICAgICAgICAgICAgICBRclNjYW5uZXIuX3N0b3BWaWRlb1N0cmVhbShvcGVuZWRTdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVhZG9ubHkgJHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50O1xuICAgIHJlYWRvbmx5ICRjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50O1xuICAgIHJlYWRvbmx5ICRvdmVybGF5PzogSFRNTERpdkVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSAkY29kZU91dGxpbmVIaWdobGlnaHQ/OiBTVkdTVkdFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX29uRGVjb2RlPzogKHJlc3VsdDogUXJTY2FubmVyLlNjYW5SZXN1bHQpID0+IHZvaWQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfbGVnYWN5T25EZWNvZGU/OiAocmVzdWx0OiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfbGVnYWN5Q2FudmFzU2l6ZTogbnVtYmVyID0gUXJTY2FubmVyLkRFRkFVTFRfQ0FOVkFTX1NJWkU7XG4gICAgcHJpdmF0ZSBfcHJlZmVycmVkQ2FtZXJhOiBRclNjYW5uZXIuRmFjaW5nTW9kZSB8IFFyU2Nhbm5lci5EZXZpY2VJZCA9ICdlbnZpcm9ubWVudCc7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfbWF4U2NhbnNQZXJTZWNvbmQ6IG51bWJlciA9IDI1O1xuICAgIHByaXZhdGUgX2xhc3RTY2FuVGltZXN0YW1wOiBudW1iZXIgPSAtMTtcbiAgICBwcml2YXRlIF9zY2FuUmVnaW9uOiBRclNjYW5uZXIuU2NhblJlZ2lvbjtcbiAgICBwcml2YXRlIF9jb2RlT3V0bGluZUhpZ2hsaWdodFJlbW92YWxUaW1lb3V0PzogbnVtYmVyO1xuICAgIHByaXZhdGUgX3FyRW5naW5lUHJvbWlzZTogUHJvbWlzZTxXb3JrZXIgfCBCYXJjb2RlRGV0ZWN0b3I+XG4gICAgcHJpdmF0ZSBfYWN0aXZlOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfcGF1c2VkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfZmxhc2hPbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2Rlc3Ryb3llZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50LFxuICAgICAgICBvbkRlY29kZTogKHJlc3VsdDogUXJTY2FubmVyLlNjYW5SZXN1bHQpID0+IHZvaWQsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9uRGVjb2RlRXJyb3I/OiAoZXJyb3I6IEVycm9yIHwgc3RyaW5nKSA9PiB2b2lkLFxuICAgICAgICAgICAgY2FsY3VsYXRlU2NhblJlZ2lvbj86ICh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCkgPT4gUXJTY2FubmVyLlNjYW5SZWdpb24sXG4gICAgICAgICAgICBwcmVmZXJyZWRDYW1lcmE/OiBRclNjYW5uZXIuRmFjaW5nTW9kZSB8IFFyU2Nhbm5lci5EZXZpY2VJZCxcbiAgICAgICAgICAgIG1heFNjYW5zUGVyU2Vjb25kPzogbnVtYmVyO1xuICAgICAgICAgICAgaGlnaGxpZ2h0U2NhblJlZ2lvbj86IGJvb2xlYW4sXG4gICAgICAgICAgICBoaWdobGlnaHRDb2RlT3V0bGluZT86IGJvb2xlYW4sXG4gICAgICAgICAgICBvdmVybGF5PzogSFRNTERpdkVsZW1lbnQsXG4gICAgICAgICAgICAvKioganVzdCBhIHRlbXBvcmFyeSBmbGFnIHVudGlsIHdlIHN3aXRjaCBlbnRpcmVseSB0byB0aGUgbmV3IGFwaSAqL1xuICAgICAgICAgICAgcmV0dXJuRGV0YWlsZWRTY2FuUmVzdWx0PzogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICApO1xuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICB2aWRlbzogSFRNTFZpZGVvRWxlbWVudCxcbiAgICAgICAgb25EZWNvZGU6IChyZXN1bHQ6IHN0cmluZykgPT4gdm9pZCxcbiAgICAgICAgb25EZWNvZGVFcnJvcj86IChlcnJvcjogRXJyb3IgfCBzdHJpbmcpID0+IHZvaWQsXG4gICAgICAgIGNhbGN1bGF0ZVNjYW5SZWdpb24/OiAodmlkZW86IEhUTUxWaWRlb0VsZW1lbnQpID0+IFFyU2Nhbm5lci5TY2FuUmVnaW9uLFxuICAgICAgICBwcmVmZXJyZWRDYW1lcmE/OiBRclNjYW5uZXIuRmFjaW5nTW9kZSB8IFFyU2Nhbm5lci5EZXZpY2VJZCxcbiAgICApO1xuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICB2aWRlbzogSFRNTFZpZGVvRWxlbWVudCxcbiAgICAgICAgb25EZWNvZGU6IChyZXN1bHQ6IHN0cmluZykgPT4gdm9pZCxcbiAgICAgICAgb25EZWNvZGVFcnJvcj86IChlcnJvcjogRXJyb3IgfCBzdHJpbmcpID0+IHZvaWQsXG4gICAgICAgIGNhbnZhc1NpemU/OiBudW1iZXIsXG4gICAgICAgIHByZWZlcnJlZENhbWVyYT86IFFyU2Nhbm5lci5GYWNpbmdNb2RlIHwgUXJTY2FubmVyLkRldmljZUlkLFxuICAgICk7XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgY29uc3RydWN0b3IodmlkZW86IEhUTUxWaWRlb0VsZW1lbnQsIG9uRGVjb2RlOiAocmVzdWx0OiBzdHJpbmcpID0+IHZvaWQsIGNhbnZhc1NpemU/OiBudW1iZXIpO1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICB2aWRlbzogSFRNTFZpZGVvRWxlbWVudCxcbiAgICAgICAgb25EZWNvZGU6ICgocmVzdWx0OiBRclNjYW5uZXIuU2NhblJlc3VsdCkgPT4gdm9pZCkgfCAoKHJlc3VsdDogc3RyaW5nKSA9PiB2b2lkKSxcbiAgICAgICAgY2FudmFzU2l6ZU9yT25EZWNvZGVFcnJvck9yT3B0aW9ucz86IG51bWJlciB8ICgoZXJyb3I6IEVycm9yIHwgc3RyaW5nKSA9PiB2b2lkKSB8IHtcbiAgICAgICAgICAgIG9uRGVjb2RlRXJyb3I/OiAoZXJyb3I6IEVycm9yIHwgc3RyaW5nKSA9PiB2b2lkLFxuICAgICAgICAgICAgY2FsY3VsYXRlU2NhblJlZ2lvbj86ICh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCkgPT4gUXJTY2FubmVyLlNjYW5SZWdpb24sXG4gICAgICAgICAgICBwcmVmZXJyZWRDYW1lcmE/OiBRclNjYW5uZXIuRmFjaW5nTW9kZSB8IFFyU2Nhbm5lci5EZXZpY2VJZCxcbiAgICAgICAgICAgIG1heFNjYW5zUGVyU2Vjb25kPzogbnVtYmVyO1xuICAgICAgICAgICAgaGlnaGxpZ2h0U2NhblJlZ2lvbj86IGJvb2xlYW4sXG4gICAgICAgICAgICBoaWdobGlnaHRDb2RlT3V0bGluZT86IGJvb2xlYW4sXG4gICAgICAgICAgICBvdmVybGF5PzogSFRNTERpdkVsZW1lbnQsXG4gICAgICAgICAgICAvKioganVzdCBhIHRlbXBvcmFyeSBmbGFnIHVudGlsIHdlIHN3aXRjaCBlbnRpcmVseSB0byB0aGUgbmV3IGFwaSAqL1xuICAgICAgICAgICAgcmV0dXJuRGV0YWlsZWRTY2FuUmVzdWx0PzogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgY2FudmFzU2l6ZU9yQ2FsY3VsYXRlU2NhblJlZ2lvbj86IG51bWJlciB8ICgodmlkZW86IEhUTUxWaWRlb0VsZW1lbnQpID0+IFFyU2Nhbm5lci5TY2FuUmVnaW9uKSxcbiAgICAgICAgcHJlZmVycmVkQ2FtZXJhPzogUXJTY2FubmVyLkZhY2luZ01vZGUgfCBRclNjYW5uZXIuRGV2aWNlSWQsXG4gICAgKSB7XG4gICAgICAgIHRoaXMuJHZpZGVvID0gdmlkZW87XG4gICAgICAgIHRoaXMuJGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgICAgIGlmIChjYW52YXNTaXplT3JPbkRlY29kZUVycm9yT3JPcHRpb25zICYmIHR5cGVvZiBjYW52YXNTaXplT3JPbkRlY29kZUVycm9yT3JPcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gd2UgZ290IGFuIG9wdGlvbnMgb2JqZWN0IHVzaW5nIHRoZSBuZXcgYXBpXG4gICAgICAgICAgICB0aGlzLl9vbkRlY29kZSA9IG9uRGVjb2RlIGFzIFFyU2Nhbm5lclsnX29uRGVjb2RlJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FudmFzU2l6ZU9yT25EZWNvZGVFcnJvck9yT3B0aW9ucyB8fCBjYW52YXNTaXplT3JDYWxjdWxhdGVTY2FuUmVnaW9uIHx8IHByZWZlcnJlZENhbWVyYSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignWW91XFwncmUgdXNpbmcgYSBkZXByZWNhdGVkIHZlcnNpb24gb2YgdGhlIFFyU2Nhbm5lciBjb25zdHJ1Y3RvciB3aGljaCB3aWxsIGJlIHJlbW92ZWQgaW4gJ1xuICAgICAgICAgICAgICAgICAgICArICd0aGUgZnV0dXJlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgdmlkZW8gYW5kIG9uRGVjb2RlIHdlcmUgc3BlY2lmaWVkIGFuZCB3ZSBjYW4ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIG5ldyBvciBvbGQgYXBpIHVzYWdlLiBGb3JcbiAgICAgICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3ZSBoYXZlIHRvIGFzc3VtZSB0aGUgb2xkIGFwaSBmb3Igbm93LiBUaGUgb3B0aW9ucyBvYmplY3QgaXMgbWFya2VkIGFzIG5vbi1cbiAgICAgICAgICAgICAgICAvLyBvcHRpb25hbCBpbiB0aGUgcGFyYW1ldGVyIGxpc3QgYWJvdmUgdG8gbWFrZSBjbGVhciB0aGF0IFNjYW5SZXN1bHQgaW5zdGVhZCBvZiBzdHJpbmcgaXMgb25seSBwYXNzZWRcbiAgICAgICAgICAgICAgICAvLyBpZiBhbiBvcHRpb25zIG9iamVjdCB3YXMgcHJvdmlkZWQuIEhvd2V2ZXIsIGluIHRoZSBmdXR1cmUgb25jZSBsZWdhY3kgc3VwcG9ydCBpcyByZW1vdmVkLCB0aGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdCBzaG91bGQgYmVjb21lIG9wdGlvbmFsLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTm90ZSB0aGF0IHRoZSB0eXBlIG9mIHRoZSBzY2FuIHJlc3VsdCBwYXNzZWQgdG8gb25EZWNvZGUgd2lsbCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS4gJ1xuICAgICAgICAgICAgICAgICAgICArICdUbyBhbHJlYWR5IHN3aXRjaCB0byB0aGUgbmV3IGFwaSB0b2RheSwgeW91IGNhbiBwYXNzIHJldHVybkRldGFpbGVkU2NhblJlc3VsdDogdHJ1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xlZ2FjeU9uRGVjb2RlID0gb25EZWNvZGUgYXMgUXJTY2FubmVyWydfbGVnYWN5T25EZWNvZGUnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgY2FudmFzU2l6ZU9yT25EZWNvZGVFcnJvck9yT3B0aW9ucyA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gY2FudmFzU2l6ZU9yT25EZWNvZGVFcnJvck9yT3B0aW9uc1xuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgdGhpcy5fb25EZWNvZGVFcnJvciA9IG9wdGlvbnMub25EZWNvZGVFcnJvciB8fCAodHlwZW9mIGNhbnZhc1NpemVPck9uRGVjb2RlRXJyb3JPck9wdGlvbnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gY2FudmFzU2l6ZU9yT25EZWNvZGVFcnJvck9yT3B0aW9uc1xuICAgICAgICAgICAgOiB0aGlzLl9vbkRlY29kZUVycm9yKTtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlU2NhblJlZ2lvbiA9IG9wdGlvbnMuY2FsY3VsYXRlU2NhblJlZ2lvbiB8fCAodHlwZW9mIGNhbnZhc1NpemVPckNhbGN1bGF0ZVNjYW5SZWdpb249PT0nZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGNhbnZhc1NpemVPckNhbGN1bGF0ZVNjYW5SZWdpb25cbiAgICAgICAgICAgIDogdGhpcy5fY2FsY3VsYXRlU2NhblJlZ2lvbik7XG4gICAgICAgIHRoaXMuX3ByZWZlcnJlZENhbWVyYSA9IG9wdGlvbnMucHJlZmVycmVkQ2FtZXJhIHx8IHByZWZlcnJlZENhbWVyYSB8fCB0aGlzLl9wcmVmZXJyZWRDYW1lcmE7XG4gICAgICAgIHRoaXMuX2xlZ2FjeUNhbnZhc1NpemUgPSB0eXBlb2YgY2FudmFzU2l6ZU9yT25EZWNvZGVFcnJvck9yT3B0aW9ucyA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gY2FudmFzU2l6ZU9yT25EZWNvZGVFcnJvck9yT3B0aW9uc1xuICAgICAgICAgICAgOiB0eXBlb2YgY2FudmFzU2l6ZU9yQ2FsY3VsYXRlU2NhblJlZ2lvbiA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICA/IGNhbnZhc1NpemVPckNhbGN1bGF0ZVNjYW5SZWdpb25cbiAgICAgICAgICAgICAgICA6IHRoaXMuX2xlZ2FjeUNhbnZhc1NpemU7XG4gICAgICAgIHRoaXMuX21heFNjYW5zUGVyU2Vjb25kID0gb3B0aW9ucy5tYXhTY2Fuc1BlclNlY29uZCB8fCB0aGlzLl9tYXhTY2Fuc1BlclNlY29uZDtcblxuICAgICAgICB0aGlzLl9vblBsYXkgPSB0aGlzLl9vblBsYXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fb25Mb2FkZWRNZXRhRGF0YSA9IHRoaXMuX29uTG9hZGVkTWV0YURhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlID0gdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU92ZXJsYXkgPSB0aGlzLl91cGRhdGVPdmVybGF5LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB2aWRlby5kaXNhYmxlUGljdHVyZUluUGljdHVyZSA9IHRydWU7XG4gICAgICAgIC8vIEFsbG93IGlubGluZSBwbGF5YmFjayBvbiBpUGhvbmUgaW5zdGVhZCBvZiByZXF1aXJpbmcgZnVsbCBzY3JlZW4gcGxheWJhY2ssXG4gICAgICAgIC8vIHNlZSBodHRwczovL3dlYmtpdC5vcmcvYmxvZy82Nzg0L25ldy12aWRlby1wb2xpY2llcy1mb3ItaW9zL1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgLy8gQWxsb3cgcGxheSgpIG9uIGlQaG9uZSB3aXRob3V0IHJlcXVpcmluZyBhIHVzZXIgZ2VzdHVyZS4gU2hvdWxkIG5vdCByZWFsbHkgYmUgbmVlZGVkIGFzIGNhbWVyYSBzdHJlYW1cbiAgICAgICAgLy8gaW5jbHVkZXMgbm8gYXVkaW8sIGJ1dCBqdXN0IHRvIGJlIHNhZmUuXG4gICAgICAgIHZpZGVvLm11dGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBBdm9pZCBTYWZhcmkgc3RvcHBpbmcgdGhlIHZpZGVvIHN0cmVhbSBvbiBhIGhpZGRlbiB2aWRlby5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jb3ptby9qc1FSL2lzc3Vlcy8xODVcbiAgICAgICAgbGV0IHNob3VsZEhpZGVWaWRlbyA9IGZhbHNlO1xuICAgICAgICBpZiAodmlkZW8uaGlkZGVuKSB7XG4gICAgICAgICAgICB2aWRlby5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHNob3VsZEhpZGVWaWRlbyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHZpZGVvKSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh2aWRlbyk7XG4gICAgICAgICAgICBzaG91bGRIaWRlVmlkZW8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZGVvQ29udGFpbmVyID0gdmlkZW8ucGFyZW50RWxlbWVudCE7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0U2NhblJlZ2lvbiB8fCBvcHRpb25zLmhpZ2hsaWdodENvZGVPdXRsaW5lKSB7XG4gICAgICAgICAgICBjb25zdCBnb3RFeHRlcm5hbE92ZXJsYXkgPSAhIW9wdGlvbnMub3ZlcmxheTtcbiAgICAgICAgICAgIHRoaXMuJG92ZXJsYXkgPSBvcHRpb25zLm92ZXJsYXkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjb25zdCBvdmVybGF5U3R5bGUgPSB0aGlzLiRvdmVybGF5LnN0eWxlO1xuICAgICAgICAgICAgb3ZlcmxheVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIG92ZXJsYXlTdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgb3ZlcmxheVN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLiRvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ3NjYW4tcmVnaW9uLWhpZ2hsaWdodCcpO1xuICAgICAgICAgICAgaWYgKCFnb3RFeHRlcm5hbE92ZXJsYXkgJiYgb3B0aW9ucy5oaWdobGlnaHRTY2FuUmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBzdHlsZTsgY2FuIGJlIG92ZXJ3cml0dGVuIHZpYSBjc3MsIGUuZy4gYnkgY2hhbmdpbmcgdGhlIHN2ZydzIHN0cm9rZSBjb2xvciwgaGlkaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIC5zY2FuLXJlZ2lvbi1oaWdobGlnaHQtc3ZnLCBzZXR0aW5nIGEgYm9yZGVyLCBvdXRsaW5lLCBiYWNrZ3JvdW5kLCBldGMuXG4gICAgICAgICAgICAgICAgdGhpcy4kb3ZlcmxheS5pbm5lckhUTUwgPSAnPHN2ZyBjbGFzcz1cInNjYW4tcmVnaW9uLWhpZ2hsaWdodC1zdmdcIiB2aWV3Qm94PVwiMCAwIDIzOCAyMzhcIiAnXG4gICAgICAgICAgICAgICAgICAgICsgJ3ByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2xlZnQ6MDt0b3A6MDsnXG4gICAgICAgICAgICAgICAgICAgICsgJ2ZpbGw6bm9uZTtzdHJva2U6I2U5YjIxMztzdHJva2Utd2lkdGg6NDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmRcIj4nXG4gICAgICAgICAgICAgICAgICAgICsgJzxwYXRoIGQ9XCJNMzEgMkgxMGE4IDggMCAwIDAtOCA4djIxTTIwNyAyaDIxYTggOCAwIDAgMSA4IDh2MjFtMCAxNzZ2MjFhOCA4IDAgMCAxLTggOGgtMjFtLTE3NiAnXG4gICAgICAgICAgICAgICAgICAgICsgJzBIMTBhOCA4IDAgMCAxLTgtOHYtMjFcIi8+PC9zdmc+JztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRvdmVybGF5LmZpcnN0RWxlbWVudENoaWxkIS5hbmltYXRlKHsgdHJhbnNmb3JtOiBbJ3NjYWxlKC45OCknLCAnc2NhbGUoMS4wMSknXSB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0aW9uczogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdhbHRlcm5hdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiAnZWFzZS1pbi1vdXQnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgIHZpZGVvQ29udGFpbmVyLmluc2VydEJlZm9yZSh0aGlzLiRvdmVybGF5LCB0aGlzLiR2aWRlby5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oaWdobGlnaHRDb2RlT3V0bGluZSkge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgc3R5bGU7IGNhbiBiZSBvdmVyd3JpdHRlbiB2aWEgY3NzXG4gICAgICAgICAgICAgICAgdGhpcy4kb3ZlcmxheS5pbnNlcnRBZGphY2VudEhUTUwoXG4gICAgICAgICAgICAgICAgICAgICdiZWZvcmVlbmQnLFxuICAgICAgICAgICAgICAgICAgICAnPHN2ZyBjbGFzcz1cImNvZGUtb3V0bGluZS1oaWdobGlnaHRcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiIHN0eWxlPVwiZGlzcGxheTpub25lO3dpZHRoOjEwMCU7J1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnaGVpZ2h0OjEwMCU7ZmlsbDpub25lO3N0cm9rZTojZTliMjEzO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1kYXNoYXJyYXk6MjU7J1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnc3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kXCI+PHBvbHlnb24vPjwvc3ZnPicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodCA9IHRoaXMuJG92ZXJsYXkubGFzdEVsZW1lbnRDaGlsZCBhcyBTVkdTVkdFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NjYW5SZWdpb24gPSB0aGlzLl9jYWxjdWxhdGVTY2FuUmVnaW9uKHZpZGVvKTtcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2tpbmcgaW4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIHNob3VsZCBhdm9pZCBhIHBvdGVudGlhbCBhZGRpdGlvbmFsIHJlLWZsb3cgZm9yIGdldENvbXB1dGVkU3R5bGUuXG4gICAgICAgICAgICBjb25zdCB2aWRlb1N0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodmlkZW8pO1xuICAgICAgICAgICAgaWYgKHZpZGVvU3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgdmlkZW8uc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnYmxvY2snLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgICAgICAgICAgc2hvdWxkSGlkZVZpZGVvID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWRlb1N0eWxlLnZpc2liaWxpdHkgIT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgICAgIHZpZGVvLnN0eWxlLnNldFByb3BlcnR5KCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgICAgICAgICAgc2hvdWxkSGlkZVZpZGVvID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRIaWRlVmlkZW8pIHtcbiAgICAgICAgICAgICAgICAvLyBIaWRlIHRoZSB2aWRlbyBpbiBhIHdheSB0aGF0IGRvZXNuJ3QgY2F1c2UgU2FmYXJpIHRvIHN0b3AgdGhlIHBsYXliYWNrLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUXJTY2FubmVyIGhhcyBvdmVyd3JpdHRlbiB0aGUgdmlkZW8gaGlkaW5nIHN0eWxlIHRvIGF2b2lkIFNhZmFyaSBzdG9wcGluZyB0aGUgcGxheWJhY2suJyk7XG4gICAgICAgICAgICAgICAgdmlkZW8uc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgICAgICAgICAgICB2aWRlby5zdHlsZS53aWR0aCA9ICcwJztcbiAgICAgICAgICAgICAgICB2aWRlby5zdHlsZS5oZWlnaHQgPSAnMCc7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJG92ZXJsYXkgJiYgdGhpcy4kb3ZlcmxheS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG92ZXJsYXkucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLiRvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRvdmVybGF5ITtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuJGNvZGVPdXRsaW5lSGlnaGxpZ2h0ITtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuJG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVPdmVybGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCB0aGlzLl9vblBsYXkpO1xuICAgICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIHRoaXMuX29uTG9hZGVkTWV0YURhdGEpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX3VwZGF0ZU92ZXJsYXkpO1xuXG4gICAgICAgIHRoaXMuX3FyRW5naW5lUHJvbWlzZSA9IFFyU2Nhbm5lci5jcmVhdGVRckVuZ2luZSgpO1xuICAgIH1cblxuICAgIGFzeW5jIGhhc0ZsYXNoKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBsZXQgc3RyZWFtOiBNZWRpYVN0cmVhbSB8IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiR2aWRlby5zcmNPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLiR2aWRlby5zcmNPYmplY3QgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbSkpIHJldHVybiBmYWxzZTsgLy8gc3JjT2JqZWN0IGlzIG5vdCBhIGNhbWVyYSBzdHJlYW1cbiAgICAgICAgICAgICAgICBzdHJlYW0gPSB0aGlzLiR2aWRlby5zcmNPYmplY3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmVhbSA9IChhd2FpdCB0aGlzLl9nZXRDYW1lcmFTdHJlYW0oKSkuc3RyZWFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICd0b3JjaCcgaW4gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF0uZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gY2xvc2UgdGhlIHN0cmVhbSB3ZSBqdXN0IG9wZW5lZCBmb3IgZGV0ZWN0aW5nIHdoZXRoZXIgaXQgc3VwcG9ydHMgZmxhc2hcbiAgICAgICAgICAgIGlmIChzdHJlYW0gJiYgc3RyZWFtICE9PSB0aGlzLiR2aWRlby5zcmNPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NhbGwgaGFzRmxhc2ggYWZ0ZXIgc3VjY2Vzc2Z1bGx5IHN0YXJ0aW5nIHRoZSBzY2FubmVyIHRvIGF2b2lkIGNyZWF0aW5nICdcbiAgICAgICAgICAgICAgICAgICAgKyAnYSB0ZW1wb3JhcnkgdmlkZW8gc3RyZWFtJyk7XG4gICAgICAgICAgICAgICAgUXJTY2FubmVyLl9zdG9wVmlkZW9TdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRmxhc2hPbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsYXNoT247XG4gICAgfVxuXG4gICAgYXN5bmMgdG9nZ2xlRmxhc2goKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICh0aGlzLl9mbGFzaE9uKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnR1cm5GbGFzaE9mZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50dXJuRmxhc2hPbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgdHVybkZsYXNoT24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICh0aGlzLl9mbGFzaE9uIHx8IHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9mbGFzaE9uID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUgfHwgdGhpcy5fcGF1c2VkKSByZXR1cm47IC8vIGZsYXNoIHdpbGwgYmUgdHVybmVkIG9uIGxhdGVyIG9uIC5zdGFydCgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWF3YWl0IHRoaXMuaGFzRmxhc2goKSkgdGhyb3cgJ05vIGZsYXNoIGF2YWlsYWJsZSc7XG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIHZpZGVvIHRyYWNrIGlzIGd1YXJhbnRlZWQgdG8gZXhpc3QgYW5kIHRvIGJlIGEgTWVkaWFTdHJlYW0gZHVlIHRvIHRoZSBjaGVjayBpbiBoYXNGbGFzaFxuICAgICAgICAgICAgYXdhaXQgKHRoaXMuJHZpZGVvLnNyY09iamVjdCBhcyBNZWRpYVN0cmVhbSkuZ2V0VmlkZW9UcmFja3MoKVswXS5hcHBseUNvbnN0cmFpbnRzKHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBjb25zdHJhaW50ICd0b3JjaCcgaXMgdW5rbm93biB0byB0c1xuICAgICAgICAgICAgICAgIGFkdmFuY2VkOiBbeyB0b3JjaDogdHJ1ZSB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9mbGFzaE9uID0gZmFsc2U7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgdHVybkZsYXNoT2ZmKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoIXRoaXMuX2ZsYXNoT24pIHJldHVybjtcbiAgICAgICAgLy8gYXBwbHlDb25zdHJhaW50cyB3aXRoIHRvcmNoOiBmYWxzZSBkb2VzIG5vdCB3b3JrIHRvIHR1cm4gdGhlIGZsYXNobGlnaHQgb2ZmLCBhcyBhIHN0cmVhbSdzIHRvcmNoIHN0YXlzXG4gICAgICAgIC8vIGNvbnRpbnVvdXNseSBvbiwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVRyYWNrQ29uc3RyYWludHMjdG9yY2guIFRoZXJlZm9yZSxcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBzdG9wIHRoZSBzdHJlYW0gdG8gdHVybiB0aGUgZmxhc2hsaWdodCBvZmYuXG4gICAgICAgIHRoaXMuX2ZsYXNoT24gPSBmYWxzZTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcmVzdGFydFZpZGVvU3RyZWFtKCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy4kdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCB0aGlzLl9vbkxvYWRlZE1ldGFEYXRhKTtcbiAgICAgICAgdGhpcy4kdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheScsIHRoaXMuX29uUGxheSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fdXBkYXRlT3ZlcmxheSk7XG5cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZmxhc2hPbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0b3AoKTsgLy8gc2V0cyB0aGlzLl9wYXVzZWQgPSB0cnVlIGFuZCB0aGlzLl9hY3RpdmUgPSBmYWxzZVxuICAgICAgICBRclNjYW5uZXIuX3Bvc3RXb3JrZXJNZXNzYWdlKHRoaXMuX3FyRW5naW5lUHJvbWlzZSwgJ2Nsb3NlJyk7XG4gICAgfVxuXG4gICAgYXN5bmMgc3RhcnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFFSIHNjYW5uZXIgY2FuIG5vdCBiZSBzdGFydGVkIGFzIGl0IGhhZCBiZWVuIGRlc3Ryb3llZC4nKTtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSAmJiAhdGhpcy5fcGF1c2VkKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIC8vIHdhcm4gYnV0IHRyeSBzdGFydGluZyB0aGUgY2FtZXJhIGFueXdheXNcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIGNhbWVyYSBzdHJlYW0gaXMgb25seSBhY2Nlc3NpYmxlIGlmIHRoZSBwYWdlIGlzIHRyYW5zZmVycmVkIHZpYSBodHRwcy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHJldHVybjsgLy8gY2FtZXJhIHdpbGwgYmUgc3RhcnRlZCBhcyBzb29uIGFzIHRhYiBpcyBpbiBmb3JlZ3JvdW5kXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4kdmlkZW8uc3JjT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBjYW1lcmEgc3RyZWFtIGFscmVhZHkvc3RpbGwgc2V0XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiR2aWRlby5wbGF5KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBzdHJlYW0sIGZhY2luZ01vZGUgfSA9IGF3YWl0IHRoaXMuX2dldENhbWVyYVN0cmVhbSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUgfHwgdGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gd2FzIHN0b3BwZWQgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgICAgICAgICAgUXJTY2FubmVyLl9zdG9wVmlkZW9TdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRWaWRlb01pcnJvcihmYWNpbmdNb2RlKTtcbiAgICAgICAgICAgIHRoaXMuJHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuJHZpZGVvLnBsYXkoKTtcblxuICAgICAgICAgICAgLy8gUmVzdGFydCB0aGUgZmxhc2ggaWYgaXQgd2FzIHByZXZpb3VzbHkgb25cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGFzaE9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmxhc2hPbiA9IGZhbHNlOyAvLyBmb3JjZSB0dXJuRmxhc2hPbiB0byByZXN0YXJ0IHRoZSBmbGFzaFxuICAgICAgICAgICAgICAgIHRoaXMudHVybkZsYXNoT24oKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3AoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYXN5bmMgcGF1c2Uoc3RvcFN0cmVhbUltbWVkaWF0ZWx5ID0gZmFsc2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUpIHJldHVybiB0cnVlO1xuICAgICAgICB0aGlzLiR2aWRlby5wYXVzZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLiRvdmVybGF5KSB7XG4gICAgICAgICAgICB0aGlzLiRvdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9wU3RyZWFtID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHZpZGVvLnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV2b2tlIHNyY09iamVjdCBvbmx5IGlmIGl0J3MgYSBzdHJlYW0gd2hpY2ggd2FzIGxpa2VseSBzZXQgYnkgdXNcbiAgICAgICAgICAgICAgICBRclNjYW5uZXIuX3N0b3BWaWRlb1N0cmVhbSh0aGlzLiR2aWRlby5zcmNPYmplY3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHZpZGVvLnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN0b3BTdHJlYW1JbW1lZGlhdGVseSkge1xuICAgICAgICAgICAgc3RvcFN0cmVhbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKTtcbiAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3RvcFN0cmVhbSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBhc3luYyBzZXRDYW1lcmEoZmFjaW5nTW9kZU9yRGV2aWNlSWQ6IFFyU2Nhbm5lci5GYWNpbmdNb2RlIHwgUXJTY2FubmVyLkRldmljZUlkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmIChmYWNpbmdNb2RlT3JEZXZpY2VJZCA9PT0gdGhpcy5fcHJlZmVycmVkQ2FtZXJhKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3ByZWZlcnJlZENhbWVyYSA9IGZhY2luZ01vZGVPckRldmljZUlkO1xuICAgICAgICAvLyBSZXN0YXJ0IHRoZSBzY2FubmVyIHdpdGggdGhlIG5ldyBjYW1lcmEgd2hpY2ggd2lsbCBhbHNvIHVwZGF0ZSB0aGUgdmlkZW8gbWlycm9yIGFuZCB0aGUgc2NhbiByZWdpb24uXG4gICAgICAgIGF3YWl0IHRoaXMuX3Jlc3RhcnRWaWRlb1N0cmVhbSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBzY2FuSW1hZ2UoXG4gICAgICAgIGltYWdlT3JGaWxlT3JCbG9iT3JVcmw6IEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBPZmZzY3JlZW5DYW52YXMgfCBJbWFnZUJpdG1hcFxuICAgICAgICAgICAgfCBTVkdJbWFnZUVsZW1lbnQgfCBGaWxlIHwgQmxvYiB8IFVSTCB8IFN0cmluZyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgc2NhblJlZ2lvbj86IFFyU2Nhbm5lci5TY2FuUmVnaW9uIHwgbnVsbCxcbiAgICAgICAgICAgIHFyRW5naW5lPzogV29ya2VyIHwgQmFyY29kZURldGVjdG9yIHwgUHJvbWlzZTxXb3JrZXIgfCBCYXJjb2RlRGV0ZWN0b3I+IHwgbnVsbCxcbiAgICAgICAgICAgIGNhbnZhcz86IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCxcbiAgICAgICAgICAgIGRpc2FsbG93Q2FudmFzUmVzaXppbmc/OiBib29sZWFuLFxuICAgICAgICAgICAgYWxzb1RyeVdpdGhvdXRTY2FuUmVnaW9uPzogYm9vbGVhbixcbiAgICAgICAgICAgIC8qKiBqdXN0IGEgdGVtcG9yYXJ5IGZsYWcgdW50aWwgd2Ugc3dpdGNoIGVudGlyZWx5IHRvIHRoZSBuZXcgYXBpICovXG4gICAgICAgICAgICByZXR1cm5EZXRhaWxlZFNjYW5SZXN1bHQ/OiB0cnVlLFxuICAgICAgICB9LFxuICAgICk6IFByb21pc2U8UXJTY2FubmVyLlNjYW5SZXN1bHQ+O1xuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHN0YXRpYyBhc3luYyBzY2FuSW1hZ2UoXG4gICAgICAgIGltYWdlT3JGaWxlT3JCbG9iT3JVcmw6IEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBPZmZzY3JlZW5DYW52YXMgfCBJbWFnZUJpdG1hcFxuICAgICAgICAgICAgfCBTVkdJbWFnZUVsZW1lbnQgfCBGaWxlIHwgQmxvYiB8IFVSTCB8IFN0cmluZyxcbiAgICAgICAgc2NhblJlZ2lvbj86IFFyU2Nhbm5lci5TY2FuUmVnaW9uIHwgbnVsbCxcbiAgICAgICAgcXJFbmdpbmU/OiBXb3JrZXIgfCBCYXJjb2RlRGV0ZWN0b3IgfCBQcm9taXNlPFdvcmtlciB8IEJhcmNvZGVEZXRlY3Rvcj4gfCBudWxsLFxuICAgICAgICBjYW52YXM/OiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwsXG4gICAgICAgIGRpc2FsbG93Q2FudmFzUmVzaXppbmc/OiBib29sZWFuLFxuICAgICAgICBhbHNvVHJ5V2l0aG91dFNjYW5SZWdpb24/OiBib29sZWFuLFxuICAgICk6IFByb21pc2U8c3RyaW5nPjtcbiAgICBzdGF0aWMgYXN5bmMgc2NhbkltYWdlKFxuICAgICAgICBpbWFnZU9yRmlsZU9yQmxvYk9yVXJsOiBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzIHwgSW1hZ2VCaXRtYXBcbiAgICAgICAgICAgIHwgU1ZHSW1hZ2VFbGVtZW50IHwgRmlsZSB8IEJsb2IgfCBVUkwgfCBTdHJpbmcsXG4gICAgICAgIHNjYW5SZWdpb25Pck9wdGlvbnM/OiBRclNjYW5uZXIuU2NhblJlZ2lvbiB8IHtcbiAgICAgICAgICAgIHNjYW5SZWdpb24/OiBRclNjYW5uZXIuU2NhblJlZ2lvbiB8IG51bGwsXG4gICAgICAgICAgICBxckVuZ2luZT86IFdvcmtlciB8IEJhcmNvZGVEZXRlY3RvciB8IFByb21pc2U8V29ya2VyIHwgQmFyY29kZURldGVjdG9yPiB8IG51bGwsXG4gICAgICAgICAgICBjYW52YXM/OiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwsXG4gICAgICAgICAgICBkaXNhbGxvd0NhbnZhc1Jlc2l6aW5nPzogYm9vbGVhbixcbiAgICAgICAgICAgIGFsc29UcnlXaXRob3V0U2NhblJlZ2lvbj86IGJvb2xlYW4sXG4gICAgICAgICAgICAvKioganVzdCBhIHRlbXBvcmFyeSBmbGFnIHVudGlsIHdlIHN3aXRjaCBlbnRpcmVseSB0byB0aGUgbmV3IGFwaSAqL1xuICAgICAgICAgICAgcmV0dXJuRGV0YWlsZWRTY2FuUmVzdWx0PzogdHJ1ZSxcbiAgICAgICAgfSB8IG51bGwsXG4gICAgICAgIHFyRW5naW5lPzogV29ya2VyIHwgQmFyY29kZURldGVjdG9yIHwgUHJvbWlzZTxXb3JrZXIgfCBCYXJjb2RlRGV0ZWN0b3I+IHwgbnVsbCxcbiAgICAgICAgY2FudmFzPzogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsLFxuICAgICAgICBkaXNhbGxvd0NhbnZhc1Jlc2l6aW5nOiBib29sZWFuID0gZmFsc2UsXG4gICAgICAgIGFsc29UcnlXaXRob3V0U2NhblJlZ2lvbjogYm9vbGVhbiA9IGZhbHNlLFxuICAgICk6IFByb21pc2U8c3RyaW5nIHwgUXJTY2FubmVyLlNjYW5SZXN1bHQ+IHtcbiAgICAgICAgbGV0IHNjYW5SZWdpb246IFFyU2Nhbm5lci5TY2FuUmVnaW9uIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJldHVybkRldGFpbGVkU2NhblJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAoc2NhblJlZ2lvbk9yT3B0aW9ucyAmJiAoXG4gICAgICAgICAgICAnc2NhblJlZ2lvbicgaW4gc2NhblJlZ2lvbk9yT3B0aW9uc1xuICAgICAgICAgICAgfHwgJ3FyRW5naW5lJyBpbiBzY2FuUmVnaW9uT3JPcHRpb25zXG4gICAgICAgICAgICB8fCAnY2FudmFzJyBpbiBzY2FuUmVnaW9uT3JPcHRpb25zXG4gICAgICAgICAgICB8fCAnZGlzYWxsb3dDYW52YXNSZXNpemluZycgaW4gc2NhblJlZ2lvbk9yT3B0aW9uc1xuICAgICAgICAgICAgfHwgJ2Fsc29UcnlXaXRob3V0U2NhblJlZ2lvbicgaW4gc2NhblJlZ2lvbk9yT3B0aW9uc1xuICAgICAgICAgICAgfHwgJ3JldHVybkRldGFpbGVkU2NhblJlc3VsdCcgaW4gc2NhblJlZ2lvbk9yT3B0aW9uc1xuICAgICAgICApKSB7XG4gICAgICAgICAgICAvLyB3ZSBnb3QgYW4gb3B0aW9ucyBvYmplY3QgdXNpbmcgdGhlIG5ldyBhcGlcbiAgICAgICAgICAgIHNjYW5SZWdpb24gPSBzY2FuUmVnaW9uT3JPcHRpb25zLnNjYW5SZWdpb247XG4gICAgICAgICAgICBxckVuZ2luZSA9IHNjYW5SZWdpb25Pck9wdGlvbnMucXJFbmdpbmU7XG4gICAgICAgICAgICBjYW52YXMgPSBzY2FuUmVnaW9uT3JPcHRpb25zLmNhbnZhcztcbiAgICAgICAgICAgIGRpc2FsbG93Q2FudmFzUmVzaXppbmcgPSBzY2FuUmVnaW9uT3JPcHRpb25zLmRpc2FsbG93Q2FudmFzUmVzaXppbmcgfHwgZmFsc2U7XG4gICAgICAgICAgICBhbHNvVHJ5V2l0aG91dFNjYW5SZWdpb24gPSBzY2FuUmVnaW9uT3JPcHRpb25zLmFsc29UcnlXaXRob3V0U2NhblJlZ2lvbiB8fCBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybkRldGFpbGVkU2NhblJlc3VsdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NhblJlZ2lvbk9yT3B0aW9ucyB8fCBxckVuZ2luZSB8fCBjYW52YXMgfHwgZGlzYWxsb3dDYW52YXNSZXNpemluZyB8fCBhbHNvVHJ5V2l0aG91dFNjYW5SZWdpb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignWW91XFwncmUgdXNpbmcgYSBkZXByZWNhdGVkIGFwaSBmb3Igc2NhbkltYWdlIHdoaWNoIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT25seSBpbWFnZU9yRmlsZU9yQmxvYk9yVXJsIHdhcyBzcGVjaWZpZWQgYW5kIHdlIGNhbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gbmV3IG9yIG9sZCBhcGkgdXNhZ2UuIEZvclxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2UgaGF2ZSB0byBhc3N1bWUgdGhlIG9sZCBhcGkgZm9yIG5vdy4gVGhlIG9wdGlvbnMgb2JqZWN0IGlzIG1hcmtlZCBhcyBub24tXG4gICAgICAgICAgICAvLyBvcHRpb25hbCBpbiB0aGUgcGFyYW1ldGVyIGxpc3QgYWJvdmUgdG8gbWFrZSBjbGVhciB0aGF0IFNjYW5SZXN1bHQgaW5zdGVhZCBvZiBzdHJpbmcgaXMgb25seSByZXR1cm5lZCBpZlxuICAgICAgICAgICAgLy8gYW4gb3B0aW9ucyBvYmplY3Qgd2FzIHByb3ZpZGVkLiBIb3dldmVyLCBpbiB0aGUgZnV0dXJlIG9uY2UgbGVnYWN5IHN1cHBvcnQgaXMgcmVtb3ZlZCwgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICAvLyBzaG91bGQgYmVjb21lIG9wdGlvbmFsLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdOb3RlIHRoYXQgdGhlIHJldHVybiB0eXBlIG9mIHNjYW5JbWFnZSB3aWxsIGNoYW5nZSBpbiB0aGUgZnV0dXJlLiBUbyBhbHJlYWR5IHN3aXRjaCB0byB0aGUgJ1xuICAgICAgICAgICAgICAgICsgJ25ldyBhcGkgdG9kYXksIHlvdSBjYW4gcGFzcyByZXR1cm5EZXRhaWxlZFNjYW5SZXN1bHQ6IHRydWUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBnb3RFeHRlcm5hbEVuZ2luZSA9ICEhcXJFbmdpbmU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBpbWFnZTogSFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcyB8IEltYWdlQml0bWFwXG4gICAgICAgICAgICAgICAgfCBTVkdJbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBsZXQgY2FudmFzQ29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgICAgICAgICAgW3FyRW5naW5lLCBpbWFnZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgcXJFbmdpbmUgfHwgUXJTY2FubmVyLmNyZWF0ZVFyRW5naW5lKCksXG4gICAgICAgICAgICAgICAgUXJTY2FubmVyLl9sb2FkSW1hZ2UoaW1hZ2VPckZpbGVPckJsb2JPclVybCksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIFtjYW52YXMsIGNhbnZhc0NvbnRleHRdID0gUXJTY2FubmVyLl9kcmF3VG9DYW52YXMoaW1hZ2UsIHNjYW5SZWdpb24sIGNhbnZhcywgZGlzYWxsb3dDYW52YXNSZXNpemluZyk7XG4gICAgICAgICAgICBsZXQgZGV0YWlsZWRTY2FuUmVzdWx0OiBRclNjYW5uZXIuU2NhblJlc3VsdDtcblxuICAgICAgICAgICAgaWYgKHFyRW5naW5lIGluc3RhbmNlb2YgV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcXJFbmdpbmVXb3JrZXIgPSBxckVuZ2luZTsgLy8gZm9yIHRzIHRvIGtub3cgdGhhdCBpdCdzIHN0aWxsIGEgd29ya2VyIGxhdGVyIGluIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICBpZiAoIWdvdEV4dGVybmFsRW5naW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBzY2FubmluZyBvZiBpbnZlcnRlZCBjb2xvciBxciBjb2Rlcy5cbiAgICAgICAgICAgICAgICAgICAgUXJTY2FubmVyLl9wb3N0V29ya2VyTWVzc2FnZVN5bmMocXJFbmdpbmVXb3JrZXIsICdpbnZlcnNpb25Nb2RlJywgJ2JvdGgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGV0YWlsZWRTY2FuUmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGltZW91dDogbnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25NZXNzYWdlOiAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4gdm9pZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9uRXJyb3I6IChlcnJvcjogRXJyb3JFdmVudCB8IHN0cmluZykgPT4gdm9pZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV4cGVjdGVkUmVzcG9uc2VJZCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBvbk1lc3NhZ2UgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuaWQgIT09IGV4cGVjdGVkUmVzcG9uc2VJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHFyRW5naW5lV29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXJFbmdpbmVXb3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZXZlbnQuZGF0YS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXJQb2ludHM6IFFyU2Nhbm5lci5fY29udmVydFBvaW50cyhldmVudC5kYXRhLmNvcm5lclBvaW50cywgc2NhblJlZ2lvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChRclNjYW5uZXIuTk9fUVJfQ09ERV9GT1VORCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IgPSAoZXJyb3I6IEVycm9yRXZlbnQgfCBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFyRW5naW5lV29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXJFbmdpbmVXb3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICFlcnJvciA/ICdVbmtub3duIEVycm9yJyA6ICgoZXJyb3IgYXMgRXJyb3JFdmVudCkubWVzc2FnZSB8fCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoJ1NjYW5uZXIgZXJyb3I6ICcgKyBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBxckVuZ2luZVdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcXJFbmdpbmVXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gb25FcnJvcigndGltZW91dCcpLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNhbnZhc0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcyEud2lkdGgsIGNhbnZhcyEuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRSZXNwb25zZUlkID0gUXJTY2FubmVyLl9wb3N0V29ya2VyTWVzc2FnZVN5bmMoXG4gICAgICAgICAgICAgICAgICAgICAgICBxckVuZ2luZVdvcmtlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZWNvZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgW2ltYWdlRGF0YS5kYXRhLmJ1ZmZlcl0sXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRldGFpbGVkU2NhblJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlPFFyU2Nhbm5lci5TY2FuUmVzdWx0PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB3aW5kb3cuc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHJlamVjdCgnU2Nhbm5lciBlcnJvcjogdGltZW91dCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTAwMDAsXG4gICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAoYXN5bmMgKCk6IFByb21pc2U8UXJTY2FubmVyLlNjYW5SZXN1bHQ+ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3NjYW5SZXN1bHRdID0gYXdhaXQgcXJFbmdpbmUuZGV0ZWN0KGNhbnZhcyEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NhblJlc3VsdCkgdGhyb3cgUXJTY2FubmVyLk5PX1FSX0NPREVfRk9VTkQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc2NhblJlc3VsdC5yYXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVyUG9pbnRzOiBRclNjYW5uZXIuX2NvbnZlcnRQb2ludHMoc2NhblJlc3VsdC5jb3JuZXJQb2ludHMsIHNjYW5SZWdpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKGUgYXMgRXJyb3IpLm1lc3NhZ2UgfHwgZSBhcyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9ub3QgaW1wbGVtZW50ZWR8c2VydmljZSB1bmF2YWlsYWJsZS8udGVzdChlcnJvck1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBjYW4gYXBwYXJlbnRseSBmb3Igc29tZSByZWFzb24gaGFwcGVuIGV2ZW4gdGhvdWdoIGdldFN1cHBvcnRlZEZvcm1hdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY3JlYXRlUXJTY2FubmVyIHJlcG9ydGVkIHRoYXQgaXQncyBzdXBwb3J0ZWQsIHNlZSBpc3N1ZSAjOTguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcnZpY2UgdW5hdmFpbGFibGUgY2FuIGhhcHBlbiBhZnRlciBzb21lIHRpbWUgd2hlbiB0aGUgQmFyY29kZURldGVjdG9yIGNyYXNoZWQgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiB0aGVvcmV0aWNhbGx5IGJlIHJlY292ZXJlZCBmcm9tIGJ5IGNyZWF0aW5nIGEgbmV3IEJhcmNvZGVEZXRlY3Rvci4gSG93ZXZlciwgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV3ZXIgYnJvd3NlcnMgdGhpcyBpc3N1ZSBkb2VzIG5vdCBzZWVtIHRvIGJlIHByZXNlbnQgYW55bW9yZSBhbmQgdGhlcmVmb3JlIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSB0aGlzIG9wdGltaXphdGlvbiBhbnltb3JlIGJ1dCBqdXN0IHNldCBfZGlzYWJsZUJhcmNvZGVEZXRlY3RvciBpbiBib3RoIGNhc2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCBpZiB3ZSBnb3QgYW4gZXh0ZXJuYWwgcXJFbmdpbmUgdGhhdCBjcmFzaGVkLCB3ZSBzaG91bGQgcG9zc2libHkgbm90aWZ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjYWxsZXIgYWJvdXQgaXQsIGJ1dCB3ZSBhbHNvIGRvbid0IGRvIHRoaXMgaGVyZSwgYXMgaXQncyBzdWNoIGFuIHVubGlrZWx5IGNhc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFFyU2Nhbm5lci5fZGlzYWJsZUJhcmNvZGVEZXRlY3RvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdpdGhvdXQgcGFzc2luZyB0aGUgYnJva2VuIEJhcmNvZGVTY2FubmVyIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBRclNjYW5uZXIuc2NhbkltYWdlKGltYWdlT3JGaWxlT3JCbG9iT3JVcmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5SZWdpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhbGxvd0NhbnZhc1Jlc2l6aW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxzb1RyeVdpdGhvdXRTY2FuUmVnaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFNjYW5uZXIgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuRGV0YWlsZWRTY2FuUmVzdWx0ID8gZGV0YWlsZWRTY2FuUmVzdWx0IDogZGV0YWlsZWRTY2FuUmVzdWx0LmRhdGE7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghc2NhblJlZ2lvbiB8fCAhYWxzb1RyeVdpdGhvdXRTY2FuUmVnaW9uKSB0aHJvdyBlO1xuICAgICAgICAgICAgY29uc3QgZGV0YWlsZWRTY2FuUmVzdWx0ID0gYXdhaXQgUXJTY2FubmVyLnNjYW5JbWFnZShcbiAgICAgICAgICAgICAgICBpbWFnZU9yRmlsZU9yQmxvYk9yVXJsLFxuICAgICAgICAgICAgICAgIHsgcXJFbmdpbmUsIGNhbnZhcywgZGlzYWxsb3dDYW52YXNSZXNpemluZyB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5EZXRhaWxlZFNjYW5SZXN1bHQgPyBkZXRhaWxlZFNjYW5SZXN1bHQgOiBkZXRhaWxlZFNjYW5SZXN1bHQuZGF0YTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICghZ290RXh0ZXJuYWxFbmdpbmUpIHtcbiAgICAgICAgICAgICAgICBRclNjYW5uZXIuX3Bvc3RXb3JrZXJNZXNzYWdlKHFyRW5naW5lISwgJ2Nsb3NlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRHcmF5c2NhbGVXZWlnaHRzKHJlZDogbnVtYmVyLCBncmVlbjogbnVtYmVyLCBibHVlOiBudW1iZXIsIHVzZUludGVnZXJBcHByb3hpbWF0aW9uOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgICAvLyBOb3RlIHRoYXQgZm9yIHRoZSBuYXRpdmUgQmFyY29kZURlY29kZXIgb3IgaWYgdGhlIHdvcmtlciB3YXMgZGVzdHJveWVkLCB0aGlzIGlzIGEgbm8tb3AuIEhvd2V2ZXIsIHRoZSBuYXRpdmVcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb25zIHdvcmsgYWxzbyB3ZWxsIHdpdGggY29sb3JlZCBxciBjb2Rlcy5cbiAgICAgICAgUXJTY2FubmVyLl9wb3N0V29ya2VyTWVzc2FnZShcbiAgICAgICAgICAgIHRoaXMuX3FyRW5naW5lUHJvbWlzZSxcbiAgICAgICAgICAgICdncmF5c2NhbGVXZWlnaHRzJyxcbiAgICAgICAgICAgIHsgcmVkLCBncmVlbiwgYmx1ZSwgdXNlSW50ZWdlckFwcHJveGltYXRpb24gfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldEludmVyc2lvbk1vZGUoaW52ZXJzaW9uTW9kZTogUXJTY2FubmVyLkludmVyc2lvbk1vZGUpOiB2b2lkIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGZvciB0aGUgbmF0aXZlIEJhcmNvZGVEZWNvZGVyIG9yIGlmIHRoZSB3b3JrZXIgd2FzIGRlc3Ryb3llZCwgdGhpcyBpcyBhIG5vLW9wLiBIb3dldmVyLCB0aGUgbmF0aXZlXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9ucyBzY2FuIG5vcm1hbCBhbmQgaW52ZXJ0ZWQgcXIgY29kZXMgYnkgZGVmYXVsdFxuICAgICAgICBRclNjYW5uZXIuX3Bvc3RXb3JrZXJNZXNzYWdlKHRoaXMuX3FyRW5naW5lUHJvbWlzZSwgJ2ludmVyc2lvbk1vZGUnLCBpbnZlcnNpb25Nb2RlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlUXJFbmdpbmUoKTogUHJvbWlzZTxXb3JrZXIgfCBCYXJjb2RlRGV0ZWN0b3I+O1xuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGVRckVuZ2luZSh3b3JrZXJQYXRoOiBzdHJpbmcpOiBQcm9taXNlPFdvcmtlciB8IEJhcmNvZGVEZXRlY3Rvcj47XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZVFyRW5naW5lKHdvcmtlclBhdGg/OiBzdHJpbmcpOiBQcm9taXNlPFdvcmtlciB8IEJhcmNvZGVEZXRlY3Rvcj4ge1xuICAgICAgICBpZiAod29ya2VyUGF0aCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdTcGVjaWZ5aW5nIGEgd29ya2VyIHBhdGggaXMgbm90IHJlcXVpcmVkIGFuZCBub3Qgc3VwcG9ydGVkIGFueW1vcmUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlIG5vIHR5cGVzIGRlZmluZWQgZm9yIGltcG9ydFxuICAgICAgICBjb25zdCBjcmVhdGVXb3JrZXIgPSAoKSA9PiAoaW1wb3J0KCcuL3FyLXNjYW5uZXItd29ya2VyLm1pbi5qcycpIGFzIFByb21pc2U8eyBjcmVhdGVXb3JrZXI6ICgpID0+IFdvcmtlciB9PilcbiAgICAgICAgICAgIC50aGVuKChtb2R1bGUpID0+IG1vZHVsZS5jcmVhdGVXb3JrZXIoKSk7XG5cbiAgICAgICAgY29uc3QgdXNlQmFyY29kZURldGVjdG9yID0gIVFyU2Nhbm5lci5fZGlzYWJsZUJhcmNvZGVEZXRlY3RvclxuICAgICAgICAgICAgJiYgJ0JhcmNvZGVEZXRlY3RvcicgaW4gd2luZG93XG4gICAgICAgICAgICAmJiBCYXJjb2RlRGV0ZWN0b3IuZ2V0U3VwcG9ydGVkRm9ybWF0c1xuICAgICAgICAgICAgJiYgKGF3YWl0IEJhcmNvZGVEZXRlY3Rvci5nZXRTdXBwb3J0ZWRGb3JtYXRzKCkpLmluY2x1ZGVzKCdxcl9jb2RlJyk7XG5cbiAgICAgICAgaWYgKCF1c2VCYXJjb2RlRGV0ZWN0b3IpIHJldHVybiBjcmVhdGVXb3JrZXIoKTtcblxuICAgICAgICAvLyBPbiBNYWNzIHdpdGggYW4gTTEvTTIgcHJvY2Vzc29yIGFuZCBtYWNPUyBWZW50dXJhIChtYWNPUyB2ZXJzaW9uIDEzKSwgdGhlIEJhcmNvZGVEZXRlY3RvciBpcyBicm9rZW4gaW5cbiAgICAgICAgLy8gQ2hyb21pdW0gYmFzZWQgYnJvd3NlcnMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZlcnNpb24uIEZvciB0aGF0IGNvbnN0ZWxsYXRpb24sIHRoZSBCYXJjb2RlRGV0ZWN0b3IgZG9lcyBub3RcbiAgICAgICAgLy8gZXJyb3IgYnV0IGRvZXMgbm90IGRldGVjdCBRUiBjb2Rlcy4gTWFjcyB3aXRob3V0IGFuIE0xL00yIG9yIGJlZm9yZSBWZW50dXJhIGFyZSBmaW5lLlxuICAgICAgICAvLyBTZWUgaXNzdWUgIzIwOSBhbmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTM4MjQ0MlxuICAgICAgICAvLyBUT0RPIHVwZGF0ZSB0aGlzIG9uY2UgdGhlIGlzc3VlIGluIG1hY09TIGlzIGZpeGVkXG4gICAgICAgIGNvbnN0IHVzZXJBZ2VudERhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgICAgICAgY29uc3QgaXNDaHJvbWl1bU9uTWFjV2l0aEFybVZlbnR1cmEgPSB1c2VyQWdlbnREYXRhIC8vIGFsbCBDaHJvbWl1bSBicm93c2VycyBzdXBwb3J0IHVzZXJBZ2VudERhdGFcbiAgICAgICAgICAgICYmIHVzZXJBZ2VudERhdGEuYnJhbmRzLnNvbWUoKHsgYnJhbmQgfSkgPT4gL0Nocm9taXVtL2kudGVzdChicmFuZCkpXG4gICAgICAgICAgICAmJiAvbWFjID9PUy9pLnRlc3QodXNlckFnZW50RGF0YS5wbGF0Zm9ybSlcbiAgICAgICAgICAgIC8vIERvZXMgaXQgaGF2ZSBhbiBBUk0gY2hpcCAoZS5nLiBNMS9NMikgYW5kIFZlbnR1cmE/IENoZWNrIHRoaXMgbGFzdCBhcyBnZXRIaWdoRW50cm9weVZhbHVlcyBjYW5cbiAgICAgICAgICAgIC8vIHRoZW9yZXRpY2FsbHkgdHJpZ2dlciBhIGJyb3dzZXIgcHJvbXB0LCBhbHRob3VnaCBubyBicm93c2VyIGN1cnJlbnRseSBkb2VzIHNlZW0gdG8gc2hvdyBvbmUuXG4gICAgICAgICAgICAvLyBJZiBicm93c2VyIG9yIHVzZXIgcmVmdXNlZCB0byByZXR1cm4gdGhlIHJlcXVlc3RlZCB2YWx1ZXMsIGFzc3VtZSBicm9rZW4gQVJNIFZlbnR1cmEsIHRvIGJlIHNhZmUuXG4gICAgICAgICAgICAmJiBhd2FpdCB1c2VyQWdlbnREYXRhLmdldEhpZ2hFbnRyb3B5VmFsdWVzKFsnYXJjaGl0ZWN0dXJlJywgJ3BsYXRmb3JtVmVyc2lvbiddKVxuICAgICAgICAgICAgICAgIC50aGVuKCh7IGFyY2hpdGVjdHVyZSwgcGxhdGZvcm1WZXJzaW9uIH0pID0+XG4gICAgICAgICAgICAgICAgICAgIC9hcm0vaS50ZXN0KGFyY2hpdGVjdHVyZSB8fCAnYXJtJykgJiYgcGFyc2VJbnQocGxhdGZvcm1WZXJzaW9uIHx8ICcxMycpID49IC8qIFZlbnR1cmEgKi8gMTMpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHRydWUpO1xuICAgICAgICBpZiAoaXNDaHJvbWl1bU9uTWFjV2l0aEFybVZlbnR1cmEpIHJldHVybiBjcmVhdGVXb3JrZXIoKTtcblxuICAgICAgICByZXR1cm4gbmV3IEJhcmNvZGVEZXRlY3Rvcih7IGZvcm1hdHM6IFsncXJfY29kZSddIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgX29uUGxheSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc2NhblJlZ2lvbiA9IHRoaXMuX2NhbGN1bGF0ZVNjYW5SZWdpb24odGhpcy4kdmlkZW8pO1xuICAgICAgICB0aGlzLl91cGRhdGVPdmVybGF5KCk7XG4gICAgICAgIGlmICh0aGlzLiRvdmVybGF5KSB7XG4gICAgICAgICAgICB0aGlzLiRvdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zY2FuRnJhbWUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9vbkxvYWRlZE1ldGFEYXRhKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zY2FuUmVnaW9uID0gdGhpcy5fY2FsY3VsYXRlU2NhblJlZ2lvbih0aGlzLiR2aWRlbyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU92ZXJsYXkoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9vblZpc2liaWxpdHlDaGFuZ2UoKTogdm9pZCB7XG4gICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX2NhbGN1bGF0ZVNjYW5SZWdpb24odmlkZW86IEhUTUxWaWRlb0VsZW1lbnQpOiBRclNjYW5uZXIuU2NhblJlZ2lvbiB7XG4gICAgICAgIC8vIERlZmF1bHQgc2NhbiByZWdpb24gY2FsY3VsYXRpb24uIE5vdGUgdGhhdCB0aGlzIGNhbiBiZSBvdmVyd3JpdHRlbiBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgIGNvbnN0IHNtYWxsZXN0RGltZW5zaW9uID0gTWF0aC5taW4odmlkZW8udmlkZW9XaWR0aCwgdmlkZW8udmlkZW9IZWlnaHQpO1xuICAgICAgICBjb25zdCBzY2FuUmVnaW9uU2l6ZSA9IE1hdGgucm91bmQoMiAvIDMgKiBzbWFsbGVzdERpbWVuc2lvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBNYXRoLnJvdW5kKCh2aWRlby52aWRlb1dpZHRoIC0gc2NhblJlZ2lvblNpemUpIC8gMiksXG4gICAgICAgICAgICB5OiBNYXRoLnJvdW5kKCh2aWRlby52aWRlb0hlaWdodCAtIHNjYW5SZWdpb25TaXplKSAvIDIpLFxuICAgICAgICAgICAgd2lkdGg6IHNjYW5SZWdpb25TaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiBzY2FuUmVnaW9uU2l6ZSxcbiAgICAgICAgICAgIGRvd25TY2FsZWRXaWR0aDogdGhpcy5fbGVnYWN5Q2FudmFzU2l6ZSxcbiAgICAgICAgICAgIGRvd25TY2FsZWRIZWlnaHQ6IHRoaXMuX2xlZ2FjeUNhbnZhc1NpemUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdXBkYXRlT3ZlcmxheSgpOiB2b2lkIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJ1bm5pbmcgaW4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIHNob3VsZCBhdm9pZCBhIHBvdGVudGlhbCBhZGRpdGlvbmFsIHJlLWZsb3cgZm9yIGdldENvbXB1dGVkU3R5bGVcbiAgICAgICAgICAgIC8vIGFuZCBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0LCBvZmZzZXRMZWZ0LCBvZmZzZXRUb3AuXG4gICAgICAgICAgICBpZiAoIXRoaXMuJG92ZXJsYXkpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvID0gdGhpcy4kdmlkZW87XG4gICAgICAgICAgICBjb25zdCB2aWRlb1dpZHRoID0gdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvSGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50V2lkdGggPSB2aWRlby5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRIZWlnaHQgPSB2aWRlby5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50WCA9IHZpZGVvLm9mZnNldExlZnQ7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50WSA9IHZpZGVvLm9mZnNldFRvcDtcblxuICAgICAgICAgICAgY29uc3QgdmlkZW9TdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHZpZGVvKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvT2JqZWN0Rml0ID0gdmlkZW9TdHlsZS5vYmplY3RGaXQ7XG4gICAgICAgICAgICBjb25zdCB2aWRlb0FzcGVjdFJhdGlvID0gdmlkZW9XaWR0aCAvIHZpZGVvSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudEFzcGVjdFJhdGlvID0gZWxlbWVudFdpZHRoIC8gZWxlbWVudEhlaWdodDtcbiAgICAgICAgICAgIGxldCB2aWRlb1NjYWxlZFdpZHRoOiBudW1iZXI7XG4gICAgICAgICAgICBsZXQgdmlkZW9TY2FsZWRIZWlnaHQ6IG51bWJlcjtcbiAgICAgICAgICAgIHN3aXRjaCAodmlkZW9PYmplY3RGaXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICAgICAgdmlkZW9TY2FsZWRXaWR0aCA9IHZpZGVvV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvU2NhbGVkSGVpZ2h0ID0gdmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGwnOlxuICAgICAgICAgICAgICAgICAgICB2aWRlb1NjYWxlZFdpZHRoID0gZWxlbWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2aWRlb1NjYWxlZEhlaWdodCA9IGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC8vICdjb3ZlcicsICdjb250YWlucycsICdzY2FsZS1kb3duJ1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlkZW9PYmplY3RGaXQgPT09ICdjb3ZlcidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmlkZW9Bc3BlY3RSYXRpbyA+IGVsZW1lbnRBc3BlY3RSYXRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB2aWRlb0FzcGVjdFJhdGlvIDwgZWxlbWVudEFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2NhbGVkIGhlaWdodCBpcyB0aGUgZWxlbWVudCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gZm9yICdjb3ZlcicgaWYgdGhlIHZpZGVvIGFzcGVjdCByYXRpbyBpcyB3aWRlciB0aGFuIHRoZSBlbGVtZW50IGFzcGVjdCByYXRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAoc2NhbGVkIGhlaWdodCBtYXRjaGVzIGVsZW1lbnQgaGVpZ2h0IGFuZCBzY2FsZWQgd2lkdGggb3ZlcmZsb3dzIGVsZW1lbnQgd2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtIGZvciAnY29udGFpbnMnLydzY2FsZS1kb3duJyBpZiBlbGVtZW50IGFzcGVjdCByYXRpbyBpcyB3aWRlciB0aGFuIHRoZSB2aWRlbyBhc3BlY3QgcmF0aW9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgKHNjYWxlZCBoZWlnaHQgbWF0Y2hlZCBlbGVtZW50IGhlaWdodCBhbmQgZWxlbWVudCB3aWR0aCBvdmVyZmxvd3Mgc2NhbGVkIHdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9TY2FsZWRIZWlnaHQgPSBlbGVtZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9TY2FsZWRXaWR0aCA9IHZpZGVvU2NhbGVkSGVpZ2h0ICogdmlkZW9Bc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvU2NhbGVkV2lkdGggPSBlbGVtZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb1NjYWxlZEhlaWdodCA9IHZpZGVvU2NhbGVkV2lkdGggLyB2aWRlb0FzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWRlb09iamVjdEZpdCA9PT0gJ3NjYWxlLWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgJ3NjYWxlLWRvd24nIHRoZSBkaW1lbnNpb25zIGFyZSB0aGUgbWluaW11bSBvZiAnY29udGFpbnMnIGFuZCAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvU2NhbGVkV2lkdGggPSBNYXRoLm1pbih2aWRlb1NjYWxlZFdpZHRoLCB2aWRlb1dpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvU2NhbGVkSGVpZ2h0ID0gTWF0aC5taW4odmlkZW9TY2FsZWRIZWlnaHQsIHZpZGVvSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnZXRDb21wdXRlZFN0eWxlIGlzIHNvIG5pY2UgdG8gY29udmVydCBrZXl3b3JkcyAobGVmdCwgY2VudGVyLCByaWdodCwgdG9wLCBib3R0b20pIHRvIHBlcmNlbnQgYW5kIG1ha2VzXG4gICAgICAgICAgICAvLyBzdXJlIHRvIHNldCB0aGUgZGVmYXVsdCBvZiA1MCUgaWYgb25seSBvbmUgb3Igbm8gY29tcG9uZW50IHdhcyBwcm92aWRlZCwgdGhlcmVmb3JlIHdlIGNhbiBiZSBzdXJlIHRoYXRcbiAgICAgICAgICAgIC8vIGJvdGggY29tcG9uZW50cyBhcmUgc2V0LiBBZGRpdGlvbmFsbHksIGl0IGNvbnZlcnRzIHVuaXRzIG90aGVyIHRoYW4gcHggKGUuZy4gcmVtKSB0byBweC5cbiAgICAgICAgICAgIGNvbnN0IFt2aWRlb1gsIHZpZGVvWV0gPSB2aWRlb1N0eWxlLm9iamVjdFBvc2l0aW9uLnNwbGl0KCcgJykubWFwKChsZW5ndGgsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhWYWx1ZSA9IHBhcnNlRmxvYXQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoLmVuZHNXaXRoKCclJylcbiAgICAgICAgICAgICAgICAgICAgPyAoIWkgPyBlbGVtZW50V2lkdGggLSB2aWRlb1NjYWxlZFdpZHRoIDogZWxlbWVudEhlaWdodCAtIHZpZGVvU2NhbGVkSGVpZ2h0KSAqIGxlbmd0aFZhbHVlIC8gMTAwXG4gICAgICAgICAgICAgICAgICAgIDogbGVuZ3RoVmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcmVnaW9uV2lkdGggPSB0aGlzLl9zY2FuUmVnaW9uLndpZHRoIHx8IHZpZGVvV2lkdGg7XG4gICAgICAgICAgICBjb25zdCByZWdpb25IZWlnaHQgPSB0aGlzLl9zY2FuUmVnaW9uLmhlaWdodCB8fCB2aWRlb0hlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvblggPSB0aGlzLl9zY2FuUmVnaW9uLnggfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvblkgPSB0aGlzLl9zY2FuUmVnaW9uLnkgfHwgMDtcblxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheVN0eWxlID0gdGhpcy4kb3ZlcmxheS5zdHlsZTtcbiAgICAgICAgICAgIG92ZXJsYXlTdHlsZS53aWR0aCA9IGAke3JlZ2lvbldpZHRoIC8gdmlkZW9XaWR0aCAqIHZpZGVvU2NhbGVkV2lkdGh9cHhgO1xuICAgICAgICAgICAgb3ZlcmxheVN0eWxlLmhlaWdodCA9IGAke3JlZ2lvbkhlaWdodCAvIHZpZGVvSGVpZ2h0ICogdmlkZW9TY2FsZWRIZWlnaHR9cHhgO1xuICAgICAgICAgICAgb3ZlcmxheVN0eWxlLnRvcCA9IGAke2VsZW1lbnRZICsgdmlkZW9ZICsgcmVnaW9uWSAvIHZpZGVvSGVpZ2h0ICogdmlkZW9TY2FsZWRIZWlnaHR9cHhgO1xuICAgICAgICAgICAgY29uc3QgaXNWaWRlb01pcnJvcmVkID0gL3NjYWxlWFxcKC0xXFwpLy50ZXN0KHZpZGVvLnN0eWxlLnRyYW5zZm9ybSEpO1xuICAgICAgICAgICAgb3ZlcmxheVN0eWxlLmxlZnQgPSBgJHtlbGVtZW50WFxuICAgICAgICAgICAgICAgICsgKGlzVmlkZW9NaXJyb3JlZCA/IGVsZW1lbnRXaWR0aCAtIHZpZGVvWCAtIHZpZGVvU2NhbGVkV2lkdGggOiB2aWRlb1gpXG4gICAgICAgICAgICAgICAgKyAoaXNWaWRlb01pcnJvcmVkID8gdmlkZW9XaWR0aCAtIHJlZ2lvblggLSByZWdpb25XaWR0aCA6IHJlZ2lvblgpIC8gdmlkZW9XaWR0aCAqIHZpZGVvU2NhbGVkV2lkdGh9cHhgO1xuICAgICAgICAgICAgLy8gYXBwbHkgc2FtZSBtaXJyb3IgYXMgb24gdmlkZW9cbiAgICAgICAgICAgIG92ZXJsYXlTdHlsZS50cmFuc2Zvcm0gPSB2aWRlby5zdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIF9jb252ZXJ0UG9pbnRzKFxuICAgICAgICBwb2ludHM6IFFyU2Nhbm5lci5Qb2ludFtdLFxuICAgICAgICBzY2FuUmVnaW9uPzogUXJTY2FubmVyLlNjYW5SZWdpb24gfCBudWxsLFxuICAgICk6IFFyU2Nhbm5lci5Qb2ludFtdIHtcbiAgICAgICAgaWYgKCFzY2FuUmVnaW9uKSByZXR1cm4gcG9pbnRzO1xuICAgICAgICBjb25zdCBvZmZzZXRYID0gc2NhblJlZ2lvbi54IHx8IDA7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBzY2FuUmVnaW9uLnkgfHwgMDtcbiAgICAgICAgY29uc3Qgc2NhbGVGYWN0b3JYID0gc2NhblJlZ2lvbi53aWR0aCAmJiBzY2FuUmVnaW9uLmRvd25TY2FsZWRXaWR0aFxuICAgICAgICAgICAgPyBzY2FuUmVnaW9uLndpZHRoIC8gc2NhblJlZ2lvbi5kb3duU2NhbGVkV2lkdGhcbiAgICAgICAgICAgIDogMTtcbiAgICAgICAgY29uc3Qgc2NhbGVGYWN0b3JZID0gc2NhblJlZ2lvbi5oZWlnaHQgJiYgc2NhblJlZ2lvbi5kb3duU2NhbGVkSGVpZ2h0XG4gICAgICAgICAgICA/IHNjYW5SZWdpb24uaGVpZ2h0IC8gc2NhblJlZ2lvbi5kb3duU2NhbGVkSGVpZ2h0XG4gICAgICAgICAgICA6IDE7XG4gICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICAgICAgICBwb2ludC54ID0gcG9pbnQueCAqIHNjYWxlRmFjdG9yWCArIG9mZnNldFg7XG4gICAgICAgICAgICBwb2ludC55ID0gcG9pbnQueSAqIHNjYWxlRmFjdG9yWSArIG9mZnNldFk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zY2FuRnJhbWUoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZlIHx8IHRoaXMuJHZpZGVvLnBhdXNlZCB8fCB0aGlzLiR2aWRlby5lbmRlZCkgcmV0dXJuO1xuICAgICAgICAvLyBJZiByZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrIGlzIGF2YWlsYWJsZSB1c2UgdGhhdCB0byBhdm9pZCB1bm5lY2Vzc2FyeSBzY2FucyBvbiB0aGUgc2FtZSBmcmFtZSBhcyB0aGVcbiAgICAgICAgLy8gY2FtZXJhJ3MgZnJhbWVyYXRlIGNhbiBiZSBsb3dlciB0aGFuIHRoZSBzY3JlZW4gcmVmcmVzaCByYXRlIGFuZCB0aGlzLl9tYXhTY2Fuc1BlclNlY29uZCwgZXNwZWNpYWxseSBpbiBkYXJrXG4gICAgICAgIC8vIHNldHRpbmdzIHdoZXJlIHRoZSBleHBvc3VyZSB0aW1lIGlzIGxvbmdlci4gQm90aCwgcmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayBhbmQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFyZSBub3RcbiAgICAgICAgLy8gYmVpbmcgZmlyZWQgaWYgdGhlIHRhYiBpcyBpbiB0aGUgYmFja2dyb3VuZCwgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LlxuICAgICAgICBjb25zdCByZXF1ZXN0RnJhbWUgPSAncmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaycgaW4gdGhpcy4kdmlkZW9cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgID8gdGhpcy4kdmlkZW8ucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjay5iaW5kKHRoaXMuJHZpZGVvKVxuICAgICAgICAgICAgOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgICAgIHJlcXVlc3RGcmFtZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdmlkZW8ucmVhZHlTdGF0ZSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBzY2FucyB1bnRpbCB0aGUgdmlkZW8gaXMgcmVhZHkgYXMgZHJhd0ltYWdlKCkgb25seSB3b3JrcyBjb3JyZWN0bHkgb24gYSB2aWRlbyB3aXRoIHJlYWR5U3RhdGVcbiAgICAgICAgICAgICAgICAvLyA+IDEsIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2RyYXdJbWFnZSNOb3Rlcy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFsc28gYXZvaWRzIGZhbHNlIHBvc2l0aXZlcyBmb3IgdmlkZW9zIHBhdXNlZCBhZnRlciBhIHN1Y2Nlc3NmdWwgc2NhbiB3aGljaCByZW1haW5zIHZpc2libGUgb25cbiAgICAgICAgICAgICAgICAvLyB0aGUgY2FudmFzIHVudGlsIHRoZSB2aWRlbyBpcyBzdGFydGVkIGFnYWluIGFuZCByZWFkeS5cbiAgICAgICAgICAgICAgICB0aGlzLl9zY2FuRnJhbWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RTY2FuID0gRGF0ZS5ub3coKSAtIHRoaXMuX2xhc3RTY2FuVGltZXN0YW1wO1xuICAgICAgICAgICAgY29uc3QgbWluaW11bVRpbWVCZXR3ZWVuU2NhbnMgPSAxMDAwIC8gdGhpcy5fbWF4U2NhbnNQZXJTZWNvbmQ7XG4gICAgICAgICAgICBpZiAodGltZVNpbmNlTGFzdFNjYW4gPCBtaW5pbXVtVGltZUJldHdlZW5TY2Fucykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1pbmltdW1UaW1lQmV0d2VlblNjYW5zIC0gdGltZVNpbmNlTGFzdFNjYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTY2FuIHJhdGU6JywgTWF0aC5yb3VuZCgxMDAwIC8gKERhdGUubm93KCkgLSB0aGlzLl9sYXN0U2NhblRpbWVzdGFtcCkpKTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RTY2FuVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgbGV0IHJlc3VsdDogUXJTY2FubmVyLlNjYW5SZXN1bHQgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IFFyU2Nhbm5lci5zY2FuSW1hZ2UodGhpcy4kdmlkZW8sIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhblJlZ2lvbjogdGhpcy5fc2NhblJlZ2lvbixcbiAgICAgICAgICAgICAgICAgICAgcXJFbmdpbmU6IHRoaXMuX3FyRW5naW5lUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzOiB0aGlzLiRjYW52YXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYWN0aXZlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5fb25EZWNvZGVFcnJvcihlcnJvciBhcyBFcnJvciB8IHN0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChRclNjYW5uZXIuX2Rpc2FibGVCYXJjb2RlRGV0ZWN0b3IgJiYgIShhd2FpdCB0aGlzLl9xckVuZ2luZVByb21pc2UgaW5zdGFuY2VvZiBXb3JrZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgZGlzYWJsZWQgQmFyY29kZURldGVjdG9yXG4gICAgICAgICAgICAgICAgdGhpcy5fcXJFbmdpbmVQcm9taXNlID0gUXJTY2FubmVyLmNyZWF0ZVFyRW5naW5lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25EZWNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25EZWNvZGUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xlZ2FjeU9uRGVjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlZ2FjeU9uRGVjb2RlKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kY29kZU91dGxpbmVIaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NvZGVPdXRsaW5lSGlnaGxpZ2h0UmVtb3ZhbFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2RlT3V0bGluZUhpZ2hsaWdodFJlbW92YWxUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAndmlld0JveCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLl9zY2FuUmVnaW9uLnggfHwgMH0gYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYCR7dGhpcy5fc2NhblJlZ2lvbi55IHx8IDB9IGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGAke3RoaXMuX3NjYW5SZWdpb24ud2lkdGggfHwgdGhpcy4kdmlkZW8udmlkZW9XaWR0aH0gYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYCR7dGhpcy5fc2NhblJlZ2lvbi5oZWlnaHQgfHwgdGhpcy4kdmlkZW8udmlkZW9IZWlnaHR9YCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seWdvbiA9IHRoaXMuJGNvZGVPdXRsaW5lSGlnaGxpZ2h0LmZpcnN0RWxlbWVudENoaWxkITtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5zZXRBdHRyaWJ1dGUoJ3BvaW50cycsIHJlc3VsdC5jb3JuZXJQb2ludHMubWFwKCh7eCwgeX0pID0+IGAke3h9LCR7eX1gKS5qb2luKCcgJykpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodCAmJiAhdGhpcy5fY29kZU91dGxpbmVIaWdobGlnaHRSZW1vdmFsVGltZW91dCkge1xuICAgICAgICAgICAgICAgIC8vIGhpZGUgYWZ0ZXIgdGltZW91dCB0byBtYWtlIGl0IGZsYXNoIGxlc3Mgd2hlbiBvbiBzb21lIGZyYW1lcyB0aGUgUVIgY29kZSBpcyBkZXRlY3RlZCBhbmQgb24gc29tZSBub3RcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2RlT3V0bGluZUhpZ2hsaWdodFJlbW92YWxUaW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4gdGhpcy4kY29kZU91dGxpbmVIaWdobGlnaHQhLnN0eWxlLmRpc3BsYXkgPSAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIDEwMCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zY2FuRnJhbWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfb25EZWNvZGVFcnJvcihlcnJvcjogRXJyb3IgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgLy8gZGVmYXVsdCBlcnJvciBoYW5kbGVyOyBjYW4gYmUgb3ZlcndyaXR0ZW4gaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgIGlmIChlcnJvciA9PT0gUXJTY2FubmVyLk5PX1FSX0NPREVfRk9VTkQpIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX2dldENhbWVyYVN0cmVhbSgpOiBQcm9taXNlPHsgc3RyZWFtOiBNZWRpYVN0cmVhbSwgZmFjaW5nTW9kZTogUXJTY2FubmVyLkZhY2luZ01vZGUgfT4ge1xuICAgICAgICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMpIHRocm93ICdDYW1lcmEgbm90IGZvdW5kLic7XG5cbiAgICAgICAgY29uc3QgcHJlZmVyZW5jZVR5cGUgPSAvXihlbnZpcm9ubWVudHx1c2VyKSQvLnRlc3QodGhpcy5fcHJlZmVycmVkQ2FtZXJhKVxuICAgICAgICAgICAgPyAnZmFjaW5nTW9kZSdcbiAgICAgICAgICAgIDogJ2RldmljZUlkJztcbiAgICAgICAgY29uc3QgY29uc3RyYWludHNXaXRob3V0Q2FtZXJhOiBBcnJheTxNZWRpYVRyYWNrQ29uc3RyYWludHM+ID0gW3tcbiAgICAgICAgICAgIHdpZHRoOiB7IG1pbjogMTAyNCB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHdpZHRoOiB7IG1pbjogNzY4IH1cbiAgICAgICAgfSwge31dO1xuICAgICAgICBjb25zdCBjb25zdHJhaW50c1dpdGhDYW1lcmEgPSBjb25zdHJhaW50c1dpdGhvdXRDYW1lcmEubWFwKChjb25zdHJhaW50KSA9PiBPYmplY3QuYXNzaWduKHt9LCBjb25zdHJhaW50LCB7XG4gICAgICAgICAgICBbcHJlZmVyZW5jZVR5cGVdOiB7IGV4YWN0OiB0aGlzLl9wcmVmZXJyZWRDYW1lcmEgfSxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZvciAoY29uc3QgY29uc3RyYWludHMgb2YgWy4uLmNvbnN0cmFpbnRzV2l0aENhbWVyYSwgLi4uY29uc3RyYWludHNXaXRob3V0Q2FtZXJhXSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IHZpZGVvOiBjb25zdHJhaW50cywgYXVkaW86IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlIGZyb20gdGhlIHN0cmVhbSwgb3RoZXJ3aXNlIHVzZSBhIGd1ZXNzIG9yICdlbnZpcm9ubWVudCcgYXNcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LiBOb3RlIHRoYXQgdGhlIGd1ZXNzIGlzIG5vdCBhbHdheXMgYWNjdXJhdGUgYXMgU2FmYXJpIHJldHVybnMgY2FtZXJhcyBvZiBkaWZmZXJlbnQgZmFjaW5nXG4gICAgICAgICAgICAgICAgLy8gbW9kZSwgZXZlbiBmb3IgZXhhY3QgZmFjaW5nTW9kZSBjb25zdHJhaW50cy5cbiAgICAgICAgICAgICAgICBjb25zdCBmYWNpbmdNb2RlID0gdGhpcy5fZ2V0RmFjaW5nTW9kZShzdHJlYW0pXG4gICAgICAgICAgICAgICAgICAgIHx8IChjb25zdHJhaW50cy5mYWNpbmdNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX3ByZWZlcnJlZENhbWVyYSBhcyBRclNjYW5uZXIuRmFjaW5nTW9kZSAvLyBhIGZhY2luZyBtb2RlIHdlIHdlcmUgYWJsZSB0byBmdWxmaWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICh0aGlzLl9wcmVmZXJyZWRDYW1lcmEgPT09ICdlbnZpcm9ubWVudCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICd1c2VyJyAvLyBzd2l0Y2ggYXMgX3ByZWZlcnJlZENhbWVyYSB3YXMgZW52aXJvbm1lbnQgYnV0IHdlIGFyZSBub3QgYWJsZSB0byBmdWxmaWxsIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZW52aXJvbm1lbnQnIC8vIHN3aXRjaCBmcm9tIHVuZnVsZmlsbGVkIHVzZXIgZmFjaW5nTW9kZSBvciBkZWZhdWx0IHRvIGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RyZWFtLCBmYWNpbmdNb2RlIH07XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgJ0NhbWVyYSBub3QgZm91bmQuJztcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9yZXN0YXJ0VmlkZW9TdHJlYW0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhbHdheXMgcGF1c2UgdGhlIHN0cmVhbSBhbmQgbm90IG9ubHkgaWYgIXRoaXMuX3BhdXNlZCBhcyBldmVuIGlmIHRoaXMuX3BhdXNlZCA9PT0gdHJ1ZSwgdGhlXG4gICAgICAgIC8vIHN0cmVhbSBtaWdodCBzdGlsbCBiZSBydW5uaW5nLCBhcyBpdCdzIGJ5IGRlZmF1bHQgb25seSBzdG9wcGVkIGFmdGVyIGEgZGVsYXkgb2YgMzAwbXMuXG4gICAgICAgIGNvbnN0IHdhc1BhdXNlZCA9IHRoaXMuX3BhdXNlZDtcbiAgICAgICAgY29uc3QgcGF1c2VkID0gYXdhaXQgdGhpcy5wYXVzZSh0cnVlKTtcbiAgICAgICAgaWYgKCFwYXVzZWQgfHwgd2FzUGF1c2VkIHx8ICF0aGlzLl9hY3RpdmUpIHJldHVybjtcbiAgICAgICAgYXdhaXQgdGhpcy5zdGFydCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIF9zdG9wVmlkZW9TdHJlYW0oc3RyZWFtIDogTWVkaWFTdHJlYW0pOiB2b2lkIHtcbiAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiBzdHJlYW0uZ2V0VHJhY2tzKCkpIHtcbiAgICAgICAgICAgIHRyYWNrLnN0b3AoKTsgLy8gIG5vdGUgdGhhdCB0aGlzIHdpbGwgYWxzbyBhdXRvbWF0aWNhbGx5IHR1cm4gdGhlIGZsYXNobGlnaHQgb2ZmXG4gICAgICAgICAgICBzdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2V0VmlkZW9NaXJyb3IoZmFjaW5nTW9kZTogUXJTY2FubmVyLkZhY2luZ01vZGUpOiB2b2lkIHtcbiAgICAgICAgLy8gaW4gdXNlciBmYWNpbmcgbW9kZSBtaXJyb3IgdGhlIHZpZGVvIHRvIG1ha2UgaXQgZWFzaWVyIGZvciB0aGUgdXNlciB0byBwb3NpdGlvbiB0aGUgUVIgY29kZVxuICAgICAgICBjb25zdCBzY2FsZUZhY3RvciA9IGZhY2luZ01vZGUgPT09ICd1c2VyJz8gLTEgOiAxO1xuICAgICAgICB0aGlzLiR2aWRlby5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGVYKCcgKyBzY2FsZUZhY3RvciArICcpJztcbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXRGYWNpbmdNb2RlKHZpZGVvU3RyZWFtOiBNZWRpYVN0cmVhbSk6IFFyU2Nhbm5lci5GYWNpbmdNb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB2aWRlb1N0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICBpZiAoIXZpZGVvVHJhY2spIHJldHVybiBudWxsOyAvLyB1bmtub3duXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9Kb2R1c05vZHVzL3JlYWN0LXFyLXJlYWRlci9ibG9iL21hc3Rlci9zcmMvZ2V0RGV2aWNlSWQuanMjTDEzXG4gICAgICAgIHJldHVybiAvcmVhcnxiYWNrfGVudmlyb25tZW50L2kudGVzdCh2aWRlb1RyYWNrLmxhYmVsKVxuICAgICAgICAgICAgPyAnZW52aXJvbm1lbnQnXG4gICAgICAgICAgICA6IC9mcm9udHx1c2VyfGZhY2UvaS50ZXN0KHZpZGVvVHJhY2subGFiZWwpXG4gICAgICAgICAgICAgICAgPyAndXNlcidcbiAgICAgICAgICAgICAgICA6IG51bGw7IC8vIHVua25vd25cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBfZHJhd1RvQ2FudmFzKFxuICAgICAgICBpbWFnZTogSFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcyB8IEltYWdlQml0bWFwXG4gICAgICAgICAgICB8IFNWR0ltYWdlRWxlbWVudCxcbiAgICAgICAgc2NhblJlZ2lvbj86IFFyU2Nhbm5lci5TY2FuUmVnaW9uIHwgbnVsbCxcbiAgICAgICAgY2FudmFzPzogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsLFxuICAgICAgICBkaXNhbGxvd0NhbnZhc1Jlc2l6aW5nPSBmYWxzZSxcbiAgICApOiBbSFRNTENhbnZhc0VsZW1lbnQsIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0ge1xuICAgICAgICBjYW52YXMgPSBjYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNvbnN0IHNjYW5SZWdpb25YID0gc2NhblJlZ2lvbiAmJiBzY2FuUmVnaW9uLnggPyBzY2FuUmVnaW9uLnggOiAwO1xuICAgICAgICBjb25zdCBzY2FuUmVnaW9uWSA9IHNjYW5SZWdpb24gJiYgc2NhblJlZ2lvbi55ID8gc2NhblJlZ2lvbi55IDogMDtcbiAgICAgICAgY29uc3Qgc2NhblJlZ2lvbldpZHRoID0gc2NhblJlZ2lvbiAmJiBzY2FuUmVnaW9uLndpZHRoXG4gICAgICAgICAgICA/IHNjYW5SZWdpb24ud2lkdGhcbiAgICAgICAgICAgIDogKGltYWdlIGFzIEhUTUxWaWRlb0VsZW1lbnQpLnZpZGVvV2lkdGggfHwgaW1hZ2Uud2lkdGggYXMgbnVtYmVyO1xuICAgICAgICBjb25zdCBzY2FuUmVnaW9uSGVpZ2h0ID0gc2NhblJlZ2lvbiAmJiBzY2FuUmVnaW9uLmhlaWdodFxuICAgICAgICAgICAgPyBzY2FuUmVnaW9uLmhlaWdodFxuICAgICAgICAgICAgOiAoaW1hZ2UgYXMgSFRNTFZpZGVvRWxlbWVudCkudmlkZW9IZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0IGFzIG51bWJlcjtcblxuICAgICAgICBpZiAoIWRpc2FsbG93Q2FudmFzUmVzaXppbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gc2NhblJlZ2lvbiAmJiBzY2FuUmVnaW9uLmRvd25TY2FsZWRXaWR0aFxuICAgICAgICAgICAgICAgID8gc2NhblJlZ2lvbi5kb3duU2NhbGVkV2lkdGhcbiAgICAgICAgICAgICAgICA6IHNjYW5SZWdpb25XaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IHNjYW5SZWdpb24gJiYgc2NhblJlZ2lvbi5kb3duU2NhbGVkSGVpZ2h0XG4gICAgICAgICAgICAgICAgPyBzY2FuUmVnaW9uLmRvd25TY2FsZWRIZWlnaHRcbiAgICAgICAgICAgICAgICA6IHNjYW5SZWdpb25IZWlnaHQ7XG4gICAgICAgICAgICAvLyBTZXR0aW5nIHRoZSBjYW52YXMgd2lkdGggb3IgaGVpZ2h0IGNsZWFycyB0aGUgY2FudmFzLCBldmVuIGlmIHRoZSB2YWx1ZXMgZGlkbid0IGNoYW5nZSwgdGhlcmVmb3JlIG9ubHlcbiAgICAgICAgICAgIC8vIHNldCB0aGVtIGlmIHRoZXkgYWN0dWFsbHkgY2hhbmdlZC5cbiAgICAgICAgICAgIGlmIChjYW52YXMud2lkdGggIT09IGNhbnZhc1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7IGFscGhhOiBmYWxzZSB9KSE7XG4gICAgICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7IC8vIGdpdmVzIGxlc3MgYmx1cnJ5IGltYWdlc1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgc2NhblJlZ2lvblgsIHNjYW5SZWdpb25ZLCBzY2FuUmVnaW9uV2lkdGgsIHNjYW5SZWdpb25IZWlnaHQsXG4gICAgICAgICAgICAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBbY2FudmFzLCBjb250ZXh0XTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhc3luYyBfbG9hZEltYWdlKFxuICAgICAgICBpbWFnZU9yRmlsZU9yQmxvYk9yVXJsOiBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzIHwgSW1hZ2VCaXRtYXBcbiAgICAgICAgICAgIHwgU1ZHSW1hZ2VFbGVtZW50IHwgRmlsZSB8IEJsb2IgfCBVUkwgfCBTdHJpbmcsXG4gICAgKTogUHJvbWlzZTxIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzIHwgSW1hZ2VCaXRtYXBcbiAgICAgICAgfCBTVkdJbWFnZUVsZW1lbnQgPiB7XG4gICAgICAgIGlmIChpbWFnZU9yRmlsZU9yQmxvYk9yVXJsIGluc3RhbmNlb2YgSW1hZ2UpIHtcbiAgICAgICAgICAgIGF3YWl0IFFyU2Nhbm5lci5fYXdhaXRJbWFnZUxvYWQoaW1hZ2VPckZpbGVPckJsb2JPclVybCk7XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VPckZpbGVPckJsb2JPclVybDtcbiAgICAgICAgfSBlbHNlIGlmIChpbWFnZU9yRmlsZU9yQmxvYk9yVXJsIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudFxuICAgICAgICAgICAgfHwgaW1hZ2VPckZpbGVPckJsb2JPclVybCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50XG4gICAgICAgICAgICB8fCBpbWFnZU9yRmlsZU9yQmxvYk9yVXJsIGluc3RhbmNlb2YgU1ZHSW1hZ2VFbGVtZW50XG4gICAgICAgICAgICB8fCAnT2Zmc2NyZWVuQ2FudmFzJyBpbiB3aW5kb3cgJiYgaW1hZ2VPckZpbGVPckJsb2JPclVybCBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhc1xuICAgICAgICAgICAgfHwgJ0ltYWdlQml0bWFwJyBpbiB3aW5kb3cgJiYgaW1hZ2VPckZpbGVPckJsb2JPclVybCBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VPckZpbGVPckJsb2JPclVybDtcbiAgICAgICAgfSBlbHNlIGlmIChpbWFnZU9yRmlsZU9yQmxvYk9yVXJsIGluc3RhbmNlb2YgRmlsZSB8fCBpbWFnZU9yRmlsZU9yQmxvYk9yVXJsIGluc3RhbmNlb2YgQmxvYlxuICAgICAgICAgICAgfHwgaW1hZ2VPckZpbGVPckJsb2JPclVybCBpbnN0YW5jZW9mIFVSTCB8fCB0eXBlb2YgaW1hZ2VPckZpbGVPckJsb2JPclVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpZiAoaW1hZ2VPckZpbGVPckJsb2JPclVybCBpbnN0YW5jZW9mIEZpbGUgfHwgaW1hZ2VPckZpbGVPckJsb2JPclVybCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGltYWdlT3JGaWxlT3JCbG9iT3JVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSBpbWFnZU9yRmlsZU9yQmxvYk9yVXJsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFFyU2Nhbm5lci5fYXdhaXRJbWFnZUxvYWQoaW1hZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbWFnZTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlT3JGaWxlT3JCbG9iT3JVcmwgaW5zdGFuY2VvZiBGaWxlIHx8IGltYWdlT3JGaWxlT3JCbG9iT3JVcmwgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaW1hZ2Uuc3JjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnVW5zdXBwb3J0ZWQgaW1hZ2UgdHlwZS4nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgX2F3YWl0SW1hZ2VMb2FkKGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmIChpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDApIHJldHVybjsgLy8gYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQ6IEVycm9yRXZlbnQgfCBFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRXJyb3JFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoJ0ltYWdlIGxvYWQgZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgX3Bvc3RXb3JrZXJNZXNzYWdlKFxuICAgICAgICBxckVuZ2luZU9yUXJFbmdpbmVQcm9taXNlOiBXb3JrZXIgfCBCYXJjb2RlRGV0ZWN0b3IgfCBQcm9taXNlPFdvcmtlciB8IEJhcmNvZGVEZXRlY3Rvcj4sXG4gICAgICAgIHR5cGU6IHN0cmluZyxcbiAgICAgICAgZGF0YT86IGFueSxcbiAgICAgICAgdHJhbnNmZXI/OiBUcmFuc2ZlcmFibGVbXSxcbiAgICApOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgICByZXR1cm4gUXJTY2FubmVyLl9wb3N0V29ya2VyTWVzc2FnZVN5bmMoYXdhaXQgcXJFbmdpbmVPclFyRW5naW5lUHJvbWlzZSwgdHlwZSwgZGF0YSwgdHJhbnNmZXIpO1xuICAgIH1cblxuICAgIC8vIHN5bmMgdmVyc2lvbiBvZiBfcG9zdFdvcmtlck1lc3NhZ2Ugd2l0aG91dCBwZXJmb3JtYW5jZSBvdmVyaGVhZCBvZiBhc3luYyBmdW5jdGlvbnNcbiAgICBwcml2YXRlIHN0YXRpYyBfcG9zdFdvcmtlck1lc3NhZ2VTeW5jKFxuICAgICAgICBxckVuZ2luZTogV29ya2VyIHwgQmFyY29kZURldGVjdG9yLFxuICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgIGRhdGE/OiBhbnksXG4gICAgICAgIHRyYW5zZmVyPzogVHJhbnNmZXJhYmxlW10sXG4gICAgKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCEocXJFbmdpbmUgaW5zdGFuY2VvZiBXb3JrZXIpKSByZXR1cm4gLTE7XG4gICAgICAgIGNvbnN0IGlkID0gUXJTY2FubmVyLl93b3JrZXJNZXNzYWdlSWQrKztcbiAgICAgICAgcXJFbmdpbmUucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSwgdHJhbnNmZXIpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxufVxuXG5kZWNsYXJlIG5hbWVzcGFjZSBRclNjYW5uZXIge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgU2NhblJlZ2lvbiB7XG4gICAgICAgIHg/OiBudW1iZXI7XG4gICAgICAgIHk/OiBudW1iZXI7XG4gICAgICAgIHdpZHRoPzogbnVtYmVyO1xuICAgICAgICBoZWlnaHQ/OiBudW1iZXI7XG4gICAgICAgIGRvd25TY2FsZWRXaWR0aD86IG51bWJlcjtcbiAgICAgICAgZG93blNjYWxlZEhlaWdodD86IG51bWJlcjtcbiAgICB9XG5cbiAgICBleHBvcnQgdHlwZSBGYWNpbmdNb2RlID0gJ2Vudmlyb25tZW50JyB8ICd1c2VyJztcbiAgICBleHBvcnQgdHlwZSBEZXZpY2VJZCA9IHN0cmluZztcblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ2FtZXJhIHtcbiAgICAgICAgaWQ6IERldmljZUlkO1xuICAgICAgICBsYWJlbDogc3RyaW5nO1xuICAgIH1cblxuICAgIGV4cG9ydCB0eXBlIEludmVyc2lvbk1vZGUgPSAnb3JpZ2luYWwnIHwgJ2ludmVydCcgfCAnYm90aCc7XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIFBvaW50IHtcbiAgICAgICAgeDogbnVtYmVyO1xuICAgICAgICB5OiBudW1iZXI7XG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBTY2FuUmVzdWx0IHtcbiAgICAgICAgZGF0YTogc3RyaW5nO1xuICAgICAgICAvLyBJbiBjbG9ja3dpc2Ugb3JkZXIsIHN0YXJ0aW5nIGF0IHRvcCBsZWZ0LCBidXQgdGhpcyBtaWdodCBub3QgYmUgZ3VhcmFudGVlZCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICBjb3JuZXJQb2ludHM6IFFyU2Nhbm5lci5Qb2ludFtdO1xuICAgIH1cbn1cblxuLy8gc2ltcGxpZmllZCBmcm9tIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vc2hhcGUtZGV0ZWN0aW9uLWFwaS8jYmFyY29kZS1kZXRlY3Rpb24tYXBpXG5kZWNsYXJlIGNsYXNzIEJhcmNvZGVEZXRlY3RvciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucz86IHsgZm9ybWF0czogc3RyaW5nW10gfSk7XG4gICAgc3RhdGljIGdldFN1cHBvcnRlZEZvcm1hdHMoKTogUHJvbWlzZTxzdHJpbmdbXT47XG4gICAgZGV0ZWN0KGltYWdlOiBJbWFnZUJpdG1hcFNvdXJjZSk6IFByb21pc2U8QXJyYXk8eyByYXdWYWx1ZTogc3RyaW5nLCBjb3JuZXJQb2ludHM6IFFyU2Nhbm5lci5Qb2ludFtdIH0+Pjtcbn1cblxuLy8gc2ltcGxpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sdWtld2FybG93L3VzZXItYWdlbnQtZGF0YS10eXBlcy9ibG9iL21hc3Rlci9pbmRleC5kLnRzXG5kZWNsYXJlIGdsb2JhbCB7XG4gICAgaW50ZXJmYWNlIE5hdmlnYXRvciB7XG4gICAgICAgIHJlYWRvbmx5IHVzZXJBZ2VudERhdGE/OiB7XG4gICAgICAgICAgICByZWFkb25seSBwbGF0Zm9ybTogc3RyaW5nO1xuICAgICAgICAgICAgcmVhZG9ubHkgYnJhbmRzOiBBcnJheTx7XG4gICAgICAgICAgICAgICAgcmVhZG9ubHkgYnJhbmQ6IHN0cmluZztcbiAgICAgICAgICAgICAgICByZWFkb25seSB2ZXJzaW9uOiBzdHJpbmc7XG4gICAgICAgICAgICB9PjtcbiAgICAgICAgICAgIGdldEhpZ2hFbnRyb3B5VmFsdWVzKGhpbnRzOiBzdHJpbmdbXSk6IFByb21pc2U8e1xuICAgICAgICAgICAgICAgIHJlYWRvbmx5IGFyY2hpdGVjdHVyZT86IHN0cmluZztcbiAgICAgICAgICAgICAgICByZWFkb25seSBwbGF0Zm9ybVZlcnNpb24/OiBzdHJpbmc7XG4gICAgICAgICAgICB9PjtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFFyU2Nhbm5lcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/qr-scanner/qr-scanner.min.js\n");

/***/ })

};
