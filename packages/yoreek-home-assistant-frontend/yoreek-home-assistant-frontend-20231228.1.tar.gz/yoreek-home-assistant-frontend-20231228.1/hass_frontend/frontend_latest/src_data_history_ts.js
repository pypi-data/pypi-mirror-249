/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
export const id = "src_data_history_ts";
export const ids = ["src_data_history_ts"];
export const modules = {

/***/ "./src/data/history.ts":
/*!*****************************!*\
  !*** ./src/data/history.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeGroupKey: () => (/* binding */ computeGroupKey),\n/* harmony export */   computeHistory: () => (/* binding */ computeHistory),\n/* harmony export */   entityIdHistoryNeedsAttributes: () => (/* binding */ entityIdHistoryNeedsAttributes),\n/* harmony export */   fetchDateWS: () => (/* binding */ fetchDateWS),\n/* harmony export */   subscribeHistory: () => (/* binding */ subscribeHistory),\n/* harmony export */   subscribeHistoryStatesTimeWindow: () => (/* binding */ subscribeHistoryStatesTimeWindow)\n/* harmony export */ });\n/* harmony import */ var _common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/entity/compute_domain */ \"./src/common/entity/compute_domain.ts\");\n/* harmony import */ var _common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/entity/compute_state_display */ \"./src/common/entity/compute_state_display.ts\");\n/* harmony import */ var _common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/entity/compute_state_name */ \"./src/common/entity/compute_state_name.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__]);\n_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nconst DOMAINS_USE_LAST_UPDATED = [\"climate\", \"humidifier\", \"water_heater\"];\nconst NEED_ATTRIBUTE_DOMAINS = [\"climate\", \"humidifier\", \"input_datetime\", \"thermostat\", \"water_heater\", \"person\", \"device_tracker\"];\nconst LINE_ATTRIBUTES_TO_KEEP = [\"temperature\", \"current_temperature\", \"target_temp_low\", \"target_temp_high\", \"hvac_action\", \"humidity\", \"mode\", \"action\", \"current_humidity\"];\nconst entityIdHistoryNeedsAttributes = (hass, entityId) => !hass.states[entityId] || NEED_ATTRIBUTE_DOMAINS.includes((0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__.computeDomain)(entityId));\nconst fetchDateWS = (hass, startTime, endTime, entityIds) => {\n  const params = {\n    type: \"history/history_during_period\",\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some(entityId => entityIdHistoryNeedsAttributes(hass, entityId))\n  };\n  if (entityIds.length !== 0) {\n    return hass.callWS({\n      ...params,\n      entity_ids: entityIds\n    });\n  }\n  return hass.callWS(params);\n};\nconst subscribeHistory = (hass, callbackFunction, startTime, endTime, entityIds) => {\n  const params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some(entityId => entityIdHistoryNeedsAttributes(hass, entityId))\n  };\n  const stream = new HistoryStream(hass);\n  return hass.connection.subscribeMessage(message => callbackFunction(stream.processMessage(message)), params);\n};\nclass HistoryStream {\n  constructor(hass, hoursToShow) {\n    this.hass = void 0;\n    this.hoursToShow = void 0;\n    this.combinedHistory = void 0;\n    this.hass = hass;\n    this.hoursToShow = hoursToShow;\n    this.combinedHistory = {};\n  }\n  processMessage(streamMessage) {\n    if (!this.combinedHistory || !Object.keys(this.combinedHistory).length) {\n      this.combinedHistory = streamMessage.states;\n      return this.combinedHistory;\n    }\n    if (!Object.keys(streamMessage.states).length) {\n      // Empty messages are still sent to\n      // indicate no more historical events\n      return this.combinedHistory;\n    }\n    const purgeBeforePythonTime = this.hoursToShow ? (new Date().getTime() - 60 * 60 * this.hoursToShow * 1000) / 1000 : undefined;\n    const newHistory = {};\n    for (const entityId of Object.keys(this.combinedHistory)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(streamMessage.states)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(newHistory)) {\n      if (entityId in this.combinedHistory && entityId in streamMessage.states) {\n        const entityCombinedHistory = this.combinedHistory[entityId];\n        const lastEntityCombinedHistory = entityCombinedHistory[entityCombinedHistory.length - 1];\n        newHistory[entityId] = entityCombinedHistory.concat(streamMessage.states[entityId]);\n        if (streamMessage.states[entityId][0].lu < lastEntityCombinedHistory.lu) {\n          // If the history is out of order we have to sort it.\n          newHistory[entityId] = newHistory[entityId].sort((a, b) => a.lu - b.lu);\n        }\n      } else if (entityId in this.combinedHistory) {\n        newHistory[entityId] = this.combinedHistory[entityId];\n      } else {\n        newHistory[entityId] = streamMessage.states[entityId];\n      }\n      // Remove old history\n      if (purgeBeforePythonTime && entityId in this.combinedHistory) {\n        const expiredStates = newHistory[entityId].filter(state => state.lu < purgeBeforePythonTime);\n        if (!expiredStates.length) {\n          continue;\n        }\n        newHistory[entityId] = newHistory[entityId].filter(state => state.lu >= purgeBeforePythonTime);\n        if (newHistory[entityId].length && newHistory[entityId][0].lu === purgeBeforePythonTime) {\n          continue;\n        }\n        // Update the first entry to the start time state\n        // as we need to preserve the start time state and\n        // only expire the rest of the history as it ages.\n        const lastExpiredState = expiredStates[expiredStates.length - 1];\n        lastExpiredState.lu = purgeBeforePythonTime;\n        newHistory[entityId].unshift(lastExpiredState);\n      }\n    }\n    this.combinedHistory = newHistory;\n    return this.combinedHistory;\n  }\n}\nconst subscribeHistoryStatesTimeWindow = (hass, callbackFunction, hoursToShow, entityIds, minimalResponse = true, significantChangesOnly = true, noAttributes) => {\n  const params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: new Date(new Date().getTime() - 60 * 60 * hoursToShow * 1000).toISOString(),\n    minimal_response: minimalResponse,\n    significant_changes_only: significantChangesOnly,\n    no_attributes: noAttributes !== null && noAttributes !== void 0 ? noAttributes : !entityIds.some(entityId => entityIdHistoryNeedsAttributes(hass, entityId))\n  };\n  const stream = new HistoryStream(hass, hoursToShow);\n  return hass.connection.subscribeMessage(message => callbackFunction(stream.processMessage(message)), params);\n};\nconst equalState = (obj1, obj2) => obj1.state === obj2.state && (\n// Only compare attributes if both states have an attributes object.\n// When `minimal_response` is sent, only the first and last state\n// will have attributes except for domains in DOMAINS_USE_LAST_UPDATED.\n!obj1.attributes || !obj2.attributes || LINE_ATTRIBUTES_TO_KEEP.every(attr => obj1.attributes[attr] === obj2.attributes[attr]));\nconst processTimelineEntity = (localize, locale, config, entities, entityId, states, current_state) => {\n  const data = [];\n  const first = states[0];\n  for (const state of states) {\n    if (data.length > 0 && state.s === data[data.length - 1].state) {\n      continue;\n    }\n    const currentAttributes = {};\n    if (current_state !== null && current_state !== void 0 && current_state.attributes.device_class) {\n      currentAttributes.device_class = current_state === null || current_state === void 0 ? void 0 : current_state.attributes.device_class;\n    }\n    data.push({\n      state_localize: (0,_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__.computeStateDisplayFromEntityAttributes)(localize, locale, config, entities[entityId], entityId, {\n        ...(state.a || first.a),\n        ...currentAttributes\n      }, state.s),\n      state: state.s,\n      // lc (last_changed) may be omitted if its the same\n      // as lu (last_updated).\n      last_changed: (state.lc ? state.lc : state.lu) * 1000\n    });\n  }\n  return {\n    name: (0,_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__.computeStateNameFromEntityAttributes)(entityId, (current_state === null || current_state === void 0 ? void 0 : current_state.attributes) || first.a),\n    entity_id: entityId,\n    data\n  };\n};\nconst processLineChartEntities = (unit, device_class, entities, hassEntities) => {\n  const data = [];\n  Object.keys(entities).forEach(entityId => {\n    const states = entities[entityId];\n    const first = states[0];\n    const domain = (0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__.computeDomain)(entityId);\n    const processedStates = [];\n    for (const state of states) {\n      let processedState;\n      if (DOMAINS_USE_LAST_UPDATED.includes(domain)) {\n        processedState = {\n          state: state.s,\n          last_changed: state.lu * 1000,\n          attributes: {}\n        };\n        for (const attr of LINE_ATTRIBUTES_TO_KEEP) {\n          if (attr in state.a) {\n            processedState.attributes[attr] = state.a[attr];\n          }\n        }\n      } else {\n        processedState = {\n          state: state.s,\n          // lc (last_changed) may be omitted if its the same\n          // as lu (last_updated).\n          last_changed: (state.lc ? state.lc : state.lu) * 1000,\n          attributes: {}\n        };\n      }\n      if (processedStates.length > 1 && equalState(processedState, processedStates[processedStates.length - 1]) && equalState(processedState, processedStates[processedStates.length - 2])) {\n        continue;\n      }\n      processedStates.push(processedState);\n    }\n    const attributes = entityId in hassEntities ? hassEntities[entityId].attributes : \"friendly_name\" in first.a ? first.a : undefined;\n    data.push({\n      domain,\n      name: (0,_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__.computeStateNameFromEntityAttributes)(entityId, attributes || {}),\n      entity_id: entityId,\n      states: processedStates\n    });\n  });\n  return {\n    unit,\n    device_class,\n    identifier: Object.keys(entities).join(\"\"),\n    data\n  };\n};\nconst NUMERICAL_DOMAINS = [\"counter\", \"input_number\", \"number\"];\nconst isNumericFromDomain = domain => NUMERICAL_DOMAINS.includes(domain);\nconst isNumericFromAttributes = attributes => \"unit_of_measurement\" in attributes || \"state_class\" in attributes;\nconst isNumericSensorEntity = (stateObj, sensorNumericalDeviceClasses) => stateObj.attributes.device_class != null && sensorNumericalDeviceClasses.includes(stateObj.attributes.device_class);\nconst BLANK_UNIT = \" \";\nconst computeHistory = (hass, stateHistory, localize, sensorNumericalDeviceClasses, splitDeviceClasses = false) => {\n  const lineChartDevices = {};\n  const timelineDevices = [];\n  if (!stateHistory) {\n    return {\n      line: [],\n      timeline: []\n    };\n  }\n  Object.keys(stateHistory).forEach(entityId => {\n    var _ref;\n    const stateInfo = stateHistory[entityId];\n    if (stateInfo.length === 0) {\n      return;\n    }\n    const domain = (0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__.computeDomain)(entityId);\n    const currentState = entityId in hass.states ? hass.states[entityId] : undefined;\n    const numericStateFromHistory = currentState || isNumericFromDomain(domain) ? undefined : stateInfo.find(state => state.a && isNumericFromAttributes(state.a));\n    let unit;\n    const isNumeric = isNumericFromDomain(domain) || currentState != null && isNumericFromAttributes(currentState.attributes) || currentState != null && domain === \"sensor\" && isNumericSensorEntity(currentState, sensorNumericalDeviceClasses) || numericStateFromHistory != null;\n    if (isNumeric) {\n      unit = (currentState === null || currentState === void 0 ? void 0 : currentState.attributes.unit_of_measurement) || (numericStateFromHistory === null || numericStateFromHistory === void 0 ? void 0 : numericStateFromHistory.a.unit_of_measurement) || BLANK_UNIT;\n    } else {\n      unit = {\n        zone: localize(\"ui.dialogs.more_info_control.zone.graph_unit\"),\n        climate: hass.config.unit_system.temperature,\n        humidifier: \"%\",\n        water_heater: hass.config.unit_system.temperature\n      }[domain];\n    }\n    const deviceClass = (_ref = (currentState === null || currentState === void 0 ? void 0 : currentState.attributes) || (numericStateFromHistory === null || numericStateFromHistory === void 0 ? void 0 : numericStateFromHistory.a)) === null || _ref === void 0 ? void 0 : _ref.device_class;\n    const key = computeGroupKey(unit, deviceClass, splitDeviceClasses);\n    if (!unit) {\n      timelineDevices.push(processTimelineEntity(localize, hass.locale, hass.config, hass.entities, entityId, stateInfo, currentState));\n    } else if (key && key in lineChartDevices && entityId in lineChartDevices[key]) {\n      lineChartDevices[key][entityId].push(...stateInfo);\n    } else if (key) {\n      if (!(key in lineChartDevices)) {\n        lineChartDevices[key] = {};\n      }\n      lineChartDevices[key][entityId] = stateInfo;\n    }\n  });\n  const unitStates = Object.keys(lineChartDevices).map(key => {\n    const splitKey = key.split(\"_\");\n    const unit = splitKey[0];\n    const deviceClass = splitKey[1] || undefined;\n    return processLineChartEntities(unit, deviceClass, lineChartDevices[key], hass.states);\n  });\n  return {\n    line: unitStates,\n    timeline: timelineDevices\n  };\n};\nconst computeGroupKey = (unit, device_class, splitDeviceClasses) => splitDeviceClasses ? `${unit}_${device_class || \"\"}` : unit;\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGF0YS9oaXN0b3J5LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFTQTtBQXVFQTtBQU9BO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFPQTtBQUFBO0FBTkE7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUdBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFHQTtBQU9BO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBT0E7QUFFQTtBQVNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFXQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL3NyYy9kYXRhL2hpc3RvcnkudHM/MzUwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBIYXNzQ29uZmlnLFxuICBIYXNzRW50aXRpZXMsXG4gIEhhc3NFbnRpdHksXG4gIEhhc3NFbnRpdHlBdHRyaWJ1dGVCYXNlLFxufSBmcm9tIFwiaG9tZS1hc3Npc3RhbnQtanMtd2Vic29ja2V0XCI7XG5pbXBvcnQgeyBjb21wdXRlRG9tYWluIH0gZnJvbSBcIi4uL2NvbW1vbi9lbnRpdHkvY29tcHV0ZV9kb21haW5cIjtcbmltcG9ydCB7IGNvbXB1dGVTdGF0ZURpc3BsYXlGcm9tRW50aXR5QXR0cmlidXRlcyB9IGZyb20gXCIuLi9jb21tb24vZW50aXR5L2NvbXB1dGVfc3RhdGVfZGlzcGxheVwiO1xuaW1wb3J0IHsgY29tcHV0ZVN0YXRlTmFtZUZyb21FbnRpdHlBdHRyaWJ1dGVzIH0gZnJvbSBcIi4uL2NvbW1vbi9lbnRpdHkvY29tcHV0ZV9zdGF0ZV9uYW1lXCI7XG5pbXBvcnQgeyBMb2NhbGl6ZUZ1bmMgfSBmcm9tIFwiLi4vY29tbW9uL3RyYW5zbGF0aW9ucy9sb2NhbGl6ZVwiO1xuaW1wb3J0IHsgSG9tZUFzc2lzdGFudCB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgRnJvbnRlbmRMb2NhbGVEYXRhIH0gZnJvbSBcIi4vdHJhbnNsYXRpb25cIjtcblxuY29uc3QgRE9NQUlOU19VU0VfTEFTVF9VUERBVEVEID0gW1wiY2xpbWF0ZVwiLCBcImh1bWlkaWZpZXJcIiwgXCJ3YXRlcl9oZWF0ZXJcIl07XG5jb25zdCBORUVEX0FUVFJJQlVURV9ET01BSU5TID0gW1xuICBcImNsaW1hdGVcIixcbiAgXCJodW1pZGlmaWVyXCIsXG4gIFwiaW5wdXRfZGF0ZXRpbWVcIixcbiAgXCJ0aGVybW9zdGF0XCIsXG4gIFwid2F0ZXJfaGVhdGVyXCIsXG4gIFwicGVyc29uXCIsXG4gIFwiZGV2aWNlX3RyYWNrZXJcIixcbl07XG5jb25zdCBMSU5FX0FUVFJJQlVURVNfVE9fS0VFUCA9IFtcbiAgXCJ0ZW1wZXJhdHVyZVwiLFxuICBcImN1cnJlbnRfdGVtcGVyYXR1cmVcIixcbiAgXCJ0YXJnZXRfdGVtcF9sb3dcIixcbiAgXCJ0YXJnZXRfdGVtcF9oaWdoXCIsXG4gIFwiaHZhY19hY3Rpb25cIixcbiAgXCJodW1pZGl0eVwiLFxuICBcIm1vZGVcIixcbiAgXCJhY3Rpb25cIixcbiAgXCJjdXJyZW50X2h1bWlkaXR5XCIsXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbmVDaGFydFN0YXRlIHtcbiAgc3RhdGU6IHN0cmluZztcbiAgbGFzdF9jaGFuZ2VkOiBudW1iZXI7XG4gIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmVDaGFydEVudGl0eSB7XG4gIGRvbWFpbjogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVudGl0eV9pZDogc3RyaW5nO1xuICBzdGF0ZXM6IExpbmVDaGFydFN0YXRlW107XG4gIHN0YXRpc3RpY3M/OiBMaW5lQ2hhcnRTdGF0ZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmVDaGFydFVuaXQge1xuICB1bml0OiBzdHJpbmc7XG4gIGRldmljZV9jbGFzcz86IHN0cmluZztcbiAgaWRlbnRpZmllcjogc3RyaW5nO1xuICBkYXRhOiBMaW5lQ2hhcnRFbnRpdHlbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaW1lbGluZVN0YXRlIHtcbiAgc3RhdGVfbG9jYWxpemU6IHN0cmluZztcbiAgc3RhdGU6IHN0cmluZztcbiAgbGFzdF9jaGFuZ2VkOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZWxpbmVFbnRpdHkge1xuICBuYW1lOiBzdHJpbmc7XG4gIGVudGl0eV9pZDogc3RyaW5nO1xuICBkYXRhOiBUaW1lbGluZVN0YXRlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVJlc3VsdCB7XG4gIGxpbmU6IExpbmVDaGFydFVuaXRbXTtcbiAgdGltZWxpbmU6IFRpbWVsaW5lRW50aXR5W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVN0YXRlcyB7XG4gIFtlbnRpdHlJZDogc3RyaW5nXTogRW50aXR5SGlzdG9yeVN0YXRlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW50aXR5SGlzdG9yeVN0YXRlIHtcbiAgLyoqIHN0YXRlICovXG4gIHM6IHN0cmluZztcbiAgLyoqIGF0dHJpYnV0ZXMgKi9cbiAgYTogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgLyoqIGxhc3RfY2hhbmdlZDsgaWYgc2V0LCBhbHNvIGFwcGxpZXMgdG8gbHUgKi9cbiAgbGM6IG51bWJlcjtcbiAgLyoqIGxhc3RfdXBkYXRlZCAqL1xuICBsdTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlTdHJlYW1NZXNzYWdlIHtcbiAgc3RhdGVzOiBIaXN0b3J5U3RhdGVzO1xuICBzdGFydF90aW1lPzogbnVtYmVyOyAvLyBTdGFydCB0aW1lIG9mIHRoaXMgaGlzdG9yaWNhbCBjaHVua1xuICBlbmRfdGltZT86IG51bWJlcjsgLy8gRW5kIHRpbWUgb2YgdGhpcyBoaXN0b3JpY2FsIGNodW5rXG59XG5cbmV4cG9ydCBjb25zdCBlbnRpdHlJZEhpc3RvcnlOZWVkc0F0dHJpYnV0ZXMgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIGVudGl0eUlkOiBzdHJpbmdcbikgPT5cbiAgIWhhc3Muc3RhdGVzW2VudGl0eUlkXSB8fFxuICBORUVEX0FUVFJJQlVURV9ET01BSU5TLmluY2x1ZGVzKGNvbXB1dGVEb21haW4oZW50aXR5SWQpKTtcblxuZXhwb3J0IGNvbnN0IGZldGNoRGF0ZVdTID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBzdGFydFRpbWU6IERhdGUsXG4gIGVuZFRpbWU6IERhdGUsXG4gIGVudGl0eUlkczogc3RyaW5nW11cbikgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgdHlwZTogXCJoaXN0b3J5L2hpc3RvcnlfZHVyaW5nX3BlcmlvZFwiLFxuICAgIHN0YXJ0X3RpbWU6IHN0YXJ0VGltZS50b0lTT1N0cmluZygpLFxuICAgIGVuZF90aW1lOiBlbmRUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgbWluaW1hbF9yZXNwb25zZTogdHJ1ZSxcbiAgICBub19hdHRyaWJ1dGVzOiAhZW50aXR5SWRzLnNvbWUoKGVudGl0eUlkKSA9PlxuICAgICAgZW50aXR5SWRIaXN0b3J5TmVlZHNBdHRyaWJ1dGVzKGhhc3MsIGVudGl0eUlkKVxuICAgICksXG4gIH07XG4gIGlmIChlbnRpdHlJZHMubGVuZ3RoICE9PSAwKSB7XG4gICAgcmV0dXJuIGhhc3MuY2FsbFdTPEhpc3RvcnlTdGF0ZXM+KHsgLi4ucGFyYW1zLCBlbnRpdHlfaWRzOiBlbnRpdHlJZHMgfSk7XG4gIH1cbiAgcmV0dXJuIGhhc3MuY2FsbFdTPEhpc3RvcnlTdGF0ZXM+KHBhcmFtcyk7XG59O1xuXG5leHBvcnQgY29uc3Qgc3Vic2NyaWJlSGlzdG9yeSA9IChcbiAgaGFzczogSG9tZUFzc2lzdGFudCxcbiAgY2FsbGJhY2tGdW5jdGlvbjogKGRhdGE6IEhpc3RvcnlTdGF0ZXMpID0+IHZvaWQsXG4gIHN0YXJ0VGltZTogRGF0ZSxcbiAgZW5kVGltZTogRGF0ZSxcbiAgZW50aXR5SWRzOiBzdHJpbmdbXVxuKTogUHJvbWlzZTwoKSA9PiBQcm9taXNlPHZvaWQ+PiA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICB0eXBlOiBcImhpc3Rvcnkvc3RyZWFtXCIsXG4gICAgZW50aXR5X2lkczogZW50aXR5SWRzLFxuICAgIHN0YXJ0X3RpbWU6IHN0YXJ0VGltZS50b0lTT1N0cmluZygpLFxuICAgIGVuZF90aW1lOiBlbmRUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgbWluaW1hbF9yZXNwb25zZTogdHJ1ZSxcbiAgICBub19hdHRyaWJ1dGVzOiAhZW50aXR5SWRzLnNvbWUoKGVudGl0eUlkKSA9PlxuICAgICAgZW50aXR5SWRIaXN0b3J5TmVlZHNBdHRyaWJ1dGVzKGhhc3MsIGVudGl0eUlkKVxuICAgICksXG4gIH07XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBIaXN0b3J5U3RyZWFtKGhhc3MpO1xuICByZXR1cm4gaGFzcy5jb25uZWN0aW9uLnN1YnNjcmliZU1lc3NhZ2U8SGlzdG9yeVN0cmVhbU1lc3NhZ2U+KFxuICAgIChtZXNzYWdlKSA9PiBjYWxsYmFja0Z1bmN0aW9uKHN0cmVhbS5wcm9jZXNzTWVzc2FnZShtZXNzYWdlKSksXG4gICAgcGFyYW1zXG4gICk7XG59O1xuXG5jbGFzcyBIaXN0b3J5U3RyZWFtIHtcbiAgaGFzczogSG9tZUFzc2lzdGFudDtcblxuICBob3Vyc1RvU2hvdz86IG51bWJlcjtcblxuICBjb21iaW5lZEhpc3Rvcnk6IEhpc3RvcnlTdGF0ZXM7XG5cbiAgY29uc3RydWN0b3IoaGFzczogSG9tZUFzc2lzdGFudCwgaG91cnNUb1Nob3c/OiBudW1iZXIpIHtcbiAgICB0aGlzLmhhc3MgPSBoYXNzO1xuICAgIHRoaXMuaG91cnNUb1Nob3cgPSBob3Vyc1RvU2hvdztcbiAgICB0aGlzLmNvbWJpbmVkSGlzdG9yeSA9IHt9O1xuICB9XG5cbiAgcHJvY2Vzc01lc3NhZ2Uoc3RyZWFtTWVzc2FnZTogSGlzdG9yeVN0cmVhbU1lc3NhZ2UpOiBIaXN0b3J5U3RhdGVzIHtcbiAgICBpZiAoIXRoaXMuY29tYmluZWRIaXN0b3J5IHx8ICFPYmplY3Qua2V5cyh0aGlzLmNvbWJpbmVkSGlzdG9yeSkubGVuZ3RoKSB7XG4gICAgICB0aGlzLmNvbWJpbmVkSGlzdG9yeSA9IHN0cmVhbU1lc3NhZ2Uuc3RhdGVzO1xuICAgICAgcmV0dXJuIHRoaXMuY29tYmluZWRIaXN0b3J5O1xuICAgIH1cbiAgICBpZiAoIU9iamVjdC5rZXlzKHN0cmVhbU1lc3NhZ2Uuc3RhdGVzKS5sZW5ndGgpIHtcbiAgICAgIC8vIEVtcHR5IG1lc3NhZ2VzIGFyZSBzdGlsbCBzZW50IHRvXG4gICAgICAvLyBpbmRpY2F0ZSBubyBtb3JlIGhpc3RvcmljYWwgZXZlbnRzXG4gICAgICByZXR1cm4gdGhpcy5jb21iaW5lZEhpc3Rvcnk7XG4gICAgfVxuICAgIGNvbnN0IHB1cmdlQmVmb3JlUHl0aG9uVGltZSA9IHRoaXMuaG91cnNUb1Nob3dcbiAgICAgID8gKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gNjAgKiA2MCAqIHRoaXMuaG91cnNUb1Nob3cgKiAxMDAwKSAvIDEwMDBcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5ld0hpc3Rvcnk6IEhpc3RvcnlTdGF0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIE9iamVjdC5rZXlzKHRoaXMuY29tYmluZWRIaXN0b3J5KSkge1xuICAgICAgbmV3SGlzdG9yeVtlbnRpdHlJZF0gPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbnRpdHlJZCBvZiBPYmplY3Qua2V5cyhzdHJlYW1NZXNzYWdlLnN0YXRlcykpIHtcbiAgICAgIG5ld0hpc3RvcnlbZW50aXR5SWRdID0gW107XG4gICAgfVxuICAgIGZvciAoY29uc3QgZW50aXR5SWQgb2YgT2JqZWN0LmtleXMobmV3SGlzdG9yeSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgZW50aXR5SWQgaW4gdGhpcy5jb21iaW5lZEhpc3RvcnkgJiZcbiAgICAgICAgZW50aXR5SWQgaW4gc3RyZWFtTWVzc2FnZS5zdGF0ZXNcbiAgICAgICkge1xuICAgICAgICBjb25zdCBlbnRpdHlDb21iaW5lZEhpc3RvcnkgPSB0aGlzLmNvbWJpbmVkSGlzdG9yeVtlbnRpdHlJZF07XG4gICAgICAgIGNvbnN0IGxhc3RFbnRpdHlDb21iaW5lZEhpc3RvcnkgPVxuICAgICAgICAgIGVudGl0eUNvbWJpbmVkSGlzdG9yeVtlbnRpdHlDb21iaW5lZEhpc3RvcnkubGVuZ3RoIC0gMV07XG4gICAgICAgIG5ld0hpc3RvcnlbZW50aXR5SWRdID0gZW50aXR5Q29tYmluZWRIaXN0b3J5LmNvbmNhdChcbiAgICAgICAgICBzdHJlYW1NZXNzYWdlLnN0YXRlc1tlbnRpdHlJZF1cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0cmVhbU1lc3NhZ2Uuc3RhdGVzW2VudGl0eUlkXVswXS5sdSA8IGxhc3RFbnRpdHlDb21iaW5lZEhpc3RvcnkubHVcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGhpc3RvcnkgaXMgb3V0IG9mIG9yZGVyIHdlIGhhdmUgdG8gc29ydCBpdC5cbiAgICAgICAgICBuZXdIaXN0b3J5W2VudGl0eUlkXSA9IG5ld0hpc3RvcnlbZW50aXR5SWRdLnNvcnQoXG4gICAgICAgICAgICAoYSwgYikgPT4gYS5sdSAtIGIubHVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVudGl0eUlkIGluIHRoaXMuY29tYmluZWRIaXN0b3J5KSB7XG4gICAgICAgIG5ld0hpc3RvcnlbZW50aXR5SWRdID0gdGhpcy5jb21iaW5lZEhpc3RvcnlbZW50aXR5SWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3SGlzdG9yeVtlbnRpdHlJZF0gPSBzdHJlYW1NZXNzYWdlLnN0YXRlc1tlbnRpdHlJZF07XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgb2xkIGhpc3RvcnlcbiAgICAgIGlmIChwdXJnZUJlZm9yZVB5dGhvblRpbWUgJiYgZW50aXR5SWQgaW4gdGhpcy5jb21iaW5lZEhpc3RvcnkpIHtcbiAgICAgICAgY29uc3QgZXhwaXJlZFN0YXRlcyA9IG5ld0hpc3RvcnlbZW50aXR5SWRdLmZpbHRlcihcbiAgICAgICAgICAoc3RhdGUpID0+IHN0YXRlLmx1IDwgcHVyZ2VCZWZvcmVQeXRob25UaW1lXG4gICAgICAgICk7XG4gICAgICAgIGlmICghZXhwaXJlZFN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXdIaXN0b3J5W2VudGl0eUlkXSA9IG5ld0hpc3RvcnlbZW50aXR5SWRdLmZpbHRlcihcbiAgICAgICAgICAoc3RhdGUpID0+IHN0YXRlLmx1ID49IHB1cmdlQmVmb3JlUHl0aG9uVGltZVxuICAgICAgICApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbmV3SGlzdG9yeVtlbnRpdHlJZF0ubGVuZ3RoICYmXG4gICAgICAgICAgbmV3SGlzdG9yeVtlbnRpdHlJZF1bMF0ubHUgPT09IHB1cmdlQmVmb3JlUHl0aG9uVGltZVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIGZpcnN0IGVudHJ5IHRvIHRoZSBzdGFydCB0aW1lIHN0YXRlXG4gICAgICAgIC8vIGFzIHdlIG5lZWQgdG8gcHJlc2VydmUgdGhlIHN0YXJ0IHRpbWUgc3RhdGUgYW5kXG4gICAgICAgIC8vIG9ubHkgZXhwaXJlIHRoZSByZXN0IG9mIHRoZSBoaXN0b3J5IGFzIGl0IGFnZXMuXG4gICAgICAgIGNvbnN0IGxhc3RFeHBpcmVkU3RhdGUgPSBleHBpcmVkU3RhdGVzW2V4cGlyZWRTdGF0ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxhc3RFeHBpcmVkU3RhdGUubHUgPSBwdXJnZUJlZm9yZVB5dGhvblRpbWU7XG4gICAgICAgIG5ld0hpc3RvcnlbZW50aXR5SWRdLnVuc2hpZnQobGFzdEV4cGlyZWRTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29tYmluZWRIaXN0b3J5ID0gbmV3SGlzdG9yeTtcbiAgICByZXR1cm4gdGhpcy5jb21iaW5lZEhpc3Rvcnk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHN1YnNjcmliZUhpc3RvcnlTdGF0ZXNUaW1lV2luZG93ID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBjYWxsYmFja0Z1bmN0aW9uOiAoZGF0YTogSGlzdG9yeVN0YXRlcykgPT4gdm9pZCxcbiAgaG91cnNUb1Nob3c6IG51bWJlcixcbiAgZW50aXR5SWRzOiBzdHJpbmdbXSxcbiAgbWluaW1hbFJlc3BvbnNlID0gdHJ1ZSxcbiAgc2lnbmlmaWNhbnRDaGFuZ2VzT25seSA9IHRydWUsXG4gIG5vQXR0cmlidXRlcz86IGJvb2xlYW5cbik6IFByb21pc2U8KCkgPT4gUHJvbWlzZTx2b2lkPj4gPT4ge1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgdHlwZTogXCJoaXN0b3J5L3N0cmVhbVwiLFxuICAgIGVudGl0eV9pZHM6IGVudGl0eUlkcyxcbiAgICBzdGFydF90aW1lOiBuZXcgRGF0ZShcbiAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gNjAgKiA2MCAqIGhvdXJzVG9TaG93ICogMTAwMFxuICAgICkudG9JU09TdHJpbmcoKSxcbiAgICBtaW5pbWFsX3Jlc3BvbnNlOiBtaW5pbWFsUmVzcG9uc2UsXG4gICAgc2lnbmlmaWNhbnRfY2hhbmdlc19vbmx5OiBzaWduaWZpY2FudENoYW5nZXNPbmx5LFxuICAgIG5vX2F0dHJpYnV0ZXM6XG4gICAgICBub0F0dHJpYnV0ZXMgPz9cbiAgICAgICFlbnRpdHlJZHMuc29tZSgoZW50aXR5SWQpID0+XG4gICAgICAgIGVudGl0eUlkSGlzdG9yeU5lZWRzQXR0cmlidXRlcyhoYXNzLCBlbnRpdHlJZClcbiAgICAgICksXG4gIH07XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBIaXN0b3J5U3RyZWFtKGhhc3MsIGhvdXJzVG9TaG93KTtcbiAgcmV0dXJuIGhhc3MuY29ubmVjdGlvbi5zdWJzY3JpYmVNZXNzYWdlPEhpc3RvcnlTdHJlYW1NZXNzYWdlPihcbiAgICAobWVzc2FnZSkgPT4gY2FsbGJhY2tGdW5jdGlvbihzdHJlYW0ucHJvY2Vzc01lc3NhZ2UobWVzc2FnZSkpLFxuICAgIHBhcmFtc1xuICApO1xufTtcblxuY29uc3QgZXF1YWxTdGF0ZSA9IChvYmoxOiBMaW5lQ2hhcnRTdGF0ZSwgb2JqMjogTGluZUNoYXJ0U3RhdGUpID0+XG4gIG9iajEuc3RhdGUgPT09IG9iajIuc3RhdGUgJiZcbiAgLy8gT25seSBjb21wYXJlIGF0dHJpYnV0ZXMgaWYgYm90aCBzdGF0ZXMgaGF2ZSBhbiBhdHRyaWJ1dGVzIG9iamVjdC5cbiAgLy8gV2hlbiBgbWluaW1hbF9yZXNwb25zZWAgaXMgc2VudCwgb25seSB0aGUgZmlyc3QgYW5kIGxhc3Qgc3RhdGVcbiAgLy8gd2lsbCBoYXZlIGF0dHJpYnV0ZXMgZXhjZXB0IGZvciBkb21haW5zIGluIERPTUFJTlNfVVNFX0xBU1RfVVBEQVRFRC5cbiAgKCFvYmoxLmF0dHJpYnV0ZXMgfHxcbiAgICAhb2JqMi5hdHRyaWJ1dGVzIHx8XG4gICAgTElORV9BVFRSSUJVVEVTX1RPX0tFRVAuZXZlcnkoXG4gICAgICAoYXR0cikgPT4gb2JqMS5hdHRyaWJ1dGVzIVthdHRyXSA9PT0gb2JqMi5hdHRyaWJ1dGVzIVthdHRyXVxuICAgICkpO1xuXG5jb25zdCBwcm9jZXNzVGltZWxpbmVFbnRpdHkgPSAoXG4gIGxvY2FsaXplOiBMb2NhbGl6ZUZ1bmMsXG4gIGxvY2FsZTogRnJvbnRlbmRMb2NhbGVEYXRhLFxuICBjb25maWc6IEhhc3NDb25maWcsXG4gIGVudGl0aWVzOiBIb21lQXNzaXN0YW50W1wiZW50aXRpZXNcIl0sXG4gIGVudGl0eUlkOiBzdHJpbmcsXG4gIHN0YXRlczogRW50aXR5SGlzdG9yeVN0YXRlW10sXG4gIGN1cnJlbnRfc3RhdGU6IEhhc3NFbnRpdHkgfCB1bmRlZmluZWRcbik6IFRpbWVsaW5lRW50aXR5ID0+IHtcbiAgY29uc3QgZGF0YTogVGltZWxpbmVTdGF0ZVtdID0gW107XG4gIGNvbnN0IGZpcnN0OiBFbnRpdHlIaXN0b3J5U3RhdGUgPSBzdGF0ZXNbMF07XG4gIGZvciAoY29uc3Qgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCAmJiBzdGF0ZS5zID09PSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc3RhdGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzOiBIYXNzRW50aXR5QXR0cmlidXRlQmFzZSA9IHt9O1xuICAgIGlmIChjdXJyZW50X3N0YXRlPy5hdHRyaWJ1dGVzLmRldmljZV9jbGFzcykge1xuICAgICAgY3VycmVudEF0dHJpYnV0ZXMuZGV2aWNlX2NsYXNzID0gY3VycmVudF9zdGF0ZT8uYXR0cmlidXRlcy5kZXZpY2VfY2xhc3M7XG4gICAgfVxuXG4gICAgZGF0YS5wdXNoKHtcbiAgICAgIHN0YXRlX2xvY2FsaXplOiBjb21wdXRlU3RhdGVEaXNwbGF5RnJvbUVudGl0eUF0dHJpYnV0ZXMoXG4gICAgICAgIGxvY2FsaXplLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgZW50aXRpZXNbZW50aXR5SWRdLFxuICAgICAgICBlbnRpdHlJZCxcbiAgICAgICAge1xuICAgICAgICAgIC4uLihzdGF0ZS5hIHx8IGZpcnN0LmEpLFxuICAgICAgICAgIC4uLmN1cnJlbnRBdHRyaWJ1dGVzLFxuICAgICAgICB9LFxuICAgICAgICBzdGF0ZS5zXG4gICAgICApLFxuICAgICAgc3RhdGU6IHN0YXRlLnMsXG4gICAgICAvLyBsYyAobGFzdF9jaGFuZ2VkKSBtYXkgYmUgb21pdHRlZCBpZiBpdHMgdGhlIHNhbWVcbiAgICAgIC8vIGFzIGx1IChsYXN0X3VwZGF0ZWQpLlxuICAgICAgbGFzdF9jaGFuZ2VkOiAoc3RhdGUubGMgPyBzdGF0ZS5sYyA6IHN0YXRlLmx1KSAqIDEwMDAsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IGNvbXB1dGVTdGF0ZU5hbWVGcm9tRW50aXR5QXR0cmlidXRlcyhcbiAgICAgIGVudGl0eUlkLFxuICAgICAgY3VycmVudF9zdGF0ZT8uYXR0cmlidXRlcyB8fCBmaXJzdC5hXG4gICAgKSxcbiAgICBlbnRpdHlfaWQ6IGVudGl0eUlkLFxuICAgIGRhdGEsXG4gIH07XG59O1xuXG5jb25zdCBwcm9jZXNzTGluZUNoYXJ0RW50aXRpZXMgPSAoXG4gIHVuaXQ6IHN0cmluZyxcbiAgZGV2aWNlX2NsYXNzOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGVudGl0aWVzOiBIaXN0b3J5U3RhdGVzLFxuICBoYXNzRW50aXRpZXM6IEhhc3NFbnRpdGllc1xuKTogTGluZUNoYXJ0VW5pdCA9PiB7XG4gIGNvbnN0IGRhdGE6IExpbmVDaGFydEVudGl0eVtdID0gW107XG5cbiAgT2JqZWN0LmtleXMoZW50aXRpZXMpLmZvckVhY2goKGVudGl0eUlkKSA9PiB7XG4gICAgY29uc3Qgc3RhdGVzID0gZW50aXRpZXNbZW50aXR5SWRdO1xuICAgIGNvbnN0IGZpcnN0OiBFbnRpdHlIaXN0b3J5U3RhdGUgPSBzdGF0ZXNbMF07XG4gICAgY29uc3QgZG9tYWluID0gY29tcHV0ZURvbWFpbihlbnRpdHlJZCk7XG4gICAgY29uc3QgcHJvY2Vzc2VkU3RhdGVzOiBMaW5lQ2hhcnRTdGF0ZVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHN0YXRlIG9mIHN0YXRlcykge1xuICAgICAgbGV0IHByb2Nlc3NlZFN0YXRlOiBMaW5lQ2hhcnRTdGF0ZTtcblxuICAgICAgaWYgKERPTUFJTlNfVVNFX0xBU1RfVVBEQVRFRC5pbmNsdWRlcyhkb21haW4pKSB7XG4gICAgICAgIHByb2Nlc3NlZFN0YXRlID0ge1xuICAgICAgICAgIHN0YXRlOiBzdGF0ZS5zLFxuICAgICAgICAgIGxhc3RfY2hhbmdlZDogc3RhdGUubHUgKiAxMDAwLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBMSU5FX0FUVFJJQlVURVNfVE9fS0VFUCkge1xuICAgICAgICAgIGlmIChhdHRyIGluIHN0YXRlLmEpIHtcbiAgICAgICAgICAgIHByb2Nlc3NlZFN0YXRlLmF0dHJpYnV0ZXMhW2F0dHJdID0gc3RhdGUuYVthdHRyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NlZFN0YXRlID0ge1xuICAgICAgICAgIHN0YXRlOiBzdGF0ZS5zLFxuICAgICAgICAgIC8vIGxjIChsYXN0X2NoYW5nZWQpIG1heSBiZSBvbWl0dGVkIGlmIGl0cyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFzIGx1IChsYXN0X3VwZGF0ZWQpLlxuICAgICAgICAgIGxhc3RfY2hhbmdlZDogKHN0YXRlLmxjID8gc3RhdGUubGMgOiBzdGF0ZS5sdSkgKiAxMDAwLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHByb2Nlc3NlZFN0YXRlcy5sZW5ndGggPiAxICYmXG4gICAgICAgIGVxdWFsU3RhdGUoXG4gICAgICAgICAgcHJvY2Vzc2VkU3RhdGUsXG4gICAgICAgICAgcHJvY2Vzc2VkU3RhdGVzW3Byb2Nlc3NlZFN0YXRlcy5sZW5ndGggLSAxXVxuICAgICAgICApICYmXG4gICAgICAgIGVxdWFsU3RhdGUocHJvY2Vzc2VkU3RhdGUsIHByb2Nlc3NlZFN0YXRlc1twcm9jZXNzZWRTdGF0ZXMubGVuZ3RoIC0gMl0pXG4gICAgICApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3NlZFN0YXRlcy5wdXNoKHByb2Nlc3NlZFN0YXRlKTtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID1cbiAgICAgIGVudGl0eUlkIGluIGhhc3NFbnRpdGllc1xuICAgICAgICA/IGhhc3NFbnRpdGllc1tlbnRpdHlJZF0uYXR0cmlidXRlc1xuICAgICAgICA6IFwiZnJpZW5kbHlfbmFtZVwiIGluIGZpcnN0LmFcbiAgICAgICAgICA/IGZpcnN0LmFcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGRhdGEucHVzaCh7XG4gICAgICBkb21haW4sXG4gICAgICBuYW1lOiBjb21wdXRlU3RhdGVOYW1lRnJvbUVudGl0eUF0dHJpYnV0ZXMoZW50aXR5SWQsIGF0dHJpYnV0ZXMgfHwge30pLFxuICAgICAgZW50aXR5X2lkOiBlbnRpdHlJZCxcbiAgICAgIHN0YXRlczogcHJvY2Vzc2VkU3RhdGVzLFxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHVuaXQsXG4gICAgZGV2aWNlX2NsYXNzLFxuICAgIGlkZW50aWZpZXI6IE9iamVjdC5rZXlzKGVudGl0aWVzKS5qb2luKFwiXCIpLFxuICAgIGRhdGEsXG4gIH07XG59O1xuXG5jb25zdCBOVU1FUklDQUxfRE9NQUlOUyA9IFtcImNvdW50ZXJcIiwgXCJpbnB1dF9udW1iZXJcIiwgXCJudW1iZXJcIl07XG5cbmNvbnN0IGlzTnVtZXJpY0Zyb21Eb21haW4gPSAoZG9tYWluOiBzdHJpbmcpID0+XG4gIE5VTUVSSUNBTF9ET01BSU5TLmluY2x1ZGVzKGRvbWFpbik7XG5cbmNvbnN0IGlzTnVtZXJpY0Zyb21BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IHsgW2tleTogc3RyaW5nXTogYW55IH0pID0+XG4gIFwidW5pdF9vZl9tZWFzdXJlbWVudFwiIGluIGF0dHJpYnV0ZXMgfHwgXCJzdGF0ZV9jbGFzc1wiIGluIGF0dHJpYnV0ZXM7XG5cbmNvbnN0IGlzTnVtZXJpY1NlbnNvckVudGl0eSA9IChcbiAgc3RhdGVPYmo6IEhhc3NFbnRpdHksXG4gIHNlbnNvck51bWVyaWNhbERldmljZUNsYXNzZXM6IHN0cmluZ1tdXG4pID0+XG4gIHN0YXRlT2JqLmF0dHJpYnV0ZXMuZGV2aWNlX2NsYXNzICE9IG51bGwgJiZcbiAgc2Vuc29yTnVtZXJpY2FsRGV2aWNlQ2xhc3Nlcy5pbmNsdWRlcyhzdGF0ZU9iai5hdHRyaWJ1dGVzLmRldmljZV9jbGFzcyk7XG5cbmNvbnN0IEJMQU5LX1VOSVQgPSBcIiBcIjtcblxuZXhwb3J0IGNvbnN0IGNvbXB1dGVIaXN0b3J5ID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBzdGF0ZUhpc3Rvcnk6IEhpc3RvcnlTdGF0ZXMsXG4gIGxvY2FsaXplOiBMb2NhbGl6ZUZ1bmMsXG4gIHNlbnNvck51bWVyaWNhbERldmljZUNsYXNzZXM6IHN0cmluZ1tdLFxuICBzcGxpdERldmljZUNsYXNzZXMgPSBmYWxzZVxuKTogSGlzdG9yeVJlc3VsdCA9PiB7XG4gIGNvbnN0IGxpbmVDaGFydERldmljZXM6IHsgW3VuaXQ6IHN0cmluZ106IEhpc3RvcnlTdGF0ZXMgfSA9IHt9O1xuICBjb25zdCB0aW1lbGluZURldmljZXM6IFRpbWVsaW5lRW50aXR5W10gPSBbXTtcbiAgaWYgKCFzdGF0ZUhpc3RvcnkpIHtcbiAgICByZXR1cm4geyBsaW5lOiBbXSwgdGltZWxpbmU6IFtdIH07XG4gIH1cbiAgT2JqZWN0LmtleXMoc3RhdGVIaXN0b3J5KS5mb3JFYWNoKChlbnRpdHlJZCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlSW5mbyA9IHN0YXRlSGlzdG9yeVtlbnRpdHlJZF07XG4gICAgaWYgKHN0YXRlSW5mby5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkb21haW4gPSBjb21wdXRlRG9tYWluKGVudGl0eUlkKTtcblxuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9XG4gICAgICBlbnRpdHlJZCBpbiBoYXNzLnN0YXRlcyA/IGhhc3Muc3RhdGVzW2VudGl0eUlkXSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBudW1lcmljU3RhdGVGcm9tSGlzdG9yeSA9XG4gICAgICBjdXJyZW50U3RhdGUgfHwgaXNOdW1lcmljRnJvbURvbWFpbihkb21haW4pXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogc3RhdGVJbmZvLmZpbmQoXG4gICAgICAgICAgICAoc3RhdGUpID0+IHN0YXRlLmEgJiYgaXNOdW1lcmljRnJvbUF0dHJpYnV0ZXMoc3RhdGUuYSlcbiAgICAgICAgICApO1xuXG4gICAgbGV0IHVuaXQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IGlzTnVtZXJpYyA9XG4gICAgICBpc051bWVyaWNGcm9tRG9tYWluKGRvbWFpbikgfHxcbiAgICAgIChjdXJyZW50U3RhdGUgIT0gbnVsbCAmJlxuICAgICAgICBpc051bWVyaWNGcm9tQXR0cmlidXRlcyhjdXJyZW50U3RhdGUuYXR0cmlidXRlcykpIHx8XG4gICAgICAoY3VycmVudFN0YXRlICE9IG51bGwgJiZcbiAgICAgICAgZG9tYWluID09PSBcInNlbnNvclwiICYmXG4gICAgICAgIGlzTnVtZXJpY1NlbnNvckVudGl0eShjdXJyZW50U3RhdGUsIHNlbnNvck51bWVyaWNhbERldmljZUNsYXNzZXMpKSB8fFxuICAgICAgbnVtZXJpY1N0YXRlRnJvbUhpc3RvcnkgIT0gbnVsbDtcblxuICAgIGlmIChpc051bWVyaWMpIHtcbiAgICAgIHVuaXQgPVxuICAgICAgICBjdXJyZW50U3RhdGU/LmF0dHJpYnV0ZXMudW5pdF9vZl9tZWFzdXJlbWVudCB8fFxuICAgICAgICBudW1lcmljU3RhdGVGcm9tSGlzdG9yeT8uYS51bml0X29mX21lYXN1cmVtZW50IHx8XG4gICAgICAgIEJMQU5LX1VOSVQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXQgPSB7XG4gICAgICAgIHpvbmU6IGxvY2FsaXplKFwidWkuZGlhbG9ncy5tb3JlX2luZm9fY29udHJvbC56b25lLmdyYXBoX3VuaXRcIiksXG4gICAgICAgIGNsaW1hdGU6IGhhc3MuY29uZmlnLnVuaXRfc3lzdGVtLnRlbXBlcmF0dXJlLFxuICAgICAgICBodW1pZGlmaWVyOiBcIiVcIixcbiAgICAgICAgd2F0ZXJfaGVhdGVyOiBoYXNzLmNvbmZpZy51bml0X3N5c3RlbS50ZW1wZXJhdHVyZSxcbiAgICAgIH1bZG9tYWluXTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXZpY2VDbGFzczogc3RyaW5nIHwgdW5kZWZpbmVkID0gKFxuICAgICAgY3VycmVudFN0YXRlPy5hdHRyaWJ1dGVzIHx8IG51bWVyaWNTdGF0ZUZyb21IaXN0b3J5Py5hXG4gICAgKT8uZGV2aWNlX2NsYXNzO1xuXG4gICAgY29uc3Qga2V5ID0gY29tcHV0ZUdyb3VwS2V5KHVuaXQsIGRldmljZUNsYXNzLCBzcGxpdERldmljZUNsYXNzZXMpO1xuXG4gICAgaWYgKCF1bml0KSB7XG4gICAgICB0aW1lbGluZURldmljZXMucHVzaChcbiAgICAgICAgcHJvY2Vzc1RpbWVsaW5lRW50aXR5KFxuICAgICAgICAgIGxvY2FsaXplLFxuICAgICAgICAgIGhhc3MubG9jYWxlLFxuICAgICAgICAgIGhhc3MuY29uZmlnLFxuICAgICAgICAgIGhhc3MuZW50aXRpZXMsXG4gICAgICAgICAgZW50aXR5SWQsXG4gICAgICAgICAgc3RhdGVJbmZvLFxuICAgICAgICAgIGN1cnJlbnRTdGF0ZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBrZXkgJiZcbiAgICAgIGtleSBpbiBsaW5lQ2hhcnREZXZpY2VzICYmXG4gICAgICBlbnRpdHlJZCBpbiBsaW5lQ2hhcnREZXZpY2VzW2tleV1cbiAgICApIHtcbiAgICAgIGxpbmVDaGFydERldmljZXNba2V5XVtlbnRpdHlJZF0ucHVzaCguLi5zdGF0ZUluZm8pO1xuICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICBpZiAoIShrZXkgaW4gbGluZUNoYXJ0RGV2aWNlcykpIHtcbiAgICAgICAgbGluZUNoYXJ0RGV2aWNlc1trZXldID0ge307XG4gICAgICB9XG4gICAgICBsaW5lQ2hhcnREZXZpY2VzW2tleV1bZW50aXR5SWRdID0gc3RhdGVJbmZvO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdW5pdFN0YXRlcyA9IE9iamVjdC5rZXlzKGxpbmVDaGFydERldmljZXMpLm1hcCgoa2V5KSA9PiB7XG4gICAgY29uc3Qgc3BsaXRLZXkgPSBrZXkuc3BsaXQoXCJfXCIpO1xuICAgIGNvbnN0IHVuaXQgPSBzcGxpdEtleVswXTtcbiAgICBjb25zdCBkZXZpY2VDbGFzcyA9IHNwbGl0S2V5WzFdIHx8IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcHJvY2Vzc0xpbmVDaGFydEVudGl0aWVzKFxuICAgICAgdW5pdCxcbiAgICAgIGRldmljZUNsYXNzLFxuICAgICAgbGluZUNoYXJ0RGV2aWNlc1trZXldLFxuICAgICAgaGFzcy5zdGF0ZXNcbiAgICApO1xuICB9KTtcblxuICByZXR1cm4geyBsaW5lOiB1bml0U3RhdGVzLCB0aW1lbGluZTogdGltZWxpbmVEZXZpY2VzIH07XG59O1xuXG5leHBvcnQgY29uc3QgY29tcHV0ZUdyb3VwS2V5ID0gKFxuICB1bml0OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGRldmljZV9jbGFzczogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBzcGxpdERldmljZUNsYXNzZXM6IGJvb2xlYW5cbikgPT4gKHNwbGl0RGV2aWNlQ2xhc3NlcyA/IGAke3VuaXR9XyR7ZGV2aWNlX2NsYXNzIHx8IFwiXCJ9YCA6IHVuaXQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/data/history.ts\n");

/***/ })

};
