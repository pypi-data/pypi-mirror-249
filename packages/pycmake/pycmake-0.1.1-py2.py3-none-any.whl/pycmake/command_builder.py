import os
import atexit
import datetime
from . import cmake_variable
from . import pycmake_variable
from . import input_args

_cmake_command = ""


def todo(any_cmake_comand):
    return lambda *args: print(
        f"TODO: {any_cmake_comand.__name__} hasn't been supported yet!"
    )


# build args list seperated by empty space
def args_builder(args):
    cmd_args = ""
    for arg in args:
        if isinstance(arg, tuple) or isinstance(arg, list):
            str_arg = args_builder(arg)
        elif isinstance(arg, str):
            str_arg = f'"{arg}"'
        else:
            str_arg = f"{arg}"

        cmd_args += str_arg + " "

    if cmd_args != "":
        cmd_args = cmd_args[: -len(" ")]

    return cmd_args


def recording(cmd):
    global _cmake_command
    _cmake_command += cmd + os.linesep
    return cmd


def builder(any_cmake_comand):
    return lambda *args: recording(
        f"{any_cmake_comand.__name__[len('cmake_'):]}({args_builder(args)})"
    )


def cmake_call_builder(cmake_call_fn):
    return lambda *args: recording(f"{args[0]}({args_builder(args[1:])})")


def callback_after_command_building():
    with open(pycmake_variable.PY_CMAKE_LISTS_PATH, "w") as f:
        f.write(
            """# This file was generated by pycmake at {}.
""".format(
                datetime.datetime.now()
                .astimezone()
                .strftime("%H:%M:%S on %d %B %Y %Z(%z)")
            )
        )
        f.write(_cmake_command)

    if input_args.args.configure:
        os.system(
            f"cmake -S {cmake_variable.CMAKE_CURRENT_SOURCE_DIR} -B "
            + os.path.join(cmake_variable.CMAKE_CURRENT_SOURCE_DIR, "build")
            + f" {pycmake_variable.PY_CMAKE_CONFIGURE_ARGS}"
        )


atexit.register(callback_after_command_building)
