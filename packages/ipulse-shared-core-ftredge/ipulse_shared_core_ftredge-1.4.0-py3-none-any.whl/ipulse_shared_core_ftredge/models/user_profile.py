from pydantic import BaseModel, EmailStr , Field, root_validator
from datetime import datetime , date
from typing import Set, Optional, Dict, Any, Annotated
import uuid
from . import pulse_enums as enums

CLASS_VERSION = 2.1
CLASS_VERSION_AUTHOR="Russlan Ramdowar;russlan@ftredge.com"
CLASS_VERSION_DATE=datetime(2023, 12, 23, 17, 50)
MODULE="core"
CLASS_REF = "usrpf"

class UserProfile(BaseModel):
    uid: str = Field(frozen=True, description="Generated by Firebase Auth")
    
    puid:str = Field(default_factory=lambda: f"{datetime.utcnow().strftime('%Y%m%d%H%M')}{uuid.uuid4().hex[:8]}_{MODULE}{CLASS_REF}".lower(),
                      frozen=True, 
                      description="Generated Automatically by default_factory")
    email: EmailStr =  Field(frozen=True, description="Propagated from Firebase Auth" )
    insights_credits: int= Field(default_factory=lambda:7, description="Depends on Subscription Plan, Regularly Updated")
    organizations_uids: Set[str] = Field( description="Depends on Subscription Plan, Regularly Updated")
    creat_date: datetime #User can Read only
    creat_by_user: str #User shouldn't see this or edit this_dump=
    updt_date: datetime #User can Read only
    updt_by_user: str #User shouldn't see this or edit this
    approved: bool  #User shouldn't see this or edit this
    provider_id: str   #User shouldn't see this or edit this
    username: Optional[str] = None #User can Read and Edit
    aliases: Optional[Set[str]] = None #User can Read and Edit
    dob: Optional[date] = None #User can Read and Edit 
    first_name: Optional[str] = None #User can Read and Edit 
    last_name: Optional[str] = None #User can Read and Edit 
    mobile: Optional[str] = None #User can Read and Edit 
    groups_names: Optional[Set[str]] = None #User can Read only
    policies_uids: Optional[Set[str]] = None #User can Read only
    subscription_plan_uid: Optional[str]=None #User can Read only
    insights_credits_updated_since_datetime: Optional[datetime]=None #User can Read only
            
    class Config:
        extra = "forbid"

    @root_validator(pre=True)
    def check_resr_classification(cls, values: Dict[Any, Any]):
        for field_name, field_value in values.items():
            if field_name in cls.model_fields:
                print(f"field_name : {field_name} , field_value : {field_value}")
                # field_info = cls.model_fields[field_name].field_info
                # resr_classification = field_info.extra.get("resr_classification")
                # if resr_classification and resr_classification not in enums.resource_classifications:
                #     raise ValueError(f"Invalid resource_classification '{resr_classification}' for field '{field_name}'")
        return values



# class User(BaseModel):
#     puid: str 
#     puid2:str #User can Read only
#     email: EmailStr  #User can Read only
#     insights_credits: int=7 #User can Read only
#     organizations_ids: Set[str]  #User can Read only
#     created_at: datetime #User can Read only
#     created_by: str #User shouldn't see this or edit this
#     updated_at: datetime #User can Read only
#     updated_by: str #User shouldn't see this or edit this
#     approved: bool  #User shouldn't see this or edit this
#     provider_id: str   #User shouldn't see this or edit this
#     username: Optional[str] = None #User can Read and Edit
#     aliases: Optional[Set[str]] = None #User can Read and Edit
#     dob: Optional[date] = None #User can Read and Edit 
#     first_name: Optional[str] = None #User can Read and Edit 
#     last_name: Optional[str] = None #User can Read and Edit 
#     mobile: Optional[str] = None #User can Read and Edit 
#     groups_names: Set[str] = None #User can Read only
#     policies_uids: Optional[Set[str]] = None #User can Read only
#     subscription_plan_uid: Optional[str]=None #User can Read only
#     insights_credits_updated_since: Optional[datetime]=None #User can Read only
#     class_version: float  = CLASS_VERSION #User shouldn't see this or edit this
