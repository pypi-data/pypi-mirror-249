<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <meta name="generator" content="sphinx-4.4.0, furo 2022.02.14.1"/>
        <title>akerbp.mlpet.feature_engineering - akerbp.mlpet 1.1.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=a8f031f701c6af50c9919b48f173a5785af06fac" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=25ceb02ed1c46dc30f2321ff83e92799f69dfdb9" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  body[data-theme="dark"] {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
  @media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }
</style></head>
  <body>
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">akerbp.mlpet 1.1.1 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">akerbp.mlpet 1.1.1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Package Documentation</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../akerbp.mlpet.html">akerbp.mlpet package</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../akerbp.mlpet.dataloader.html">dataloader module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../akerbp.mlpet.dataset.html">dataset module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../akerbp.mlpet.feature_engineering.html">feature_engineering module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../akerbp.mlpet.utilities.html">utilities module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../akerbp.mlpet.preprocessors.html">preprocessors module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../akerbp.mlpet.imputers.html">imputers module</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <div class="content-icon-container"><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for akerbp.mlpet.feature_engineering</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">cognite.client</span> <span class="kn">import</span> <span class="n">CogniteClient</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">savgol_filter</span>

<span class="kn">from</span> <span class="nn">akerbp.mlpet</span> <span class="kn">import</span> <span class="n">utilities</span>


<div class="viewcode-block" id="add_log_features"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.add_log_features">[docs]</a><span class="k">def</span> <span class="nf">add_log_features</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Creates columns with log10 of curves. All created columns are suffixed with</span>
<span class="sd">    '_log'. All negative values are set to zero and 1 is added to all values. In</span>
<span class="sd">    other words, this function is synonymous of numpy's log1p.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): dataframe with columns to calculate log10 from</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        log_features (list, optional): list of column names for the columns that should be</span>
<span class="sd">            loggified. Defaults to None</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: New dataframe with calculated log columns</span>
<span class="sd">    """</span>
    <span class="n">log_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"log_features"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">log_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">log_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="s2">"_log"</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">log_features</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="n">log_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">log_features</span><span class="p">]</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="add_gradient_features"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.add_gradient_features">[docs]</a><span class="k">def</span> <span class="nf">add_gradient_features</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Creates columns with gradient of curves. All created columns are suffixed with</span>
<span class="sd">    '_gradient'.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): dataframe with columns to calculate gradient from</span>
<span class="sd">    Keyword Args:</span>
<span class="sd">        gradient_features (list, optional): list of column names for the columns</span>
<span class="sd">            that gradient features should be calculated for. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: New dataframe with calculated gradient feature columns</span>
<span class="sd">    """</span>
    <span class="n">gradient_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"gradient_features"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">gradient_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gradient_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="s2">"_gradient"</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">gradient_features</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">feature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gradient_features</span><span class="p">):</span>
            <span class="n">df</span><span class="p">[</span><span class="n">gradient_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">feature</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="add_rolling_features"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.add_rolling_features">[docs]</a><span class="k">def</span> <span class="nf">add_rolling_features</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Creates columns with window/rolling features of curves. All created columns</span>
<span class="sd">    are suffixed with '_window_mean' / '_window_max' / '_window_min'.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): dataframe with columns to calculate rolling features from</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        rolling_features (list): columns to apply rolling features to. Defaults to None.</span>
<span class="sd">        depth_column (str): The name of the column to use to determine the sampling</span>
<span class="sd">            rate. Without this kwarg no rolling features are calculated.</span>
<span class="sd">        window (float): The window size to use for calculating the rolling</span>
<span class="sd">            features. **The window size is defined in distance**! The sampling rate</span>
<span class="sd">            is determined from the depth_column kwarg and used to transform the window</span>
<span class="sd">            size into an index based window. If this is not provided, no rolling features are calculated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: New dataframe with calculated rolling feature columns</span>
<span class="sd">    """</span>
    <span class="n">rolling_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"rolling_features"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"window"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">depth_column</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"depth_column"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rolling_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">depth_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">calculate_sampling_rate</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">depth_column</span><span class="p">])</span>
        <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">)</span>
        <span class="n">mean_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="s2">"_window_mean"</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">rolling_features</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="n">mean_cols</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="n">rolling_features</span><span class="p">]</span>
            <span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">min_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="s2">"_window_min"</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">rolling_features</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="n">min_cols</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="n">rolling_features</span><span class="p">]</span>
            <span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">max_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="s2">"_window_max"</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">rolling_features</span><span class="p">]</span>
        <span class="n">df</span><span class="p">[</span><span class="n">max_cols</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="n">rolling_features</span><span class="p">]</span>
            <span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="add_sequential_features"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.add_sequential_features">[docs]</a><span class="k">def</span> <span class="nf">add_sequential_features</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Adds n past values of columns (for sequential models modelling). All created</span>
<span class="sd">    columns are suffixed with '_1' / '_2' / ... / '_n'.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): dataframe to add time features to</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        sequential_features (list, optional): columns to apply shifting to. Defaults to None.</span>
<span class="sd">        shift_size (int, optional): Size of the shifts to calculate. In other words, number of past values</span>
<span class="sd">            to include. If this is not provided, no sequential features are calculated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: New dataframe with sequential gradient columns</span>
<span class="sd">    """</span>
    <span class="n">sequential_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"sequential_features"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">shift_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"shift_size"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sequential_features</span> <span class="ow">and</span> <span class="n">shift_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">shift_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">sequential_cols</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">shift</span><span class="si">}</span><span class="s2">"</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sequential_features</span><span class="p">]</span>
            <span class="n">df</span><span class="p">[</span><span class="n">sequential_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">sequential_features</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="add_petrophysical_features"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.add_petrophysical_features">[docs]</a><span class="k">def</span> <span class="nf">add_petrophysical_features</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Creates petrophysical features according to relevant heuristics/formulas.</span>

<span class="sd">    The features created are as follows (each one can be toggled on/off via the</span>
<span class="sd">    'petrophysical_features' kwarg)::</span>

<span class="sd">        - VPVS = ACS / AC</span>
<span class="sd">        - PR = (VP ** 2 * 2 * VS ** 2) / (2 * (VP ** 2 * VS ** 2)) where</span>
<span class="sd">        - VP = 304.8 / AC</span>
<span class="sd">        - VS = 304.8 / ACS</span>
<span class="sd">        - RAVG = AVG(RDEP, RMED, RSHA), if at least two of those are present</span>
<span class="sd">        - LFI = 2.95 * ((NEU + 0.15) / 0.6) * DEN, and</span>
<span class="sd">            - LFI &lt; *0.9 = 0</span>
<span class="sd">            - NaNs are filled with 0</span>
<span class="sd">        - FI = (ABS(LFI) + LFI) / 2</span>
<span class="sd">        - LI = ABS(ABS(LFI) * LFI) / 2</span>
<span class="sd">        - AI = DEN * ((304.8 / AC) ** 2)</span>
<span class="sd">        - CALI*BS = CALI * BS, where</span>
<span class="sd">            - BS is calculated using the guess_BS_from_CALI function from this</span>
<span class="sd">            module it is not found in the pass dataframe</span>
<span class="sd">        - VSH = Refer to the calculate_VSH docstring for more info on this</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): dataframe to which add features from and to</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        petrophysical_features (list): A list of all the petrophysical features</span>
<span class="sd">            that should be created (see above for all the potential features</span>
<span class="sd">            this method can create). This defaults to an empty list (i.e. no</span>
<span class="sd">            features created).</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: dataframe with added features</span>
<span class="sd">    """</span>
    <span class="n">petrophysical_features</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"petrophysical_features"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">petrophysical_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Calculate relevant features</span>
        <span class="k">if</span> <span class="s2">"VP"</span> <span class="ow">in</span> <span class="n">petrophysical_features</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_VP</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">"VS"</span> <span class="ow">in</span> <span class="n">petrophysical_features</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_VS</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">"VPVS"</span> <span class="ow">in</span> <span class="n">petrophysical_features</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_VPVS</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">"PR"</span> <span class="ow">in</span> <span class="n">petrophysical_features</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_PR</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">"RAVG"</span> <span class="ow">in</span> <span class="n">petrophysical_features</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_RAVG</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">"LFI"</span> <span class="ow">in</span> <span class="n">petrophysical_features</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_LFI</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">"FI"</span> <span class="ow">in</span> <span class="n">petrophysical_features</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_FI</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">"LI"</span> <span class="ow">in</span> <span class="n">petrophysical_features</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_LI</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">"AI"</span> <span class="ow">in</span> <span class="n">petrophysical_features</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_AI</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">"CALI-BS"</span> <span class="ow">in</span> <span class="n">petrophysical_features</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_CALI_BS</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">"VSH"</span> <span class="ow">in</span> <span class="n">petrophysical_features</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_VSH</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="add_well_metadata"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.add_well_metadata">[docs]</a><span class="k">def</span> <span class="nf">add_well_metadata</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Adds well metadata columns to the provided dataframe from the provided</span>
<span class="sd">    well metadata dictionary (kwarg)</span>

<span class="sd">    Warning:</span>
<span class="sd">        This method will not work without the three kwargs listed below! It will</span>
<span class="sd">        return the df untouched and print a warning if kwargs are missing.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe in which the well metadata columns will</span>
<span class="sd">            be added</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        metadata_dict (dict): The dictionary containing the relevant metadata</span>
<span class="sd">            per well (usually generated with the</span>
<span class="sd">            :py:meth: `get_well_metadata &lt;akerbp.mlpet.utilties.get_well_metadata&gt;` function).</span>
<span class="sd">        metadata_columns (list): List of metadata columns to add (each entry must</span>
<span class="sd">            correspond to a metadata key in the provided metadata_dict kwarg)</span>
<span class="sd">        id_column (str): The name of the column containing the well names (to be</span>
<span class="sd">            matched with the keys in the provided metadata_dict)</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Return the passed dataframe with the requested columns added</span>
<span class="sd">    """</span>
    <span class="n">id_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"id_column"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">metadata_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"metadata_dict"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">metadata_columns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"metadata_columns"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">id_column</span><span class="p">,</span> <span class="n">metadata_dict</span><span class="p">,</span> <span class="n">metadata_columns</span><span class="p">]]):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">"Could not add metadata because one of the necessary kwargs was "</span>
            <span class="s2">"missing! Returning the dataframe untouched."</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="c1"># Reduce metadata dict to only desired columns</span>
    <span class="n">mapper</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">well</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="n">metadata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">metadata_columns</span><span class="p">:</span>
                <span class="n">mapper</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">well</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="c1"># Apply metadata mapping</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">metadata_columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">id_column</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="add_formations_and_groups"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.add_formations_and_groups">[docs]</a><span class="k">def</span> <span class="nf">add_formations_and_groups</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Adds a FORMATION AND GROUP column to the dataframe based on the well formation</span>
<span class="sd">    tops metadata and the depth in the column.</span>

<span class="sd">    Note:</span>
<span class="sd">        This function requires several kwargs to be able to run. If they are not</span>
<span class="sd">        provided a warning is raised and instead the df is returned untouched.</span>

<span class="sd">    Note:</span>
<span class="sd">        If the well is not found in formation_tops_mapping, the code will</span>
<span class="sd">        print a warning and continue to the next well.</span>

<span class="sd">    Example:</span>
<span class="sd">        An example mapper dictionary that would classify all depths in WELL_A</span>
<span class="sd">        between 120 &amp; 879 as NORDLAND GP and all depths between 879 and 2014 as</span>
<span class="sd">        HORDALAND GP, would look like this::</span>

<span class="sd">            formation_tops_mapper = {</span>
<span class="sd">                "WELL_A": {</span>
<span class="sd">                    "labels": [NORDLAND GP, HORDALAND GP],</span>
<span class="sd">                    "levels": [120.0, 879.0, 2014.0]</span>
<span class="sd">                }</span>
<span class="sd">                ...</span>
<span class="sd">            }</span>

<span class="sd">        It can be generated by using the</span>
<span class="sd">        :py:meth: `get_formation_tops &lt;akerbp.mlpet.utilties.get_formation_tops&gt;` function</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe in which the formation tops label column</span>
<span class="sd">            should be added</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        id_column (str): The name of the column of well IDs</span>
<span class="sd">        depth_column (str): The name of the depth column to use for applying the</span>
<span class="sd">            mappings.</span>
<span class="sd">        formation_tops_mapper (dict): A dictionary mapping the well IDs to the</span>
<span class="sd">            formation tops labels, chronostrat and depth levels. For example::</span>

<span class="sd">                formation_tops_mapper = {</span>
<span class="sd">                    "31/6-6": {</span>
<span class="sd">                        "group_labels": ['Nordland Group', 'Hordaland Group', ...],</span>
<span class="sd">                        "group_labels_chronostrat": ['Cenozoic', 'Paleogene', ...]</span>
<span class="sd">                        "group_levels": [336.0, 531.0, 650.0, ...],</span>
<span class="sd">                        "formation_labels": ['Balder Formation', 'Sele Formation', ...],</span>
<span class="sd">                        "formation_labels_chronostrat": ['Eocene', 'Paleocene', ...],</span>
<span class="sd">                        "formation_levels": [650.0, 798.0, 949.0, ...]</span>
<span class="sd">                    }</span>
<span class="sd">                    ...</span>
<span class="sd">                }</span>

<span class="sd">            The above example would classify all depths in well 31/6-6 between 336 &amp;</span>
<span class="sd">            531 to belong to the Nordland Group, and the corresponding chronostrat is the Cenozoic period.</span>
<span class="sd">            Depths between 650 and 798 are classified to belong to the Balder formation,</span>
<span class="sd">            which belongs to the Eocene period.</span>
<span class="sd">        client (CogniteClient): client to query CDF for formaiton tops if a mapping dictionary is not provided</span>
<span class="sd">            Defaults to None</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: dataframe with additional columns for FORMATION and GROUP</span>
<span class="sd">    """</span>
    <span class="n">id_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"id_column"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">depth_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"depth_column"</span><span class="p">,</span> <span class="s2">"DEPTH"</span><span class="p">)</span>
    <span class="n">formation_tops_mapper</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
        <span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"formation_tops_mapper"</span><span class="p">,</span> <span class="p">{})</span>

    <span class="n">well_names</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">id_column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">formation_tops_mapper</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">formation_tops_mapper</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">get_formation_tops</span><span class="p">(</span>
                <span class="n">well_names</span><span class="o">=</span><span class="n">well_names</span><span class="p">,</span> <span class="n">client</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">"client"</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"Neither a formation tops mapping nor cognite client is provided. Not able to add formation tops to dataset"</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>
    <span class="n">df_</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">id_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">formation_tops_mapper</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">depth_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df_</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"Cannot add formations and groups metadata without a depth_column"</span>
            <span class="p">)</span>
        <span class="n">df_</span><span class="p">[</span><span class="s2">"GROUP"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"UNKNOWN"</span>
        <span class="n">df_</span><span class="p">[</span><span class="s2">"FORMATION"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"UNKNOWN"</span>

        <span class="k">for</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">df_</span><span class="p">[</span><span class="n">id_column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mappings</span> <span class="o">=</span> <span class="n">formation_tops_mapper</span><span class="p">[</span><span class="n">well</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">df_</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_</span><span class="p">[</span><span class="n">id_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">well</span><span class="p">,</span> <span class="p">[</span><span class="s2">"GROUP"</span><span class="p">,</span> <span class="s2">"FORMATION"</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"No formation tops information found for </span><span class="si">{</span><span class="n">well</span><span class="si">}</span><span class="s2">. Setting "</span>
                    <span class="s2">"both GROUP and FORMATION to NaN for this well."</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">group_labels</span><span class="p">,</span> <span class="n">group_levels</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">mappings</span><span class="p">[</span><span class="s2">"group_labels"</span><span class="p">],</span>
                <span class="n">mappings</span><span class="p">[</span><span class="s2">"group_levels"</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">formation_labels</span><span class="p">,</span> <span class="n">formation_levels</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">mappings</span><span class="p">[</span><span class="s2">"formation_labels"</span><span class="p">],</span>
                <span class="n">mappings</span><span class="p">[</span><span class="s2">"formation_levels"</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_levels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">formation_levels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">formation_labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">"The formation top information for </span><span class="si">{</span><span class="n">well</span><span class="si">}</span><span class="s2"> is invalid! "</span>
                    <span class="s2">"Please refer to the docstring of this method to understand "</span>
                    <span class="s2">"the format in which formation top mappings should be provided."</span>
                <span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">well_df</span> <span class="o">=</span> <span class="n">df_</span><span class="p">[</span><span class="n">df_</span><span class="p">[</span><span class="n">id_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">well</span><span class="p">]</span>
            <span class="n">df_</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">well_df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s2">"GROUP"</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span>
                <span class="n">well_df</span><span class="p">[</span><span class="n">depth_column</span><span class="p">],</span>
                <span class="n">bins</span><span class="o">=</span><span class="n">group_levels</span><span class="p">,</span>
                <span class="n">labels</span><span class="o">=</span><span class="n">group_labels</span><span class="p">,</span>
                <span class="n">include_lowest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">df_</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">well_df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s2">"FORMATION"</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span>
                <span class="n">well_df</span><span class="p">[</span><span class="n">depth_column</span><span class="p">],</span>
                <span class="n">bins</span><span class="o">=</span><span class="n">formation_levels</span><span class="p">,</span>
                <span class="n">labels</span><span class="o">=</span><span class="n">formation_labels</span><span class="p">,</span>
                <span class="n">include_lowest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">df_</span><span class="p">[</span><span class="s2">"GROUP"</span><span class="p">]</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">map_formation_and_group</span><span class="p">(</span>
            <span class="n">df_</span><span class="p">[</span><span class="s2">"GROUP"</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">utilities</span><span class="o">.</span><span class="n">standardize_group_formation_name</span><span class="p">)</span>
        <span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">df_</span><span class="p">[</span><span class="s2">"FORMATION"</span><span class="p">]</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">map_formation_and_group</span><span class="p">(</span>
            <span class="n">df_</span><span class="p">[</span><span class="s2">"FORMATION"</span><span class="p">]</span>
            <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">utilities</span><span class="o">.</span><span class="n">standardize_group_formation_name</span><span class="p">)</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"A formation tops label could not be added to the provided dataframe"</span>
            <span class="s2">" because some keyword arguments were missing!"</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">df_</span></div>


<div class="viewcode-block" id="guess_BS_from_CALI"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.guess_BS_from_CALI">[docs]</a><span class="k">def</span> <span class="nf">guess_BS_from_CALI</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">standard_BS_values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Guess bitsize from CALI, given the standard bitsizes</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): dataframe to preprocess</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        standard_BS_values (ndarray): Numpy array of standardized bitsizes to</span>
<span class="sd">            consider. Defaults to::</span>

<span class="sd">                np.array([6, 8.5, 9.875, 12.25, 17.5, 26])</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: preprocessed dataframe</span>

<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">standard_BS_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">standard_BS_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">,</span> <span class="mf">9.875</span><span class="p">,</span> <span class="mf">12.25</span><span class="p">,</span> <span class="mf">17.5</span><span class="p">,</span> <span class="mi">26</span><span class="p">]</span>
    <span class="n">BS_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">standard_BS_values</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">(</span><span class="n">BS_values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">BS_values</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">edges</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]])</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">"BS"</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"CALI"</span><span class="p">],</span> <span class="n">edges</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">BS_values</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s2">"BS"</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="calculate_CALI_BS"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.calculate_CALI_BS">[docs]</a><span class="k">def</span> <span class="nf">calculate_CALI_BS</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Calculates CALI-BS assuming at least CALI is provided in the dataframe</span>
<span class="sd">    argument. If BS is not provided, it is estimated using the</span>
<span class="sd">    :py:meth:`guess_BS_from_CALI &lt;akerbp.mlpet.feature_engineering.guess_BS_from_CALI&gt;`</span>
<span class="sd">    method from this module.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe to which CALI-BS should be added.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raises an error if neither CALI nor BS are provided</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Returns the dataframe with CALI-BS as a new column</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="s2">"CALI"</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">"BS"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">guess_BS_from_CALI</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">"CALI-BS"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">"CALI"</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">"BS"</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Not possible to generate CALI-BS. At least CALI needs to be present in the dataset."</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="calculate_AI"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.calculate_AI">[docs]</a><span class="k">def</span> <span class="nf">calculate_AI</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Calculates AI from DEN and AC according to the following formula::</span>

<span class="sd">        AI = DEN * ((304.8 / AC) ** 2)</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe to which AI should be added.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raises an error if neither DEN nor AC are provided</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Returns the dataframe with AI as a new column</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="s2">"DEN"</span><span class="p">,</span> <span class="s2">"AC"</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">"AI"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">"DEN"</span><span class="p">]</span> <span class="o">*</span> <span class="p">((</span><span class="mf">304.8</span> <span class="o">/</span> <span class="n">df</span><span class="p">[</span><span class="s2">"AC"</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Not possible to generate AI as DEN and AC are not present in the dataset."</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="calculate_LI"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.calculate_LI">[docs]</a><span class="k">def</span> <span class="nf">calculate_LI</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Calculates LI from LFI according to the following formula::</span>

<span class="sd">        LI = ABS(ABS(LFI) - LFI) / 2</span>

<span class="sd">    If LFI is not in the provided dataframe, it is calculated using the</span>
<span class="sd">    calculate_LFI method of this module.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe to which LI should be added.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raises an error if neither NEU nor DEN or LFI are provided</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Returns the dataframe with LI as a new column</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="s2">"LFI"</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="nb">set</span><span class="p">([</span><span class="s2">"NEU"</span><span class="p">,</span> <span class="s2">"DEN"</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_LFI</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Not possible to generate LI as NEU and DEN or LFI are not present in dataset."</span>
        <span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">"LI"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"LFI"</span><span class="p">])</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">"LFI"</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="calculate_FI"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.calculate_FI">[docs]</a><span class="k">def</span> <span class="nf">calculate_FI</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Calculates FI from LFI according to the following formula::</span>

<span class="sd">        FI = (ABS(LFI) + LFI) / 2</span>

<span class="sd">    If LFI is not in the provided dataframe, it is calculated using the</span>
<span class="sd">    calculate_LFI method of this module.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe to which FI should be added.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raises an error if neither NEU nor DEN or LFI are provided</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Returns the dataframe with FI as a new column</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="s2">"LFI"</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="nb">set</span><span class="p">([</span><span class="s2">"NEU"</span><span class="p">,</span> <span class="s2">"DEN"</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_LFI</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Not possible to generate FI as NEU and DEN or LFI are not present in dataset."</span>
        <span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">"FI"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"LFI"</span><span class="p">]</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">"LFI"</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="calculate_LFI"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.calculate_LFI">[docs]</a><span class="k">def</span> <span class="nf">calculate_LFI</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Calculates LFI from NEU and DEN according to the following formula::</span>

<span class="sd">        LFI = 2.95 - ((NEU + 0.15) / 0.6) - DEN</span>

<span class="sd">    where:</span>

<span class="sd">        * LFI &lt; -0.9 = 0</span>
<span class="sd">        * NaNs are filled with 0</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe to which LFI should be added.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raises an error if neither NEU nor DEN are provided</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Returns the dataframe with LFI as a new column</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="s2">"NEU"</span><span class="p">,</span> <span class="s2">"DEN"</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">"LFI"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.95</span> <span class="o">-</span> <span class="p">((</span><span class="n">df</span><span class="p">[</span><span class="s2">"NEU"</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.15</span><span class="p">)</span> <span class="o">/</span> <span class="mf">0.6</span><span class="p">)</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">"DEN"</span><span class="p">]</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">"LFI"</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.9</span><span class="p">,</span> <span class="s2">"LFI"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">"LFI"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">"LFI"</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Not possible to generate LFI as NEU and/or DEN are not present in dataset."</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="calculate_RAVG"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.calculate_RAVG">[docs]</a><span class="k">def</span> <span class="nf">calculate_RAVG</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Calculates RAVG from RDEP, RMED, RSHA according to the following formula::</span>

<span class="sd">        RAVG = AVG(RDEP, RMED, RSHA), if at least two of those are present</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe to which RAVG should be added.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raises an error if one or less resistivity curves are found</span>
<span class="sd">            in the provided dataframe</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Returns the dataframe with RAVG as a new column</span>
<span class="sd">    """</span>
    <span class="n">r_curves</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"RDEP"</span><span class="p">,</span> <span class="s2">"RMED"</span><span class="p">,</span> <span class="s2">"RSHA"</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_curves</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">"RAVG"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">r_curves</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Not possible to generate RAVG as there is only one or none resistivities curves in dataset."</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="calculate_VPVS"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.calculate_VPVS">[docs]</a><span class="k">def</span> <span class="nf">calculate_VPVS</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Calculates VPVS from ACS and AC according to the following formula::</span>

<span class="sd">        VPVS = ACS / AC</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe to which VPVS should be added.</span>


<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raises an error if neither ACS nor AC are found</span>
<span class="sd">            in the provided dataframe</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Returns the dataframe with VPVS as a new column</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="s2">"AC"</span><span class="p">,</span> <span class="s2">"ACS"</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">"VPVS"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">"ACS"</span><span class="p">]</span> <span class="o">/</span> <span class="n">df</span><span class="p">[</span><span class="s2">"AC"</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Not possible to generate VPVS as both necessary curves (AC and"</span>
            <span class="s2">" ACS) are not present in dataset."</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="calculate_PR"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.calculate_PR">[docs]</a><span class="k">def</span> <span class="nf">calculate_PR</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Calculates PR from VP and VS or ACS and AC (if VP and VS are not found)</span>
<span class="sd">    according to the following formula::</span>

<span class="sd">        PR = (VP ** 2 - 2 * VS ** 2) / (2 * (VP ** 2 - VS ** 2))</span>

<span class="sd">    where:</span>

<span class="sd">        * VP = 304.8 / AC</span>
<span class="sd">        * VS = 304.8 / ACS</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe to which PR should be added.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raises an error if none of AC, ACS, VP or VS are found</span>
<span class="sd">            in the provided dataframe</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Returns the dataframe with PR as a new column</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">([</span><span class="s2">"VP"</span><span class="p">,</span> <span class="s2">"VS"</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="s2">"AC"</span><span class="p">,</span> <span class="s2">"ACS"</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_VP</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calculate_VS</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"Not possible to generate PR as none of the neccessary curves "</span>
                <span class="s2">"(AC, ACS or VP, VS) are present in the dataset."</span>
            <span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">"PR"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"VP"</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">df</span><span class="p">[</span><span class="s2">"VS"</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
        <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"VP"</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">"VS"</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="calculate_VP"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.calculate_VP">[docs]</a><span class="k">def</span> <span class="nf">calculate_VP</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Calculates VP (if AC is found) according to the following formula::</span>

<span class="sd">        VP = 304.8 / AC</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe to which PR should be added.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raises an error if AC is not found in the provided dataframe</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Returns the dataframe with VP as a new column</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="s2">"AC"</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">"VP"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">304.8</span> <span class="o">/</span> <span class="n">df</span><span class="p">[</span><span class="s2">"AC"</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Not possible to generate VP as AC is not present in dataset."</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="calculate_VS"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.calculate_VS">[docs]</a><span class="k">def</span> <span class="nf">calculate_VS</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""</span>
<span class="sd">    Calculates VS (if ACS is found) according to the following formula::</span>

<span class="sd">        VS = 304.8 / ACS</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe to which PR should be added.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raises an error if ACS is not found in the provided dataframe</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Returns the dataframe with VS as a new column</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="s2">"ACS"</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">"VS"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">304.8</span> <span class="o">/</span> <span class="n">df</span><span class="p">[</span><span class="s2">"ACS"</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Not possible to generate VS as ACS is not present in dataset."</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="c1"># VSH is a very complex function to disabling flake complexity check on this</span>
<div class="viewcode-block" id="calculate_VSH"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.calculate_VSH">[docs]</a><span class="k">def</span> <span class="nf">calculate_VSH</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>  <span class="c1"># noqa: C901</span>
    <span class="sd">"""</span>
<span class="sd">    Calculates the VSH curve based off the GR curve and the type of formation</span>
<span class="sd">    defined in the GROUP column, as follows::</span>

<span class="sd">        VSH = (GR - GR_ss) / (GR_sh_Gp_f - GR_ss)</span>

<span class="sd">    where:</span>

<span class="sd">        - GR_ss = The 5th quantile (quant_ss - value can be changed via the</span>
<span class="sd">            kwargs) of each defined system (some systems are grouped if relevant)</span>
<span class="sd">        - GR_sh_Gp_f = Shale formation groups are grouped by GROUP and a rolling</span>
<span class="sd">            window calculation is applied to each group (window size is</span>
<span class="sd">            determined by the 'window' kwarg and quantile is determined by</span>
<span class="sd">            the quant_sh kwarg - these default to 2500 and 0.95 respectively). A</span>
<span class="sd">            savgol filter of windowlength min(501, number_of_non_nans // 2)</span>
<span class="sd">            and polynomial order 3 is then applied to the rolling quantile group.</span>
<span class="sd">            Note that the filter is **ONLY** applied if there is enough non NaN</span>
<span class="sd">            data present in the rolling quantiles. This limit is currently set to</span>
<span class="sd">            10. If after this filter is applied the group still has np.NaNs, linear</span>
<span class="sd">            interpolation is applied to fill the gaps (provided there is data</span>
<span class="sd">            that can be used to interpolate). GR_sh_Gp_f represents</span>
<span class="sd">            this final result for all groups.</span>

<span class="sd">    Note:</span>
<span class="sd">        This calculation is performed **per well**! Formation tops column in input</span>
<span class="sd">        df is forced into upper case for generalization.</span>

<span class="sd">    Warning:</span>
<span class="sd">        If a calculation fails for one well, the well will be skipped and</span>
<span class="sd">        calculation continuous for the next well.</span>

<span class="sd">    Note:</span>
<span class="sd">        If no mapping could be made to the pre-defined systems, the GROUP will</span>
<span class="sd">        be labeled as 'other'.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe to which VSH should be added.</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        groups_column_name (str): The name of the column containing</span>
<span class="sd">            group names. Defaults to 'GROUP'</span>
<span class="sd">        formations_column_name (str): The name of the column containing</span>
<span class="sd">            formation names. Defaults to 'FORMATION'</span>
<span class="sd">        id_column (str): The name of the well ID column to use for grouping</span>
<span class="sd">            the dataset by well. Defaults to 'well_name'</span>
<span class="sd">        rolling_window_size (int): The size of the window to use for the rolling quantile</span>
<span class="sd">            calculation of the shale formation groups. Defaults to 2000 or</span>
<span class="sd">            len(group_df) // 2 if less than 2000 where group_df is the dataframe</span>
<span class="sd">            for the specific shale formation group.</span>
<span class="sd">        filter_window_size (int): The size of the window to use for the savgol</span>
<span class="sd">            filtering. Defaults to 501 or odd(len(filter_series) // 2) if less</span>
<span class="sd">            than 501 where filter_series is the series of rolling quantiles to</span>
<span class="sd">            be filtered by the savgol filter. **MUST** be odd (if an even int is</span>
<span class="sd">            provided, the code automatically converts it to an odd window size)</span>
<span class="sd">        quant_ss (float): The quantile to use for each age group in the sand</span>
<span class="sd">            formation groups calculation (GR_ss). Defaults to 0.02</span>
<span class="sd">        quant_sh (float): The quantile to use in the rolling quantile calculation</span>
<span class="sd">            of the shale formation groups. Defaults to 0.95</span>
<span class="sd">        NHR_ss_threshold (float): The sand point threshold above which the</span>
<span class="sd">            Nordland, Hordaland &amp; Rogaland (NHR) groups should be merged. The threshold</span>
<span class="sd">            is represented as the ratio between the group specific sandpoint</span>
<span class="sd">            (quant_ss) and the NHR system sand point (quant_ss calculated across all</span>
<span class="sd">            three groups - N, H &amp; R). If this ratio is greater than this threshold</span>
<span class="sd">            the groups are merged according to the following strategy:</span>

<span class="sd">                1. Nordland's sandpoint is set to Hordaland's sandpoint. If there</span>
<span class="sd">                    is no Hordaland group present in the well it falls back to</span>
<span class="sd">                    being set to the NHR system sandpoint.</span>
<span class="sd">                2. Hordaland's sandpoint is set to the average of Nordland and</span>
<span class="sd">                    Rogaland's sandpoints</span>
<span class="sd">                3. Rogaland's sandpoint is set to Hordaland's sandpoint. If there</span>
<span class="sd">                    is no Hordaland group present in the well it falls back to</span>
<span class="sd">                    being set to the NHR system sandpoint.</span>

<span class="sd">        non_shale_window_threshold (float): A threshold for the following ratio::</span>

<span class="sd">                NSWT = GR_ss / (GR_sh_Gp_f * (GR_sh_Gp_f - GR_ss))</span>

<span class="sd">            This threshold causes the VSH_AUTO calculation to linearly interpolate</span>
<span class="sd">            between local minimas in the GR_sh_Gp_f curve whenever the above ratio</span>
<span class="sd">            goes above the user provided threshold. Initial user testing suggests</span>
<span class="sd">            a threshold of 0.015 is a good starting point.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Returns the dataframe with VSH as a new column</span>
<span class="sd">    """</span>
    <span class="n">g_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"groups_column_name"</span><span class="p">,</span> <span class="s2">"GROUP"</span><span class="p">)</span>
    <span class="n">f_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"formations_column_name"</span><span class="p">,</span> <span class="s2">"FORMATION"</span><span class="p">)</span>
    <span class="n">rolling_window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"rolling_window_size"</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
    <span class="n">filter_window_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"filter_window_size"</span><span class="p">,</span> <span class="mi">501</span><span class="p">)</span>
    <span class="n">quant_ss</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"quant_ss"</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">)</span>
    <span class="n">quant_sh</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"quant_sh"</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">)</span>
    <span class="n">id_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"id_column"</span><span class="p">,</span> <span class="s2">"well_name"</span><span class="p">)</span>
    <span class="n">NHR_ss_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"NHR_ss_threshold"</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
    <span class="n">non_shale_window_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"non_shale_window_threshold"</span><span class="p">,</span> <span class="mf">0.015</span><span class="p">)</span>
    <span class="n">system_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">"Nordland"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"NORDLAND GP"</span><span class="p">],</span>
        <span class="s2">"Hordaland"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"HORDALAND GP"</span><span class="p">],</span>
        <span class="s2">"Rogaland"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"ROGALAND GP"</span><span class="p">],</span>
        <span class="s2">"preCretaceous"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"UNKNOWN GP"</span><span class="p">],</span>
        <span class="s2">"Cretaceous"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"SHETLAND GP"</span><span class="p">,</span> <span class="s2">"CROMER KNOLL GP"</span><span class="p">],</span>
        <span class="s2">"Jurassic"</span><span class="p">:</span> <span class="p">[</span>
            <span class="s2">"VIKING GP"</span><span class="p">,</span>
            <span class="s2">"TYNE GP"</span><span class="p">,</span>
            <span class="s2">"BOKNFJORD GP"</span><span class="p">,</span>
            <span class="s2">"FANGST GP"</span><span class="p">,</span>
            <span class="s2">"BAT GP"</span><span class="p">,</span>
            <span class="s2">"VESTLAND GP"</span><span class="p">,</span>
            <span class="s2">"DUNLIN GP"</span><span class="p">,</span>
            <span class="s2">"BRENT GP"</span><span class="p">,</span>
            <span class="s2">"FLADEN GP"</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">}</span>
    <span class="n">mapping_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">val</span><span class="p">:</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">system_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_calculate_VSH</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="c1"># Reset index and preserve old one to be merged back later</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">old_index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"index"</span><span class="p">)</span>
        <span class="c1"># Ensure only using legal GR values</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">"GR"</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">"GR"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># Calculate GR_ss</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">"Age"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">g_col</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">)</span>
        <span class="c1"># Where not defined in mapping_dict consider as other</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">"Age"</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span> <span class="s2">"Age"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Other"</span>
        <span class="n">system_quantiles</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">"Age"</span><span class="p">)[</span><span class="s2">"GR"</span><span class="p">]</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">quant_ss</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">"Age"</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">system_quantiles</span><span class="p">)</span>
        <span class="c1"># Need to ensure index is continuous after the groupby to prevent</span>
        <span class="c1"># different sections of the well being taken into account for the</span>
        <span class="c1"># calculation of quant_ss</span>
        <span class="n">system_quantiles</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">age</span><span class="p">,</span> <span class="n">age_series</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">"Age"</span><span class="p">)[</span><span class="s2">"GR"</span><span class="p">]:</span>
            <span class="c1"># Ensure groups are continuous in index</span>
            <span class="n">sub_ages</span> <span class="o">=</span> <span class="n">age_series</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                <span class="n">age_series</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sub_age_series</span> <span class="ow">in</span> <span class="n">sub_ages</span><span class="p">:</span>
                <span class="n">sub_age_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">age</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sub_age_series</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s2">"AGE_GROUPS"</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_age_name</span>
                <span class="n">system_quantiles</span><span class="p">[</span><span class="n">sub_age_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_age_series</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">quant_ss</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">"AGE_GROUPS"</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">system_quantiles</span><span class="p">)</span>

        <span class="c1"># Need to handle Nordland, Hordaland &amp; Rogaland separetely (see docstring)</span>
        <span class="n">nhr_quant_ss</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
            <span class="n">df</span><span class="p">[</span><span class="n">g_col</span><span class="p">]</span>
            <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">"|"</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">"NORDLAND"</span><span class="p">,</span> <span class="s2">"ROGALAND"</span><span class="p">,</span> <span class="s2">"HORDALAND"</span><span class="p">]),</span> <span class="n">na</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s2">"GR"</span><span class="p">,</span>
        <span class="p">]</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">quant_ss</span><span class="p">)</span>
        <span class="n">nord_quant_ss</span> <span class="o">=</span> <span class="n">system_quantiles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"Nordland"</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">hord_quant_ss</span> <span class="o">=</span> <span class="n">system_quantiles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"Hordaland"</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">roga_quant_ss</span> <span class="o">=</span> <span class="n">system_quantiles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"Rogaland"</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">nord_quant_ss</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nord_quant_ss</span> <span class="o">/</span> <span class="n">nhr_quant_ss</span> <span class="o">&gt;</span> <span class="n">NHR_ss_threshold</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hord_quant_ss</span><span class="p">):</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">"Age"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"Nordland"</span><span class="p">,</span> <span class="s2">"GR_ss"</span><span class="p">]</span> <span class="o">=</span> <span class="n">hord_quant_ss</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">"Age"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"Nordland"</span><span class="p">,</span> <span class="s2">"GR_ss"</span><span class="p">]</span> <span class="o">=</span> <span class="n">nhr_quant_ss</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hord_quant_ss</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">hord_quant_ss</span> <span class="o">/</span> <span class="n">nhr_quant_ss</span> <span class="o">&gt;</span> <span class="n">NHR_ss_threshold</span><span class="p">:</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">"Age"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"Hordaland"</span><span class="p">,</span> <span class="s2">"GR_ss"</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">nord_quant_ss</span><span class="p">,</span> <span class="n">roga_quant_ss</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">roga_quant_ss</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">roga_quant_ss</span> <span class="o">/</span> <span class="n">nhr_quant_ss</span> <span class="o">&gt;</span> <span class="n">NHR_ss_threshold</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hord_quant_ss</span><span class="p">):</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">"Age"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"Rogaland"</span><span class="p">,</span> <span class="s2">"GR_ss"</span><span class="p">]</span> <span class="o">=</span> <span class="n">hord_quant_ss</span>

        <span class="c1"># Also need to handle draupne pseudo group separately</span>
        <span class="c1"># Make all groups in draupne formation have same GR_ss value from</span>
        <span class="c1"># the last group in the draupne formation</span>
        <span class="k">if</span> <span class="n">f_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">f_col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">"DRAUPNE"</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">"boolean"</span><span class="p">)</span>
            <span class="n">groups_in_draupne</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">g_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups_in_draupne</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">last_group</span> <span class="o">=</span> <span class="n">groups_in_draupne</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="s2">"GR_ss"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">df</span><span class="p">[</span><span class="n">g_col</span><span class="p">]</span> <span class="o">==</span> <span class="n">last_group</span><span class="p">,</span> <span class="s2">"GR_ss"</span>
                <span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Calculate GR_sh_Gp_f</span>
        <span class="k">for</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">group_series</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">g_col</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span>
            <span class="s2">"GR"</span>
        <span class="p">]:</span>
            <span class="c1"># Ensure groups are continuous in index</span>
            <span class="n">sub_groups</span> <span class="o">=</span> <span class="n">group_series</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                <span class="n">group_series</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sub_group_series</span> <span class="ow">in</span> <span class="n">sub_groups</span><span class="p">:</span>
                <span class="c1"># First calculate the quantiles</span>
                <span class="n">window_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">rolling_window_size</span><span class="p">,</span> <span class="n">sub_group_series</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">rolling_quantiles</span> <span class="o">=</span> <span class="n">sub_group_series</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span>
                    <span class="n">window</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span>
                    <span class="n">min_periods</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span>
                    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">quant_sh</span><span class="p">)</span>
                <span class="c1"># Then apply savgol_filter to non-nans</span>
                <span class="n">non_nan_index</span> <span class="o">=</span> <span class="n">rolling_quantiles</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">non_nan_index</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="n">windowLength</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="n">filter_window_size</span><span class="p">,</span>
                        <span class="n">rolling_quantiles</span><span class="p">[</span><span class="n">non_nan_index</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># windowLength must be odd so enforcing this below</span>
                    <span class="n">windowLength</span> <span class="o">+=</span> <span class="n">windowLength</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">rolling_quantiles</span><span class="p">[</span><span class="n">non_nan_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span>
                        <span class="n">rolling_quantiles</span><span class="p">[</span><span class="n">non_nan_index</span><span class="p">],</span> <span class="n">windowLength</span><span class="p">,</span> <span class="mi">3</span>
                    <span class="p">)</span>

                <span class="c1"># Then linear interpolate if there are points that can be used to interpolate (i.e. non_nan values)</span>
                <span class="k">if</span> <span class="n">rolling_quantiles</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Interpolate nan values using the index as x and curve as y</span>
                    <span class="n">rolling_quantiles</span> <span class="o">=</span> <span class="n">rolling_quantiles</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
                        <span class="n">method</span><span class="o">=</span><span class="s2">"index"</span><span class="p">,</span> <span class="n">limit_direction</span><span class="o">=</span><span class="s2">"both"</span>
                    <span class="p">)</span>

                <span class="c1"># Assign back to original df</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rolling_quantiles</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s2">"GR_sh_Gp_f"</span><span class="p">]</span> <span class="o">=</span> <span class="n">rolling_quantiles</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rolling_quantiles</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s2">"INDEX_GROUPS"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                        <span class="n">rolling_quantiles</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s2">"INDEX_GROUPS"</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">group_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">"</span>

        <span class="c1"># Set curves to nan when GR is nan</span>
        <span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">,</span> <span class="s2">"GR_sh_Gp_f"</span><span class="p">]:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">"GR"</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span> <span class="n">curve</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Check for non-shale windows</span>
        <span class="k">if</span> <span class="n">non_shale_window_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># Define parameters to work with</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">"GR_sh_Gp_f_NS"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">"GR_sh_Gp_f"</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">"VSH_AUT_INTER_RATIO"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span>
                <span class="n">df</span><span class="p">[</span><span class="s2">"GR_sh_Gp_f"</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"GR_sh_Gp_f"</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">"VSH_AUT_INTER_RATIO"</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">non_shale_window_threshold</span>

            <span class="c1"># Define areas where non_shale_window_threshold was violated</span>
            <span class="n">threshold_violations</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">get_violation_indices</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">threshold_violations</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="c1"># Check if well section contains a threshold violation</span>
                <span class="c1"># if not continue to next section</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">"first"</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">"last"</span><span class="p">]</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="s2">"INDEX_GROUPS"</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="c1"># An index to determine whether to draw a vertical line</span>
                <span class="c1"># or interpolate with index - reset for each threshold violation</span>
                <span class="n">vertical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Threshold violation applies to only one group so apply</span>
                    <span class="c1"># group specific logic</span>
                    <span class="n">group</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">"INDEX_GROUPS"</span><span class="p">]</span> <span class="o">==</span> <span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">group_start</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">group_end</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">group_start</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">==</span> <span class="n">group_end</span><span class="p">:</span>
                        <span class="c1"># If the threshold violation applies for the entire group</span>
                        <span class="c1"># only, then just interpolate between before and after</span>
                        <span class="c1"># group. This accounts for step changes due to rolling window changes</span>
                        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># start of the well</span>
                            <span class="n">inter_start</span> <span class="o">=</span> <span class="n">group_start</span>
                            <span class="n">inter_end</span> <span class="o">=</span> <span class="n">vertical</span> <span class="o">=</span> <span class="n">group_end</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">elif</span> <span class="n">end</span> <span class="o">==</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># end of the well</span>
                            <span class="n">inter_start</span> <span class="o">=</span> <span class="n">vertical</span> <span class="o">=</span> <span class="n">group_start</span> <span class="o">-</span> <span class="mi">1</span>
                            <span class="n">inter_end</span> <span class="o">=</span> <span class="n">group_end</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">inter_start</span> <span class="o">=</span> <span class="n">group_start</span> <span class="o">-</span> <span class="mi">1</span>
                            <span class="n">inter_end</span> <span class="o">=</span> <span class="n">group_end</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">group_end</span> <span class="o">-</span> <span class="n">group_start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
                        <span class="c1"># If the threshold violation applies for the majority of the</span>
                        <span class="c1"># group attempt to reduce to sand point curve and recalculate</span>
                        <span class="c1"># the threshold violation length.</span>
                        <span class="n">group</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s2">"GR"</span><span class="p">]</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">quant_ss</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="n">group</span><span class="p">[</span><span class="s2">"VSH_AUT_INTER_RATIO"</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span>
                            <span class="n">group</span><span class="p">[</span><span class="s2">"GR_sh_Gp_f"</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s2">"GR_sh_Gp_f"</span><span class="p">]</span> <span class="o">-</span> <span class="n">group</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">])</span>
                        <span class="p">)</span>
                        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s2">"GR_ss"</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">]</span>
                        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s2">"VSH_AUT_INTER_RATIO"</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span>
                            <span class="s2">"VSH_AUT_INTER_RATIO"</span>
                        <span class="p">]</span>
                        <span class="c1"># Get new threshold start and end:</span>
                        <span class="n">group_mask</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">group</span><span class="p">[</span><span class="s2">"VSH_AUT_INTER_RATIO"</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">non_shale_window_threshold</span>
                        <span class="p">)</span>
                        <span class="c1"># If no more threshold violations then continue</span>
                        <span class="k">if</span> <span class="n">group_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="n">group_violations</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">get_violation_indices</span><span class="p">(</span><span class="n">group_mask</span><span class="p">)</span>
                        <span class="n">inter_start</span><span class="p">,</span> <span class="n">inter_end</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">group_violations</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s2">"first"</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="s2">"last"</span><span class="p">]</span>
                            <span class="c1"># Calculate inter_start and inter_end with inflection point</span>
                            <span class="c1"># algorithm</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">inflection_points</span><span class="p">(</span>
                                <span class="n">df</span><span class="p">,</span> <span class="s2">"GR_sh_Gp_f"</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>
                            <span class="p">)</span>
                            <span class="n">inter_start</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">inter_end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                        <span class="n">start_na</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">inter_start</span><span class="p">)</span>
                        <span class="n">end_na</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">inter_end</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">start_na</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="n">end_na</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="n">inter_start</span> <span class="o">=</span> <span class="n">group_start</span> <span class="o">-</span> <span class="mi">1</span>
                            <span class="n">inter_end</span> <span class="o">=</span> <span class="n">group_end</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">elif</span> <span class="n">start_na</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="n">vertical</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inter_end</span><span class="p">,</span> <span class="s2">"GR_sh_Gp_f"</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
                            <span class="n">inter_start</span> <span class="o">=</span> <span class="n">group_start</span>
                            <span class="n">inter_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">inter_end</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">end_na</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="n">inter_end</span> <span class="o">=</span> <span class="n">group_end</span>
                            <span class="n">vertical</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inter_start</span><span class="p">,</span> <span class="s2">"GR_sh_Gp_f"</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
                            <span class="n">inter_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">inter_start</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">vertical</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                                <span class="n">inter_start</span> <span class="o">+</span> <span class="n">inter_end</span><span class="p">,</span> <span class="s2">"GR_sh_Gp_f"</span>
                            <span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
                            <span class="n">inter_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">inter_start</span><span class="p">)</span>
                            <span class="n">inter_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">inter_end</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">inter_start</span><span class="p">,</span> <span class="n">inter_end</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">inflection_points</span><span class="p">(</span>
                            <span class="n">df</span><span class="p">,</span> <span class="s2">"GR_sh_Gp_f"</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>
                        <span class="p">)</span>

                    <span class="c1"># If only one inflection point, draw a vertical line</span>
                    <span class="n">inter_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">([</span><span class="n">inter_start</span><span class="p">,</span> <span class="n">inter_end</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">inter_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inter_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">inter_start</span> <span class="o">=</span> <span class="n">group_start</span>
                            <span class="n">vertical</span> <span class="o">=</span> <span class="n">inter_end</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">inter_end</span> <span class="o">=</span> <span class="n">group_end</span>
                            <span class="n">vertical</span> <span class="o">=</span> <span class="n">inter_start</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Threshold violation spans multiple groups. Just find</span>
                    <span class="c1"># start and end points for interpolation based purely</span>
                    <span class="c1"># on gradient changes</span>
                    <span class="n">inter_start</span><span class="p">,</span> <span class="n">inter_end</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">inflection_points</span><span class="p">(</span>
                        <span class="n">df</span><span class="p">,</span> <span class="s2">"GR_sh_Gp_f"</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>
                    <span class="p">)</span>

                    <span class="c1"># If only one inflection point, draw a vertical line</span>
                    <span class="n">inter_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">([</span><span class="n">inter_start</span><span class="p">,</span> <span class="n">inter_end</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">inter_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inter_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">inter_start</span> <span class="o">=</span> <span class="n">start</span>
                            <span class="n">vertical</span> <span class="o">=</span> <span class="n">inter_end</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">inter_end</span> <span class="o">=</span> <span class="n">end</span>
                            <span class="n">vertical</span> <span class="o">=</span> <span class="n">inter_start</span>

                <span class="c1"># Bound indices to not go beyond the scope of the dataframe</span>
                <span class="k">if</span> <span class="n">inter_start</span> <span class="o">&lt;</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">inter_start</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">inter_end</span> <span class="o">&gt;</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">inter_end</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">new_GR_sh_Gp_f</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inter_start</span><span class="p">:</span><span class="n">inter_end</span><span class="p">,</span> <span class="s2">"GR_sh_Gp_f_NS"</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># If vertical is not nan, it means we need to draw a vertical line</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vertical</span><span class="p">):</span>
                    <span class="n">new_GR_sh_Gp_f</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">new_GR_sh_Gp_f</span> <span class="o">=</span> <span class="n">new_GR_sh_Gp_f</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">"index"</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Vertical should always be between inter_start and inter_end</span>
                    <span class="n">vertical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">vertical</span><span class="p">,</span> <span class="n">inter_start</span><span class="p">,</span> <span class="n">inter_end</span><span class="p">)</span>
                    <span class="n">new_GR_sh_Gp_f</span><span class="o">.</span><span class="n">loc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_GR_sh_Gp_f</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">vertical</span><span class="p">]</span>

                <span class="c1"># Last check, if the new NS curve is less than the original</span>
                <span class="c1"># filtered rolling window curve then discard the interpolation</span>
                <span class="n">original</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inter_start</span><span class="p">:</span><span class="n">inter_end</span><span class="p">,</span> <span class="s2">"GR_sh_Gp_f_NS"</span><span class="p">]</span>
                <span class="n">check_mask</span> <span class="o">=</span> <span class="n">new_GR_sh_Gp_f</span> <span class="o">&lt;</span> <span class="n">original</span>
                <span class="k">if</span> <span class="n">check_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_GR_sh_Gp_f</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">check_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">original</span>

                <span class="c1"># Assign back to original df</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">new_GR_sh_Gp_f</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s2">"GR_sh_Gp_f_NS"</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_GR_sh_Gp_f</span>

        <span class="c1"># If after all this work the synthetic curves still have nans, no other choice than</span>
        <span class="c1"># to interpolate with ffill and bfill (only where GR is not na)</span>
        <span class="n">curves</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">"GR_sh_Gp_f_NS"</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">curves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"GR_sh_Gp_f_NS"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"GR_sh_Gp_f"</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">df</span><span class="p">[</span><span class="n">curve</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">curve</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">curve</span><span class="p">]</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
                    <span class="n">method</span><span class="o">=</span><span class="s2">"index"</span><span class="p">,</span> <span class="n">limit_direction</span><span class="o">=</span><span class="s2">"both"</span>
                <span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">"GR"</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span> <span class="n">curves</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Finally put it all together</span>
        <span class="k">if</span> <span class="s2">"GR_sh_Gp_f_NS"</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">"VSH"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"GR"</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"GR_sh_Gp_f_NS"</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">"VSH"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"GR"</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">"GR_sh_Gp_f"</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">"GR_ss"</span><span class="p">])</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">"VSH"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">"VSH"</span><span class="p">]</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># And remap the old index to restore df to original state</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">old_index</span><span class="p">)</span>

        <span class="c1"># Drop unused columns</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">"Age"</span><span class="p">,</span>
                <span class="s2">"GR_ss"</span><span class="p">,</span>
                <span class="s2">"GR_sh_Gp_f"</span><span class="p">,</span>
                <span class="s2">"GR_sh_Gp_f_NS"</span><span class="p">,</span>
                <span class="s2">"VSH_AUT_INTER_RATIO"</span><span class="p">,</span>
                <span class="s2">"INDEX_GROUPS"</span><span class="p">,</span>
                <span class="s2">"AGE_GROUPS"</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">errors</span><span class="o">=</span><span class="s2">"ignore"</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">df</span>

    <span class="c1"># First check we have all necessary information</span>
    <span class="n">required_cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s2">"GR"</span><span class="p">,</span> <span class="n">g_col</span><span class="p">,</span> <span class="n">id_column</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">f_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">required_cols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f_col</span><span class="p">)</span>
    <span class="n">provided_cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">required_cols</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">provided_cols</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"Not possible to generate VSH as one or many of the necessary "</span>
            <span class="sa">f</span><span class="s2">"columns </span><span class="si">{</span><span class="n">required_cols</span> <span class="o">-</span> <span class="n">provided_cols</span><span class="si">}</span><span class="s2"> are not present in the "</span>
            <span class="s2">"provided dataframe."</span>
        <span class="p">)</span>
    <span class="c1"># Standardize g_col</span>
    <span class="n">df</span><span class="p">[</span><span class="n">g_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">map_formation_and_group</span><span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">g_col</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">utilities</span><span class="o">.</span><span class="n">standardize_group_formation_name</span><span class="p">)</span>
    <span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># If no formations_columns_name was provided, warn the user but continue</span>
    <span class="k">if</span> <span class="n">f_col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">"No formations_column_name was provided to the calculate_VSH "</span>
            <span class="s2">"function. It is therefore not possible to calculate VSH_AUTO with "</span>
            <span class="s2">"some custom formation mappings. The function will revert to using "</span>
            <span class="s2">" the groups_column_name provided but the calculated VSH_AUTO column"</span>
            <span class="s2">" will not be similar to the one generated in Techlog!"</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Standardize f_col for later use</span>
        <span class="n">df</span><span class="p">[</span><span class="n">f_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">map_formation_and_group</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="n">f_col</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">utilities</span><span class="o">.</span><span class="n">standardize_group_formation_name</span><span class="p">)</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Process per well</span>
    <span class="n">well_names</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">id_column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">well_names</span><span class="p">:</span>
        <span class="n">well_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">id_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">well</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">well_df</span> <span class="o">=</span> <span class="n">_calculate_VSH</span><span class="p">(</span><span class="n">well_df</span><span class="p">)</span>
        <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">well_df</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="add_vertical_depths"><a class="viewcode-back" href="../../../akerbp.mlpet.feature_engineering.html#akerbp.mlpet.feature_engineering.add_vertical_depths">[docs]</a><span class="k">def</span> <span class="nf">add_vertical_depths</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">"""Add vertical depths, i.e. TVDKB, TVDSS and TVDBML, to the input dataframe.</span>
<span class="sd">    This function relies on a keyword argument for a vertical depth mapper dictionary,</span>
<span class="sd">    created by querying CDF at discrete points along the wellbore for each well.</span>
<span class="sd">    To map the vertical depths along the entire wellbore, the data in the dictionary is interpolated by using the measured depth</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): pandas dataframe to add vertical depths to</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        md_column (str): identifier for the measured depth column in the provided dataframe</span>
<span class="sd">            Defaults to None</span>
<span class="sd">        id_column (str): identifier for the well column in the provided dataframe</span>
<span class="sd">            Defaults to None</span>
<span class="sd">        vertical_depths_mapper (dict): dictionary containing vertical- and measured depths</span>
<span class="sd">            queried from CDF at discrete points along the wellbore for each well. For example::</span>

<span class="sd">                vertical_depths_mapper = {</span>
<span class="sd">                    "25/6-2": {</span>
<span class="sd">                        "TVDKB": [0.0, 145.0, 149.9998, ...],</span>
<span class="sd">                        "TVDSS": [-26.0, 119.0, 123.9998, ...],</span>
<span class="sd">                        "TVDBML": [-145.0, 0.0, 4.999799999999993, ...],</span>
<span class="sd">                        "MD": [0.0, 145.0, 150.0, ...]</span>
<span class="sd">                    }</span>
<span class="sd">                }</span>

<span class="sd">            Defaults to an empty dictionary, i.e. {}</span>

<span class="sd">        client (CogniteClient): client for querying vertical depths from CDF if a mapping dictionary is not provided</span>
<span class="sd">            Defaults to None</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: dataframe with additional column for TVDKB, TVDSS and TVDBML</span>
<span class="sd">    """</span>
    <span class="n">md_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"md_column"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">id_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"id_column"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">client</span><span class="p">:</span> <span class="n">CogniteClient</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"client"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">vertical_depths_mapper</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">"vertical_depths_mapper"</span><span class="p">,</span> <span class="p">{}</span>
    <span class="p">)</span>
    <span class="n">well_names</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">id_column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertical_depths_mapper</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">vertical_depths_mapper</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">get_vertical_depths</span><span class="p">(</span>
                <span class="n">well_names</span><span class="o">=</span><span class="n">well_names</span><span class="p">,</span> <span class="n">client</span><span class="o">=</span><span class="n">client</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"Neither a vertical depths mapping nor a cognite client is provided. Not able to add vertical depths to dataset"</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">md_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">id_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertical_depths_mapper</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="p">):</span>
        <span class="n">df_</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">well</span> <span class="ow">in</span> <span class="n">vertical_depths_mapper</span><span class="p">:</span>
            <span class="n">md_interpolate</span> <span class="o">=</span> <span class="n">df_</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_</span><span class="p">[</span><span class="n">id_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">well</span><span class="p">,</span> <span class="n">md_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="n">depths</span> <span class="o">=</span> <span class="n">vertical_depths_mapper</span><span class="p">[</span><span class="n">well</span><span class="p">]</span>
            <span class="n">md</span> <span class="o">=</span> <span class="n">depths</span><span class="p">[</span><span class="s2">"MD"</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">depths</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">"MD"</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">vertical_depth</span> <span class="o">=</span> <span class="n">depths</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">md</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">vertical_depth</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">"extrapolate"</span><span class="p">)</span>
                    <span class="n">interpolated_vertical_depth</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">md_interpolate</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">w</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">"Interpolating </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> for well </span><span class="si">{</span><span class="n">well</span><span class="si">}</span><span class="s2"> triggered a "</span>
                        <span class="sa">f</span><span class="s2">"runtime warning: </span><span class="si">{</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">"</span>
                    <span class="p">)</span>
                <span class="n">df_</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df_</span><span class="p">[</span><span class="n">id_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">well</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolated_vertical_depth</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">"The vertical depths could not be added to the provided dataframe"</span>
            <span class="s2">" because some keyword arugments were missing!"</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">df_</span></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Aker BP
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    </body>
</html>