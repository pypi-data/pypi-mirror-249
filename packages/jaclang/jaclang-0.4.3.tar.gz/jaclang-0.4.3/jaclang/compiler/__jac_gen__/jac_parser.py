# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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crGPXOwjF/vIxT5ysY9c7CMX+8jFPnKxj1zsIxf7yMU+crGPXOwjF/vIxT5ysY9c7CMX+8jFPnKxj1zsIxf7yMU+crGPXOwjF/vIxT5ysY9c7CMX+8jFPnKxj1zsIxf7yMU+crGPXOwjF/vIxT5ysY9c7CMX+8jFPnKxj1zsIxf7yMU+crGPXOwjF/vIxT5ysY9c7CMX+8jFPnKxj1zsIxf7irn47bnF2lfnDZwZHz8zPv4jHh//Tvx0i6vvr809dfbOluE/CctwxP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txP5txG5nxG5nxG5nxG5nxP5txP5txG5nxG5uxG5nxG5uxP5txP5mxI5txI5txK5zxK5zxK5zxB5txB5txK5sxK5zxK5sxK5sxB50xB5txB50xB50VNyS+v+Km1ZlHTcPxA1CWcc3Bn6psD4qpPNvF2K6OyorLw6AFapmxWwiFArqvCAIy4m+csKunDAoJyjKuQDLieFynlrllIRyIrOciC4n2ssJ83Iis5ziUc7TvJwYLieKyomicgpLOSFSTmyUc1mVE32z6o7Ky8M6mOEfnaEOZqiDGf4pGepghjqY4dfNcGdleAAy3HUZ7uQMdTBDHczwZMhQBzM8NTLUwQwPaoYHIEMdzFAHMzyoGepghjqYoQ5mqIMZ6mCGOpihDmaogxnqYIand4anfoY6mKEOZngyZKiDGZ58GZ58GepghjqYoQ5mqIMZ6mCGyzDDUzhDHczwhM5QBzPUwQx1MEMdzFAHM9TBDHUwQx3MUAcz1MEMdTBDHcxQBzPUwQx1MEMdzHDBZgiIDHUwQ1hlqIMZ6mCGOpihDmaogxnqYIY6mKEOZqiDGepghjqYoQ5mqIMZ6mCGOpihDmaogxnqYIY6mKEOZqiDGepghjqYoQ5mqIMZ6mCGOpihDmaogxnqYIY6mCnGb0VB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APoQAH0IgD4EQB8CoA8B0IcA6EMA9CEA+hAAfQiAPgRAHwKgDwHQhwDoQwD0IQD6EAB9CIA+BEAfAqAPAdCHAOhDAPQhAPoQAH0IgD4EQB8CoA8B0IcA6EMA9CEA+hAAfQiAPgRAHwKgDwHQhwDoQwD0IQD6EAB9CIA+BEAfAqAPAdCHAOhDAPQhAPoQAH0IgD4EQB8CoA8B0IcA6EMA9CEA+hAAfQiAvnQAvPBFHZVpL6uRe4F6xqfc6Wnt6m/yd7mBn9P4LPmDSn5nZn7gszZIU5Onez+HE7VPZJB2EScPviYCZxomiU6J4xKrJKZL9EhUSRyWGJDQJN6XMEt8KHFMwipxQqJGoleiS6JPol+iXaJDYlhimcQGiZMSMyScEjMlTkmclohInJEolZgrcVZit8Q5ifUSPomQxD6JjRL7JeISHonFEvUSdokRib0SKyQMiVqJQxI5EuclVkokJLZK7JC4ILFHolCiQOKiRJHELoliiQaJQYnNEo0SlyRcEk0SlyWaJTZJXJFokbgqcU2iVeKAxDYJh8ROie0S1yUOSrRJ3BDwJNOLbNB+gHcFSCsfega6C1oO1UHTobuhGdBMaBY0G3oWKoFKoTnQXOh+qAx6DnoAmg+VQw9Dj0CPQlXQ49BiqB56EloC1UAroOehpVAtlAPlQtOgldALUAFUCBVBxVADdA90L9QIzYPugx6EXoSaoIegZqgCWgBVQo9BC6FFUAtUDT0BtUJPQU9DL0EvQ23QK9CrkAV6DVoNvQ69Ab0JrYHegt6G1kLvQN3QOsgEdUKroB5Ig8yQFeqF+qB+qB3qgLqkPNrlL2qz+Gm3iJ/R9z1TH0v2pcDU+YpPvhu8MmmPv+OC+vpVlE865ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts65ts6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zwz5M0P+zJA/M+TPDPkzQ/7MkD8z5M8M+TND/syQPzPkzwz5M0P+zJA/M+TPDPkzQ/7MkD8z5M8M+TND/syQPzPkzwz5M0P+zJA/M+TPDPkzQ/7MkD8z5M8M+TND/syQPzPkzwz5M5PPn/NHF2rj/6akI/9Z2adyb+K2gIXjX8v92cvQVWgquhiVoSJ0QahkfKFzdR8xMxfNgVV1fOTE3D/WhFxhHu7HZL7tY8yznTW99k80rfY9zab9i5pE++6TZ4ucPKN37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37KR37Mz3jg/xcTWvBv+SPBpDzA/xUoh5IcaFWBJiSogXQ6wMEQ/xQogFIV4JcTjE0hAvh6gMsSzEwhDLQzSHaAjRFOLVEK+FeCbEGyEmh1gRYl2I/SGSIU6FmBpiVYjpIQ6FeDdEV4jtIfaEGB9iTYiBECdCHAixNcSOEHND3BXi2RClIWIhXg/xfIh0iEkh3gyxO8SREJtC7AqxL8RbIaaFeDvE3hBrQ9SEKArxTogZITIhxoY4GmJCiJ0hJoaoDbExRHuImSHeC1EX4liIWSE2hzgeYnaIkyHmhFgdYluI90McDJCMPzzycYz5QvgFOr8v0Pl9gc7vC/R6X6AP/EK+83sk96Ojlm1RtJNkYrSho3lMR/7dCN/K9aQJAm8dUaeOqFNHGK4jDNcRg+oIw3UEnzqicR3RuI5oXEdEqiMo1xGY6ojNdcSnOkJ0HWGqjkhdR6SuI2jVEbDriF11xO064nYdcbuOuF1HQKsjoNURxeuI4nVE8TqieB3Bro5gXkfMqyPY1RHa6wh2dQS7OgJ9HYG+jkBfRwSs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AZWiiSiGatH5aC66AF2I7kUXoYvRJFSGJqNL0KXoMnQ5ug9dga5EV6EHUDm6Gl2DrkXXoevRDehGdBO6GU1Bt6Bb0W1oKqpAc9Dt6A50J6pEVageVaOaUMn4+2xTfY61oOdYjnuORcvnWGB8jimo51i4e441pOdYQ3qORb3nWFF6jkXE51hfeo71pedYUnyOpcHnWHt6jrWn51h7eo5FxOdYiXqOlajnWIl6juXG51hufI5VqrzmoSkoiVaiqWgpmoZeRqtQJXobLUTL0V7UgKajtagGHUJF6B00A72LutB29BLKoD1oPBqLjqIJaCc6jCaiWrQRtaOZaDFqRO+hNagOHUOz0Hy0GR1HS1AczUYn0Ek0Bx1AW9EytBrtQNvQ++ggmotOhUrGTzE1/iWmxr/E1PiXOA2/xNT4l5ga/xIv7y8xNf6l/H/2777/N1/75C3XfjS68sJbrp2V37+Pt1z7zez4bscn7fr3265//Hdc+/vcmVmdfdzV0fdHQ81f5s/bgdx3L4h+66Nb0LfmboE7zT6E/xkUgDwWh2gMMRBifoiXQswLMS7EkhBTQqwMEQ+xIMThEEtDVIZYFmJhiOUhmkM0hGgKkIz/Dyc9o97wG5Sj0Zd4+FGA/zV698n6qKFcPabje/tQwG/+6LbADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADbTADfkWeJAdvlVktyoCeRWBPK8BNB+9hOahcWgJmoJWojhagA6jpagSLUML0XLUjBpQU6hkNq6SaT98wruQbT905vuj5rvPTjz/WNPdZ6eis6Px2RPg356TvpeJ8Cim/kX0hX+CGfFCCPvwqfEPzdEfPkU+Gtx+oKnyH2yG/MNj3/cxU35WICwEwf+PutBMXWjm/G7mjG7mzGzmzGzmnGrmLGqm1jRTa5qpNc3UmmaqSzP1pJl60kw9aaaeNFMzmqkZzdSMZmpGMzWjmSqR12voGfQGmoxWoHVoP0qiU2gq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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'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'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
