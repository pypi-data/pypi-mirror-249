# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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pZf5li4B/kOOqrEU4JOu/F0b/NKfD749SDh+EOn4ydkfuir4z0VG77ZKF78jVR38pszIYfWbHFbvc1i9z2H1PofV+xxW73NYvc9h9T6H1fscVu9zWL3PYfU+h9X7HFbvc1i9z2H1PofV+xxW73NYvc9h9T6H1fscVu9zWL3PYfX+/2DvzuPjLvP8wFsSPgXGHG0wphsw9y0Bxm1bPrBlbGQKDEVDYZdvegokLIwouVwFZYMEAiTOKsqWjXFms0km90ymM8moO1Hi1m42yW4yk7ySSbK21ol2pNEcm0lL0WgmM4qiXxUqfu+Ypulj+5iGf6i3JF9SPZ/n+32OKiarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASarASargdJk9TcqQi9OtPm/h77jJcwPIxbGk2EcDeOdMLaGsS2MeBjbw9gRxsIwXgtjeRg7wzgRxoEwdoWxO4w9YWwMY28IrVOzTfAdu3NqCvkgmG6CueT54gz+tyr+/L842mc035/jNdG+eC20TxZIgp20bcEX/3xu3PxtCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq9hCq/hUuH1yxXh44tvsClaUiWqQuehmWgWmo3moLloHqpG56ML0Hx0IVqALkIXo0vQpehLaCG6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N3kGvckz6E2eQW/yDHqTZ9CbPIPe5Bn0Js+gN3kGvckz6E2eQW/yDHqTZ9CbPIPe5Bn0Js+gN3kGvckz6E2eQW/yDHqTZ9CbPIPe5Bn0Js+gN3kGvckz6E2eQW+yoHHQeOhW6DZoAjQRmgRNhm6HpkBToTugOmgaNB2aAc2E7oTuguqhWVADdDc0G5oDzYXmQfOhRsgJNUELoIXQImgxtARaCi2DlkP3QPdCzdB9kAatgO6HHoBc0EpoFfQg9BDUArVCq6E1UBvUDnVAnVAX1A31QL3QWsgNbZPStT8+t6HNHEBLz7+6zd/Nf/FLuNzm6+IfXcBqiTUSmyW2SByVCEu0SbRLdEjsk+iU6JKokTgkMVuiW+KExDaJHoleibUSyyTcEk8I6GYN/jG9qllVNN4PcY/g4Abjlcubmy/Ty5s/tlc1W2PeXxe6LV9GAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCAetCIepCOetCOetCkepCkepCqetCyepC4etCkepCWepCWepCWepCWepCIepCIepC6elCwexCwexCiexCqetCOesqlKxfyV/WPlfVrEfLgoUbXHTmr/P8KoI5imCOIpijCOYogjmKYI4imKMI5iiCOYpgjiKYowjmKII5imCOIpijCOYogjmKYI4imKMI5iiCOYpgjiKYowjmKII5imCOIpijCOYogjmKYI4imKMI5iiCOYpgjiKYowjmKII5imCOIpijCOYogjmKYI4imKMI5iiCOYpgjiKYowjmKII5imCOIpijCOYogjmKYI4imKMI5iiCOYpgjiKYowjmKII5imCOIpijCOYogjmKYI4imKMI5iiCOYpgjiKYowjmKII5imCOIpijCOYogjmKYI4imKOI4iiiOIq4jSJgowj0KEI7itCOIqYL8kAGtAZa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wbtMrI08xe0mF9llYu31GbzdxNr0Y+0W+0C7f3TtvSu7yuS7TW1Jfjt4ZUvolU1ll9OmsvN7yf4JZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXwKZXxeuvZjXMZzHz4qr6AaaJqUrv2z+cfzg99Qczjcov1/v3kldpkXYGbh0fzPwcv+OubfWuF15Rrnj0qZ9S/Ft+bMUvXW/B+ourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKourKoe7Koe7KoyLKogrKorLKorLKo3bKo3bKonrKowbKo67Ko5LKo8rKourKFqutfcQnOMVwufQyX4BzDJTjHcAnOMVxmcwyX4BzD5TnHcAnOMVyCcwyX4BzDJTjHcNFNQZ3Q01AXVAM9CgUhL9QLhSA3NAYaBh2AhkPjoIPQJugx6HGoHHoGWgsdhmyQD3oWmgFthsLQc9BQqB16HtoKdUAvQEegeuib0ItQA6RDL0GzoW9Bc6FtUA80H2qEnoSaoO2QEyqDWqGXodXQDigCHYUWQDuh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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'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'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
