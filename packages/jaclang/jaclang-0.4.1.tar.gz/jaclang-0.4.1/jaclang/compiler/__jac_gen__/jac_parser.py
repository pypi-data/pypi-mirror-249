# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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jnz2bLX8e/WfmPtnB9/jj/q9xv/RUPgrPuAfnXzQqMTD/8u3p+pXlpbWf+bH6BrVF7enfmZuT30y8xM/X/+lP73XqGYv//fOfgOg/zvsfXtJyl7yr5fet5fet5f866X37SWne0m1XvK2l9TupfftJf966X176X176X176X176X17yeleqksvvW8vGd5L79tL79tL79tL79tL79tL79tLVeql9+2l9+2l9+0l7XvpfXvpfXvpfXvpfXvpfXvpfXvpfXvpfXvpfXupX730vr30vr30vr30vr2UnV7qcy+9by+9by8dQC8Vspfet5fet5fet5fet5fet5fet5d+oJca3Evv20vv20vv20uH00vv20vv20vv20vv20vv20vv20un0kvv20u320u320u320u320u320u320u320u320u320u320u320u320u320u320sv2kt/20tn2ku320u320t/20sP29BqtAa1oKVoHVqOLkXHoxPRSehydAU6BZ2KOtASdC26DiXRVnQ9OhPdgDLoLHQOOg/djM5Ht6Bb0W3odnQRuiRUZ8ffD88gC3iFLqBKLKC2LSCBFlDNGvoqugctRpvQveh+9AC6Dz2IHkLr0dfQw+hRlEMF9AjKh+rs+Adhp/GX+Xj8Zf6WDRXRBnQf6kQb0aNoE9qMtqAc+jq6E30DlVAbehCdjs5AD6Fvom1oO3oMfQuV0T1oFXoc7UR59AR6EnWhCnoKVdHTaBd6Bj2MdqMI7UHPovVoMWpHCbQMFdBe9BxKoTR6Hn0b3Y8eQfvQXegFdAd6ER1AL6GX0d3oFfQAehW9hl5Hb6A30VvobfQOehe9h7rR++gD9CH6CDWhFSiG5qMFaBFaiVajNagFLUXr0HJ0KToenYhOQpejK9Ap6FTUgZaga9F1KIm2ouvRmegGlEFnoXPQeehmdD66Bd2KbkO3o4vQJaE6O74T1sSvzf6Kr6J7URFtQPehTrQRPYo2oc1oC8qhr6M70TdQCbWhB9Hp6Az0EJqpiW81NcWa6v8L3r2NX7QdPYa+hcroHrQKPY52ojx6Aj2JulAFPYWq6Gm0Cz2DHka7UYT2oGfRerQYtaMEWoYKaC96DqVQGj2Pvo3uR4+gfegu9AK6A72IDqCX0MvobvQKegC9il5Dr6M30JvoLfQ2ege9i95D3eh99AH6EH2EmtAKFEPz0QK0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0d2hcom13+bM2ff0mWQfxXmyj+AY2XdweuxbHBo7txz/5rdhmSy7v125fe7xr2//aWDffNjrPxV+/eHBj+3Q18d81uvjOeL1LfqQ9zllua54xU/ueCttglsd/Y8/1Ja3qY1yH7z3LZdoZBX7nWD4K6E8REWIyhAXhJgWYnqIC0PMCDEnxNwQVSHqQswLUR1ifoiZIWpCXBLiohC1IRaEWBji4hCzQlwaYnGIhhCXhVgSYmmIy0MsC7E8xIoQK0NcESIWYlWI1SHWhLgyxNoQ60I0hrgqxPoQV4e4JsS1Ia4LsSFEU4iNIa4PcUOIG0PcFOLmEJtC3BJic4gtIW4N0Rxia4htIW4LcXuIRSHuCHFniO0h4iF2hEiE2BmiJcSuEK0hdofYE2JviH0h7gqxP8SBEAdDHArRFiIZ4nCIIyGOhrg7QC5x1eRhksSPR/k3uQW3lmnvWhrYWprbWjby1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1tLc1paa2/U0t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+00t+2l5vZq3vzvS4wIXyLnS+pBi9EDKIeWoIfQcrQCrUQPo0fQPeg4+ixahTrQarQGdaJH0VrUiB5DvehxdB+ai06gjagb9aEn0JPoKfQ06kcDaDN6BqXRFjSItqJn0SJUhbajBKpBWbQLPYda0W40hJ5HD6IMOoCOoRdQCg2jw2gEvYjuRS+hdvQymo5eQZ9DJ9Hn0SgaQ3n0KnoNvY7eQG+it9DbqAzNRuWoEk1DM9AcVIfmofloJlqIZoXKJa75NLy7VfTmT3d8Qt/d6nt5U6sPmrqceiur7+AtrD78ZOb5SczvaBLzW71n3LXFk7x7ozeU+JXBaHwqi//hYGk1/E+j3zI56fSLQRIXkUtc92m4Ic+/3dz36+3mondC2/Yt3/b9/PvOfYQfyr2ByZteJm96mbzpZfKml8mbXiZvepm86WXyppfJm14mb3qZvOll8qaXyZteJm96mbzpZfKml8mbXiZvepm86WXyppfJm14mb3qZvOll8qaXyZteJm96mbzpZfKml8mbXiZvepm86WXyppfJm14mb3qZvOll8qaXyZteJm96mbzpZfKml8mbXiZvepm86WXyppfJm14mb3qZvOll8qaXyZteJm96mbzpZfKml8mbXiZvepm86WXyppfJm14mb3qZvOll8qaXyZteJm96mbzpZfKml8mbXiZvepm86WXyppfJm14mb3qZvOll8qaXyZteJm96mbzpZfKml8mbXiZvepm86WXyppfJm14mb3qZvOll8qaXyZteJm96mbzpZfKml8mbXiZvepm86S1N3jRNnaa+aHIILp2m3nh+0/NHvOn507zXOSpe/0fYwXxCNj1fz96ArwbDewkNIS4LsSTE5SEuDLEiRCzERSFWh1gT4soQa0NcFWJ2iKtDXBPi2hDXhagPsSFEXYimEPNDXBLihhA3hlgQ4qYQN4fYHGJLiIoQlSG2hpgWYluI20LcGSIeIhFiZ4iaELUhLg6xO8RdIQ6EmBMiGWJxiKUhpodYFmJGiOUhVoa4IsSqEHeHmBViXYjGEOtDzA2xMcT1ITaFuCXErSGaQ5SHuCDE7SEWhbgjRFWI7SGqQ8wMsSNES4hdIVpD7AmxN8S+EPtDHAxxKMS8EG0hDoc4EuJoiIUBcokb6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6Gkm6GkmSj3NjZMHgeITg9HyWlni1eKb8d9UfH5ykfdni781he4PlSvUkuHKdjPrls2sczezzt3MynYzK9vNrHc2s97ZzKp3M6vezax6N7MW2szqZzOrn82syzazWt7Mankz66TNrJ03s3bezBpqMyvpzaykN7OS3sxKejNr582svTaz9trMunoz6+rNrMQ2s8rezEpsM2vuzay5N7Pm3syaezMruM2s2TazZtvMmm0za/XNrOA2s3LfzMp9M6u7zazjN7PW28xabzOr+s2s6jez8tvMym8zK7/NrP83s/7fzPp/M2vEzawRN7M3oJkV4+bSSuWm8wsj5xdGPvzn8EQLJL9ZMXh+YWTwY10YuWXq/ar2l797Bd5ceJC4MDrIcU/xWzYXF0WXR4uijxWjpizxSPR/m+w8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8huk8hksNw5a/jh8YE42fXw/HxuhTV/5ZlOQf+iNkEtdG/9Sfrhj89h8mE7+w8OsNP4gPlfkuPksm/lfRH1nxPh8qMzUl/OPFC+DWH3RRG5VHfeer27+u1e35ovbjLGqbmRmfQ306h4p0DhXpHCrSOVSdJV2IVqAYugitRmvQlWgtugrNRleja9C16DpUjzagOtSE5qNL0A3oRrQA3YRuRpvRFlSBKtFWNA1tQ7ehO1EcJdBOVINq0cVoN7oLHUBzUBItRkvRdLQMzUDL0Up0BVqF7kaz0DrUiNajuWgjuh5tQregW1EzKkcXoNvRInQHqkLbUTWaiXagFrQLtaI9aC/ah/ajg+gQmofa0GF0BB1FC0PlEluLoTq1xFAR/nVLakbbUAvahK5E14XK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hV/8El9cwxdzid8ljnsIhR4unB4iooeI6CEierjEegjnHuKjh8uvh6ju4WLsIWh6uDR7uDR7CKEeLtQeIqmHSOohknqI8R4CqocLvIcLvIfw6uFy72Ew6CHYegi2HoKth2DrYdjoIeZ6iLkehpQebrYehpQebr0eBpgewrKHsOxh8OkhOnuIzh5u5x5u5x5itYdY7eFW7+FWL6kSlaOtaBrahm5Dt6NF6A50J6pC21EcVaOZaAdKoJ2oBrWgWrQLtaLdaA/ai/ahu9B+dADNQQfRITQPtaEkOoyOoKNoIbo7VC7xe8UAzBaarO6o2+qK1peL50R+f3LtPn7L4Pdp6f78B2P/Tfhg7Kl19f/GJvf/VhGOvSVdhpaiJWgLakZb0TY0DS1DM1AcVaOZaAdKoJ1oFWpBu9CVqBXtQevQXrQPXYVmo6vRdegg2oDqUBs6jJLoCDqKbkSbQuUSf0AB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB10kB11kq4L52/gMgzn+05qf9cx+iM1fNf/1OyOQSX//m852JJ4trWf99cmtApvgByf/j3W8r3dm/zyj/+9QmJX0mVC7xhxRBQxRBQxRBQxRBQxRBQ/xBQxRBQxRBQxRBQxRBQxRBQxRBQxRBQxRBQxRBQxRBQxRBQ/x4hiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiChiiC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NUGHoWmQCzoChaAZ0CyoF3oECkMHoBroUagFOgGdhs5AZ6FzUB/0GPQ4tAR6AjoKeaEItByKQvVQOdQGqVAldBJaD/VDG6B26EkoBvmhY1AntA86D+2BLkBd0EXoErQfugwdgq5AcegpaABKQE9DSegZ6Cr0LPQclIKeh16AXoRKoCrIAlmh0dAYqBoaD9VCE6AKqA4aJyug/uBd+bUst8hvd7jZd4t5+7/LYeRXONzUX+Fwk+77YtyxZ7aIuAP3qv9g7CGFA+rPcPgxtUlWQP1H4wsKw+11HE2umy/5IdYE/BYl+LfmS35kvKR4v9TCTVcLd/30/Up/4N7IK9yZs3ijwl/rz5REbtyis3jn0OIdIMVdUU+KjcLdO4duGVu8UezQLV59t+t/HoqI1fslvscjN24XW67/2RAp3iTW+MD9VP4w/VZ/4FNWaa8u7L3GnWt9X44Mu41n4UOlzhH/1D8WP+fCnV+Hdl/jBom+QEQs/C/xbYmIZZglvnn6E1bxxNORG7f0LNzttXDz1KFPoTpKvPCJiHTT18K9Xov7dvEer8b9FH0W+RNYvF2ruB/oRLEx/I6exY9i4carZfqfU/Q//038lWINS5n4n6iT9uNCTvER4wPwYyzcyCEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPziEPzplh70+MAijuU/2QOGBsFXU4ILY6ReH8YsRsfL5t7OIlvr3Gm16iauYvnSnRy6u+kdM3nKLY1omvmSy+7U9RV+ux59fjk2qqFLJCo6DRUBl0GzQGqoZqoHJoPFQLjYUmQBVQJXQndDtkg+6C6qA7oHFQPXQ3NBFqgBohOzQJmgzdA02BFMgBTYWc0L1QEzQNckHToRnQTGgWdB/U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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'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'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
